//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;

#pragma warning disable CS0649
#pragma warning disable CS1658
#pragma warning disable CS1570
#pragma warning disable CS1573
#pragma warning disable CS1574
#pragma warning disable CS1584


namespace NPlug.Interop;


using System.Collections.Generic;

using System.Diagnostics.CodeAnalysis;

using System.Runtime.CompilerServices;

using System.Runtime.InteropServices;

internal static partial class LibVst
{
    public const string SdkVersion = "VST 3.7.7";
    
    public const string AudioEffectCategory = "Audio Module Class";
    
    public const string ComponentControllerCategory = "Component Controller Class";
    
    /// <summary>
    /// FUnknown
    /// The basic interface of all interfaces.
    /// </summary>
    /// <remarks>
    ///  pluginBase- The FUnknown::queryInterface method is used to retrieve pointers to other
    /// interfaces of the object.
    /// - FUnknown::addRef and FUnknown::release manage the lifetime of the object.
    /// If no more references exist, the object is destroyed in memory.Interfaces are identified by 16 byte Globally Unique Identifiers.
    /// The SDK provides a class called FUID for this purpose.@ref howtoClass
    /// </remarks>
    public unsafe partial struct FUnknown : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 3;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            vtbl[0] = (delegate*unmanaged[MemberFunction]<FUnknown*, Guid*, void**, int>)&queryInterface_Wrapper;
            vtbl[1] = (delegate*unmanaged[MemberFunction]<FUnknown*, uint>)&addRef_Wrapper;
            vtbl[2] = (delegate*unmanaged[MemberFunction]<FUnknown*, uint>)&release_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.FUnknown*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(FUnknown), "queryInterface");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.FUnknown*, Guid*, void**, int>)Vtbl[0])(__self__, _iid, obj);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.FUnknown*, Guid*, void**, int>)Vtbl[0])((LibVst.FUnknown*)Unsafe.AsPointer(ref this), _iid, obj);
            }
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.FUnknown*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(FUnknown), "addRef");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.FUnknown*, uint>)Vtbl[1])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.FUnknown*, uint>)Vtbl[1])((LibVst.FUnknown*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.FUnknown*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(FUnknown), "release");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.FUnknown*, uint>)Vtbl[2])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.FUnknown*, uint>)Vtbl[2])((LibVst.FUnknown*)Unsafe.AsPointer(ref this));
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        private static partial ComResult queryInterface_ToManaged(FUnknown* self, Guid* _iid, void** obj);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int queryInterface_Wrapper(FUnknown* self, Guid* _iid, void** obj)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(FUnknown), "queryInterface");
                try
                {
                    return queryInterface_ToManaged(self, _iid, obj);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return queryInterface_ToManaged(self, _iid, obj);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        private static partial uint addRef_ToManaged(FUnknown* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static uint addRef_Wrapper(FUnknown* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(FUnknown), "addRef");
                try
                {
                    return addRef_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return addRef_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        private static partial uint release_ToManaged(FUnknown* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static uint release_Wrapper(FUnknown* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(FUnknown), "release");
                try
                {
                    return release_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return release_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (FUnknown, 0x00000000, 0x00000000, 0xC0000000, 0x00000046)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Base class for streams.
    /// </summary>
    /// <remarks>
    ///  pluginBase- read/write binary data from/to stream
    /// - get/set stream read-write position (read and write position is the same)
    /// </remarks>
    public unsafe partial struct IBStream : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 7;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IBStream*, void*, int, int*, int>)&read_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IBStream*, void*, int, int*, int>)&write_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IBStream*, long, int, long*, int>)&seek_Wrapper;
            vtbl[6] = (delegate*unmanaged[MemberFunction]<IBStream*, long*, int>)&tell_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IBStream, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IBStream, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IBStream, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Reads binary data from stream.
        /// </summary>
        /// <param name="buffer">: destination buffer</param>
        /// <param name="numBytes">: amount of bytes to be read</param>
        /// <param name="numBytesRead">: result - how many bytes have been read from stream (set to 0 if this is of no interest)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult read(void* buffer, int numBytes, int* numBytesRead)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IBStream*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IBStream), "read");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IBStream*, void*, int, int*, int>)Vtbl[3])(__self__, buffer, numBytes, numBytesRead);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IBStream*, void*, int, int*, int>)Vtbl[3])((LibVst.IBStream*)Unsafe.AsPointer(ref this), buffer, numBytes, numBytesRead);
            }
        }
        
        /// <summary>
        /// Writes binary data to stream.
        /// </summary>
        /// <param name="buffer">: source buffer</param>
        /// <param name="numBytes">: amount of bytes to write</param>
        /// <param name="numBytesWritten">: result - how many bytes have been written to stream (set to 0 if this is of no interest)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult write(void* buffer, int numBytes, int* numBytesWritten)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IBStream*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IBStream), "write");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IBStream*, void*, int, int*, int>)Vtbl[4])(__self__, buffer, numBytes, numBytesWritten);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IBStream*, void*, int, int*, int>)Vtbl[4])((LibVst.IBStream*)Unsafe.AsPointer(ref this), buffer, numBytes, numBytesWritten);
            }
        }
        
        /// <summary>
        /// Sets stream read-write position.
        /// </summary>
        /// <param name="pos">: new stream position (dependent on mode)</param>
        /// <param name="mode">: value of enum IStreamSeekMode</param>
        /// <param name="result">: new seek position (set to 0 if this is of no interest)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult seek(long pos, int mode, long* result)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IBStream*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IBStream), "seek");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IBStream*, long, int, long*, int>)Vtbl[5])(__self__, pos, mode, result);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IBStream*, long, int, long*, int>)Vtbl[5])((LibVst.IBStream*)Unsafe.AsPointer(ref this), pos, mode, result);
            }
        }
        
        /// <summary>
        /// Gets current stream read-write position.
        /// </summary>
        /// <param name="pos">: is assigned the current position if function succeeds</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult tell(long* pos)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IBStream*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IBStream), "tell");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IBStream*, long*, int>)Vtbl[6])(__self__, pos);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IBStream*, long*, int>)Vtbl[6])((LibVst.IBStream*)Unsafe.AsPointer(ref this), pos);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Reads binary data from stream.
        /// </summary>
        /// <param name="buffer">: destination buffer</param>
        /// <param name="numBytes">: amount of bytes to be read</param>
        /// <param name="numBytesRead">: result - how many bytes have been read from stream (set to 0 if this is of no interest)</param>
        private static partial ComResult read_ToManaged(IBStream* self, void* buffer, int numBytes, int* numBytesRead);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int read_Wrapper(IBStream* self, void* buffer, int numBytes, int* numBytesRead)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IBStream), "read");
                try
                {
                    return read_ToManaged(self, buffer, numBytes, numBytesRead);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return read_ToManaged(self, buffer, numBytes, numBytesRead);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Writes binary data to stream.
        /// </summary>
        /// <param name="buffer">: source buffer</param>
        /// <param name="numBytes">: amount of bytes to write</param>
        /// <param name="numBytesWritten">: result - how many bytes have been written to stream (set to 0 if this is of no interest)</param>
        private static partial ComResult write_ToManaged(IBStream* self, void* buffer, int numBytes, int* numBytesWritten);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int write_Wrapper(IBStream* self, void* buffer, int numBytes, int* numBytesWritten)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IBStream), "write");
                try
                {
                    return write_ToManaged(self, buffer, numBytes, numBytesWritten);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return write_ToManaged(self, buffer, numBytes, numBytesWritten);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Sets stream read-write position.
        /// </summary>
        /// <param name="pos">: new stream position (dependent on mode)</param>
        /// <param name="mode">: value of enum IStreamSeekMode</param>
        /// <param name="result">: new seek position (set to 0 if this is of no interest)</param>
        private static partial ComResult seek_ToManaged(IBStream* self, long pos, int mode, long* result);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int seek_Wrapper(IBStream* self, long pos, int mode, long* result)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IBStream), "seek");
                try
                {
                    return seek_ToManaged(self, pos, mode, result);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return seek_ToManaged(self, pos, mode, result);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets current stream read-write position.
        /// </summary>
        /// <param name="pos">: is assigned the current position if function succeeds</param>
        private static partial ComResult tell_ToManaged(IBStream* self, long* pos);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int tell_Wrapper(IBStream* self, long* pos)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IBStream), "tell");
                try
                {
                    return tell_ToManaged(self, pos);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return tell_ToManaged(self, pos);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        public enum IStreamSeekMode
        {
            /// <summary>
            /// set absolute seek position
            /// </summary>
            kIBSeekSet = 0,
            
            /// <summary>
            /// set seek position relative to current position
            /// </summary>
            kIBSeekCur,
            
            /// <summary>
            /// set seek position relative to stream end
            /// </summary>
            kIBSeekEnd,
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IBStream, 0xC3BF6EA2, 0x30994752, 0x9B6BF990, 0x1EE33E9B)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xa2, 0x6e, 0xbf, 0xc3, 0x99, 0x30, 0x52, 0x47, 0x9b, 0x6b, 0xf9, 0x90, 0x1e, 0xe3, 0x3e, 0x9b })
                        : new ReadOnlySpan<byte>(new byte[] { 0xc3, 0xbf, 0x6e, 0xa2, 0x30, 0x99, 0x47, 0x52, 0x9b, 0x6b, 0xf9, 0x90, 0x1e, 0xe3, 0x3e, 0x9b })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Object Data Archive Interface. 
    /// - [host imp]
    /// </summary>
    /// <remarks>
    /// - store data/objects/binary/subattributes in the archive
    /// - read stored data from the archiveAll data stored to the archive are identified by a string (IAttrID), which must be unique on each
    /// IAttribute level.The basic set/get methods make use of the FVariant class defined in 'funknown.h'.
    /// For a more convenient usage of this interface, you should use the functions defined
    /// in namespace PAttributes (public.sdk/source/common/pattributes.h+cpp) !! frameworkHostClasses
    /// </remarks>
    public unsafe partial struct IAttributes : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 13;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IAttributes*, byte*, LibVst.FVariant*, int>)&set_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IAttributes*, byte*, LibVst.FVariant*, int>)&queue_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IAttributes*, byte*, void*, uint, byte, int>)&setBinaryData_Wrapper;
            vtbl[6] = (delegate*unmanaged[MemberFunction]<IAttributes*, byte*, LibVst.FVariant*, int>)&get_Wrapper;
            vtbl[7] = (delegate*unmanaged[MemberFunction]<IAttributes*, byte*, LibVst.FVariant*, int>)&unqueue_Wrapper;
            vtbl[8] = (delegate*unmanaged[MemberFunction]<IAttributes*, byte*, int>)&getQueueItemCount_Wrapper;
            vtbl[9] = (delegate*unmanaged[MemberFunction]<IAttributes*, byte*, int>)&resetQueue_Wrapper;
            vtbl[10] = (delegate*unmanaged[MemberFunction]<IAttributes*, int>)&resetAllQueues_Wrapper;
            vtbl[11] = (delegate*unmanaged[MemberFunction]<IAttributes*, byte*, void*, uint, int>)&getBinaryData_Wrapper;
            vtbl[12] = (delegate*unmanaged[MemberFunction]<IAttributes*, byte*, uint>)&getBinaryDataSize_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IAttributes, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IAttributes, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IAttributes, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        ///  Methods to write attributes*******************************************************************************************************@
        /// {
        /// Store any data in the archive. It is even possible to store sub-attributes by creating
        /// a new IAttributes instance via the IHostClasses interface and pass it to the parent in the
        /// FVariant. In this case the archive must take the ownership of the newly created object, which
        /// is true for all objects that have been created only for storing. You tell the archive to take
        /// ownership by adding the FVariant::kOwner flag to the FVariant::type member (data.type |= FVariant::kOwner).
        /// When using the PAttributes functions, this is done through a function parameter.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult set(byte* attrID, LibVst.FVariant* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributes*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributes), "set");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, byte*, LibVst.FVariant*, int>)Vtbl[3])(__self__, attrID, data);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, byte*, LibVst.FVariant*, int>)Vtbl[3])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), attrID, data);
            }
        }
        
        /// <summary>
        /// Store a list of data in the archive. Please note that the type of data is not mixable! So
        /// you can only store a list of integers or a list of doubles/strings/etc. You can also store a list
        /// of subattributes or other objects that implement the IPersistent interface.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queue(byte* listID, LibVst.FVariant* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributes*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributes), "queue");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, byte*, LibVst.FVariant*, int>)Vtbl[4])(__self__, listID, data);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, byte*, LibVst.FVariant*, int>)Vtbl[4])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), listID, data);
            }
        }
        
        /// <summary>
        /// Store binary data in the archive. Parameter 'copyBytes' specifies if the passed data should be copied.
        /// The archive cannot take the ownership of binary data. Either it just references a buffer in order
        /// to write it to a file (copyBytes = false) or it copies the data to its own buffers (copyBytes = true).
        /// When binary data should be stored in the default pool for example, you must always copy it!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setBinaryData(byte* attrID, void* data, uint bytes, byte copyBytes)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributes*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributes), "setBinaryData");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, byte*, void*, uint, byte, int>)Vtbl[5])(__self__, attrID, data, bytes, copyBytes);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, byte*, void*, uint, byte, int>)Vtbl[5])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), attrID, data, bytes, copyBytes);
            }
        }
        
        /// <remarks>
        ///  Methods to read attributes*******************************************************************************************************@
        /// {
        /// Get data previously stored to the archive.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult get(byte* attrID, LibVst.FVariant* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributes*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributes), "get");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, byte*, LibVst.FVariant*, int>)Vtbl[6])(__self__, attrID, data);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, byte*, LibVst.FVariant*, int>)Vtbl[6])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), attrID, data);
            }
        }
        
        /// <summary>
        /// Get list of data previously stored to the archive. As long as there are queue members the method
        /// will return kResultTrue. When the queue is empty, the methods returns kResultFalse. All lists except from
        /// object lists can be reset which means that the items can be read once again.
        /// </summary>
        /// <seealso cref="IAttributes::resetQueue "/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult unqueue(byte* listID, LibVst.FVariant* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributes*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributes), "unqueue");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, byte*, LibVst.FVariant*, int>)Vtbl[7])(__self__, listID, data);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, byte*, LibVst.FVariant*, int>)Vtbl[7])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), listID, data);
            }
        }
        
        /// <summary>
        /// Get the amount of items in a queue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getQueueItemCount(byte* arg)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributes*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributes), "getQueueItemCount");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, byte*, int>)Vtbl[8])(__self__, arg);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, byte*, int>)Vtbl[8])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), arg);
            }
        }
        
        /// <summary>
        /// Reset a queue. If you need to restart reading a queue, you have to reset it. You can reset a queue at any time.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult resetQueue(byte* attrID)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributes*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributes), "resetQueue");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, byte*, int>)Vtbl[9])(__self__, attrID);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, byte*, int>)Vtbl[9])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), attrID);
            }
        }
        
        /// <summary>
        /// Reset all queues in the archive.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult resetAllQueues()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributes*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributes), "resetAllQueues");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, int>)Vtbl[10])(__self__);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, int>)Vtbl[10])((LibVst.IAttributes*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Read binary data from the archive. The data is copied into the passed buffer. The size of that buffer
        /// must fit the size of data stored in the archive which can be queried via IAttributes::getBinaryDataSize
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getBinaryData(byte* attrID, void* data, uint bytes)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributes*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributes), "getBinaryData");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, byte*, void*, uint, int>)Vtbl[11])(__self__, attrID, data, bytes);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, byte*, void*, uint, int>)Vtbl[11])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), attrID, data, bytes);
            }
        }
        
        /// <summary>
        /// Get the size in bytes of binary data in the archive.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint getBinaryDataSize(byte* attrID)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributes*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributes), "getBinaryDataSize");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, byte*, uint>)Vtbl[12])(__self__, attrID);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes*, byte*, uint>)Vtbl[12])((LibVst.IAttributes*)Unsafe.AsPointer(ref this), attrID);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        ///  Methods to write attributes*******************************************************************************************************@
        /// {
        /// Store any data in the archive. It is even possible to store sub-attributes by creating
        /// a new IAttributes instance via the IHostClasses interface and pass it to the parent in the
        /// FVariant. In this case the archive must take the ownership of the newly created object, which
        /// is true for all objects that have been created only for storing. You tell the archive to take
        /// ownership by adding the FVariant::kOwner flag to the FVariant::type member (data.type |= FVariant::kOwner).
        /// When using the PAttributes functions, this is done through a function parameter.
        /// </remarks>
        private static partial ComResult set_ToManaged(IAttributes* self, byte* attrID, LibVst.FVariant* data);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int set_Wrapper(IAttributes* self, byte* attrID, LibVst.FVariant* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributes), "set");
                try
                {
                    return set_ToManaged(self, attrID, data);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return set_ToManaged(self, attrID, data);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Store a list of data in the archive. Please note that the type of data is not mixable! So
        /// you can only store a list of integers or a list of doubles/strings/etc. You can also store a list
        /// of subattributes or other objects that implement the IPersistent interface.
        /// </summary>
        private static partial ComResult queue_ToManaged(IAttributes* self, byte* listID, LibVst.FVariant* data);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int queue_Wrapper(IAttributes* self, byte* listID, LibVst.FVariant* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributes), "queue");
                try
                {
                    return queue_ToManaged(self, listID, data);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return queue_ToManaged(self, listID, data);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Store binary data in the archive. Parameter 'copyBytes' specifies if the passed data should be copied.
        /// The archive cannot take the ownership of binary data. Either it just references a buffer in order
        /// to write it to a file (copyBytes = false) or it copies the data to its own buffers (copyBytes = true).
        /// When binary data should be stored in the default pool for example, you must always copy it!
        /// </summary>
        private static partial ComResult setBinaryData_ToManaged(IAttributes* self, byte* attrID, void* data, uint bytes, byte copyBytes);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setBinaryData_Wrapper(IAttributes* self, byte* attrID, void* data, uint bytes, byte copyBytes)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributes), "setBinaryData");
                try
                {
                    return setBinaryData_ToManaged(self, attrID, data, bytes, copyBytes);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setBinaryData_ToManaged(self, attrID, data, bytes, copyBytes);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <remarks>
        ///  Methods to read attributes*******************************************************************************************************@
        /// {
        /// Get data previously stored to the archive.
        /// </remarks>
        private static partial ComResult get_ToManaged(IAttributes* self, byte* attrID, LibVst.FVariant* data);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int get_Wrapper(IAttributes* self, byte* attrID, LibVst.FVariant* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributes), "get");
                try
                {
                    return get_ToManaged(self, attrID, data);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return get_ToManaged(self, attrID, data);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Get list of data previously stored to the archive. As long as there are queue members the method
        /// will return kResultTrue. When the queue is empty, the methods returns kResultFalse. All lists except from
        /// object lists can be reset which means that the items can be read once again.
        /// </summary>
        /// <seealso cref="IAttributes::resetQueue "/>
        private static partial ComResult unqueue_ToManaged(IAttributes* self, byte* listID, LibVst.FVariant* data);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int unqueue_Wrapper(IAttributes* self, byte* listID, LibVst.FVariant* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributes), "unqueue");
                try
                {
                    return unqueue_ToManaged(self, listID, data);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return unqueue_ToManaged(self, listID, data);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Get the amount of items in a queue.
        /// </summary>
        private static partial int getQueueItemCount_ToManaged(IAttributes* self, byte* arg);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getQueueItemCount_Wrapper(IAttributes* self, byte* arg)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributes), "getQueueItemCount");
                try
                {
                    return getQueueItemCount_ToManaged(self, arg);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getQueueItemCount_ToManaged(self, arg);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Reset a queue. If you need to restart reading a queue, you have to reset it. You can reset a queue at any time.
        /// </summary>
        private static partial ComResult resetQueue_ToManaged(IAttributes* self, byte* attrID);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int resetQueue_Wrapper(IAttributes* self, byte* attrID)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributes), "resetQueue");
                try
                {
                    return resetQueue_ToManaged(self, attrID);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return resetQueue_ToManaged(self, attrID);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Reset all queues in the archive.
        /// </summary>
        private static partial ComResult resetAllQueues_ToManaged(IAttributes* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int resetAllQueues_Wrapper(IAttributes* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributes), "resetAllQueues");
                try
                {
                    return resetAllQueues_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return resetAllQueues_ToManaged(self);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Read binary data from the archive. The data is copied into the passed buffer. The size of that buffer
        /// must fit the size of data stored in the archive which can be queried via IAttributes::getBinaryDataSize
        /// </summary>
        private static partial ComResult getBinaryData_ToManaged(IAttributes* self, byte* attrID, void* data, uint bytes);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getBinaryData_Wrapper(IAttributes* self, byte* attrID, void* data, uint bytes)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributes), "getBinaryData");
                try
                {
                    return getBinaryData_ToManaged(self, attrID, data, bytes);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getBinaryData_ToManaged(self, attrID, data, bytes);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Get the size in bytes of binary data in the archive.
        /// </summary>
        private static partial uint getBinaryDataSize_ToManaged(IAttributes* self, byte* attrID);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static uint getBinaryDataSize_Wrapper(IAttributes* self, byte* attrID)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributes), "getBinaryDataSize");
                try
                {
                    return getBinaryDataSize_ToManaged(self, attrID);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getBinaryDataSize_ToManaged(self, attrID);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IAttributes, 0xFA1E32F9, 0xCA6D46F5, 0xA982F956, 0xB1191B58)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xf9, 0x32, 0x1e, 0xfa, 0x6d, 0xca, 0xf5, 0x46, 0xa9, 0x82, 0xf9, 0x56, 0xb1, 0x19, 0x1b, 0x58 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xfa, 0x1e, 0x32, 0xf9, 0xca, 0x6d, 0x46, 0xf5, 0xa9, 0x82, 0xf9, 0x56, 0xb1, 0x19, 0x1b, 0x58 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// FVariant struct declaration
    /// A Value of variable type.
    /// </summary>
    /// <remarks>
    ///  pluginBase
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct FVariant
    {
        /// <summary>
        /// 
        /// </summary>
        public ushort type;
        
        [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Unicode)]
        public unsafe partial struct Union
        {
            [FieldOffset(0)]
            public long intValue;
            
            [FieldOffset(0)]
            public double floatValue;
            
            [FieldOffset(0)]
            public byte* string8;
            
            [FieldOffset(0)]
            public char* string16;
            
            [FieldOffset(0)]
            public LibVst.FUnknown* @object;
        }
        
        public LibVst.FVariant.Union union;
        
        /// <summary>
        /// 
        /// </summary>
        public enum fvariant
        {
            kEmpty = 0,
            
            kInteger = 1 << 0,
            
            kFloat = 1 << 1,
            
            kString8 = 1 << 2,
            
            kObject = 1 << 3,
            
            kOwner = 1 << 4,
            
            kString16 = 1 << 5,
        }
    }
    
    /// <summary>
    /// Extended access to Attributes; supports Attribute retrieval via iteration. 
    /// - [host imp]
    /// - [released] C7/N6
    /// </summary>
    /// <remarks>
    ///  frameworkHostClasses
    /// </remarks>
    public unsafe partial struct IAttributes2 : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 15;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            IAttributes.InitializeVtbl(vtbl);
            vtbl[13] = (delegate*unmanaged[MemberFunction]<IAttributes2*, int>)&countAttributes_Wrapper;
            vtbl[14] = (delegate*unmanaged[MemberFunction]<IAttributes2*, int, LibVst.FIDString>)&getAttributeID_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IAttributes2, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IAttributes2, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IAttributes2, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <remarks>
        ///  Methods to write attributes*******************************************************************************************************@
        /// {
        /// Store any data in the archive. It is even possible to store sub-attributes by creating
        /// a new IAttributes instance via the IHostClasses interface and pass it to the parent in the
        /// FVariant. In this case the archive must take the ownership of the newly created object, which
        /// is true for all objects that have been created only for storing. You tell the archive to take
        /// ownership by adding the FVariant::kOwner flag to the FVariant::type member (data.type |= FVariant::kOwner).
        /// When using the PAttributes functions, this is done through a function parameter.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult set(byte* attrID, LibVst.FVariant* data)
        {
            return Unsafe.As<IAttributes2, IAttributes>(ref this).set(attrID, data);
        }
        
        /// <summary>
        /// Store a list of data in the archive. Please note that the type of data is not mixable! So
        /// you can only store a list of integers or a list of doubles/strings/etc. You can also store a list
        /// of subattributes or other objects that implement the IPersistent interface.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queue(byte* listID, LibVst.FVariant* data)
        {
            return Unsafe.As<IAttributes2, IAttributes>(ref this).queue(listID, data);
        }
        
        /// <summary>
        /// Store binary data in the archive. Parameter 'copyBytes' specifies if the passed data should be copied.
        /// The archive cannot take the ownership of binary data. Either it just references a buffer in order
        /// to write it to a file (copyBytes = false) or it copies the data to its own buffers (copyBytes = true).
        /// When binary data should be stored in the default pool for example, you must always copy it!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setBinaryData(byte* attrID, void* data, uint bytes, byte copyBytes)
        {
            return Unsafe.As<IAttributes2, IAttributes>(ref this).setBinaryData(attrID, data, bytes, copyBytes);
        }
        
        /// <remarks>
        ///  Methods to read attributes*******************************************************************************************************@
        /// {
        /// Get data previously stored to the archive.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult get(byte* attrID, LibVst.FVariant* data)
        {
            return Unsafe.As<IAttributes2, IAttributes>(ref this).get(attrID, data);
        }
        
        /// <summary>
        /// Get list of data previously stored to the archive. As long as there are queue members the method
        /// will return kResultTrue. When the queue is empty, the methods returns kResultFalse. All lists except from
        /// object lists can be reset which means that the items can be read once again.
        /// </summary>
        /// <seealso cref="IAttributes::resetQueue "/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult unqueue(byte* listID, LibVst.FVariant* data)
        {
            return Unsafe.As<IAttributes2, IAttributes>(ref this).unqueue(listID, data);
        }
        
        /// <summary>
        /// Get the amount of items in a queue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getQueueItemCount(byte* arg)
        {
            return Unsafe.As<IAttributes2, IAttributes>(ref this).getQueueItemCount(arg);
        }
        
        /// <summary>
        /// Reset a queue. If you need to restart reading a queue, you have to reset it. You can reset a queue at any time.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult resetQueue(byte* attrID)
        {
            return Unsafe.As<IAttributes2, IAttributes>(ref this).resetQueue(attrID);
        }
        
        /// <summary>
        /// Reset all queues in the archive.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult resetAllQueues()
        {
            return Unsafe.As<IAttributes2, IAttributes>(ref this).resetAllQueues();
        }
        
        /// <summary>
        /// Read binary data from the archive. The data is copied into the passed buffer. The size of that buffer
        /// must fit the size of data stored in the archive which can be queried via IAttributes::getBinaryDataSize
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getBinaryData(byte* attrID, void* data, uint bytes)
        {
            return Unsafe.As<IAttributes2, IAttributes>(ref this).getBinaryData(attrID, data, bytes);
        }
        
        /// <summary>
        /// Get the size in bytes of binary data in the archive.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint getBinaryDataSize(byte* attrID)
        {
            return Unsafe.As<IAttributes2, IAttributes>(ref this).getBinaryDataSize(attrID);
        }
        
        /// <summary>
        /// Returns the number of existing attributes.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int countAttributes()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributes2*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributes2), "countAttributes");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes2*, int>)Vtbl[13])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes2*, int>)Vtbl[13])((LibVst.IAttributes2*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Returns the attribute's ID for the given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.FIDString getAttributeID(int index)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributes2*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributes2), "getAttributeID");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes2*, int, LibVst.FIDString>)Vtbl[14])(__self__, index);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributes2*, int, LibVst.FIDString>)Vtbl[14])((LibVst.IAttributes2*)Unsafe.AsPointer(ref this), index);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns the number of existing attributes.
        /// </summary>
        private static partial int countAttributes_ToManaged(IAttributes2* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int countAttributes_Wrapper(IAttributes2* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributes2), "countAttributes");
                try
                {
                    return countAttributes_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return countAttributes_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Returns the attribute's ID for the given index.
        /// </summary>
        private static partial LibVst.IAttrID getAttributeID_ToManaged(IAttributes2* self, int index);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static LibVst.FIDString getAttributeID_Wrapper(IAttributes2* self, int index)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributes2), "getAttributeID");
                try
                {
                    return getAttributeID_ToManaged(self, index);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getAttributeID_ToManaged(self, index);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IAttributes2, 0x1382126A, 0xFECA4871, 0x97D52A45, 0xB042AE99)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x6a, 0x12, 0x82, 0x13, 0xca, 0xfe, 0x71, 0x48, 0x97, 0xd5, 0x2a, 0x45, 0xb0, 0x42, 0xae, 0x99 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x13, 0x82, 0x12, 0x6a, 0xfe, 0xca, 0x48, 0x71, 0x97, 0xd5, 0x2a, 0x45, 0xb0, 0x42, 0xae, 0x99 })
                    )));
            }
        }
    }
    
    public unsafe partial struct FIDString
    {
        public byte* Value;
        
        public static implicit operator byte*(FIDString value) => value.Value;
        
        public static implicit operator FIDString(byte* value) => new FIDString() { Value = value };
    }
    
    public partial record struct IAttrID(LibVst.FIDString Value)
    {
        public static implicit operator LibVst.FIDString(IAttrID value) => value.Value;
        
        public static implicit operator IAttrID(LibVst.FIDString value) => new(value);
    }
    
    /// <summary>
    /// Basic interface to a plug-in component: IPluginBase
    /// </summary>
    /// <remarks>
    ///  pluginBase- [plug imp]
    /// - initialize/terminate the plug-in componentThe host uses this interface to initialize and to terminate the plug-in component.
    /// The context that is passed to the initialize method contains any interface to the
    /// host that the plug-in will need to work. These interfaces can vary from category to category.
    /// A list of supported host context interfaces should be included in the documentation
    /// of a specific category.
    /// </remarks>
    public unsafe partial struct IPluginBase : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 5;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IPluginBase*, LibVst.FUnknown*, int>)&initialize_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IPluginBase*, int>)&terminate_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IPluginBase, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IPluginBase, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IPluginBase, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// The host passes a number of interfaces as context to initialize the plug-in class.
        /// </summary>
        /// <param name="context,">passed by the host, is mandatory and should implement IHostApplication</param>
        /// <note>
        /// Extensive memory allocations etc. should be performed in this method rather than in
        /// the class' constructor! If the method does NOT return kResultOk, the object is released
        /// immediately. In this case terminate is not called!
        /// </note>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult initialize(LibVst.FUnknown* context)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPluginBase*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPluginBase), "initialize");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPluginBase*, LibVst.FUnknown*, int>)Vtbl[3])(__self__, context);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPluginBase*, LibVst.FUnknown*, int>)Vtbl[3])((LibVst.IPluginBase*)Unsafe.AsPointer(ref this), context);
            }
        }
        
        /// <summary>
        /// This function is called before the plug-in is unloaded and can be used for
        /// cleanups. You have to release all references to any host application interfaces.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult terminate()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPluginBase*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPluginBase), "terminate");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPluginBase*, int>)Vtbl[4])(__self__);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPluginBase*, int>)Vtbl[4])((LibVst.IPluginBase*)Unsafe.AsPointer(ref this));
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// The host passes a number of interfaces as context to initialize the plug-in class.
        /// </summary>
        /// <param name="context,">passed by the host, is mandatory and should implement IHostApplication</param>
        /// <note>
        /// Extensive memory allocations etc. should be performed in this method rather than in
        /// the class' constructor! If the method does NOT return kResultOk, the object is released
        /// immediately. In this case terminate is not called!
        /// </note>
        private static partial ComResult initialize_ToManaged(IPluginBase* self, LibVst.FUnknown* context);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int initialize_Wrapper(IPluginBase* self, LibVst.FUnknown* context)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPluginBase), "initialize");
                try
                {
                    return initialize_ToManaged(self, context);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return initialize_ToManaged(self, context);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// This function is called before the plug-in is unloaded and can be used for
        /// cleanups. You have to release all references to any host application interfaces.
        /// </summary>
        private static partial ComResult terminate_ToManaged(IPluginBase* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int terminate_Wrapper(IPluginBase* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPluginBase), "terminate");
                try
                {
                    return terminate_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return terminate_ToManaged(self);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPluginBase, 0x22888DDB, 0x156E45AE, 0x8358B348, 0x08190625)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xdb, 0x8d, 0x88, 0x22, 0x6e, 0x15, 0xae, 0x45, 0x83, 0x58, 0xb3, 0x48, 0x08, 0x19, 0x06, 0x25 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x22, 0x88, 0x8d, 0xdb, 0x15, 0x6e, 0x45, 0xae, 0x83, 0x58, 0xb3, 0x48, 0x08, 0x19, 0x06, 0x25 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// IPluginFactory interface declaration
    /// Class factory that any plug-in defines for creating class instances: IPluginFactory
    /// </summary>
    /// <remarks>
    ///  pluginBase- [plug imp]From the host's point of view a plug-in module is a factory which can create
    /// a certain kind of object(s). The interface IPluginFactory provides methods
    /// to get information about the classes exported by the plug-in and a
    /// mechanism to create instances of these classes (that usually define the IPluginBase interface).&lt;b&gt;An implementation is provided in public.sdk/source/common/pluginfactory.cpp &lt;/b&gt;
    /// </remarks>
    /// <seealso cref="GetPluginFactory"/>
    public unsafe partial struct IPluginFactory : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 7;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IPluginFactory*, LibVst.PFactoryInfo*, int>)&getFactoryInfo_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IPluginFactory*, int>)&countClasses_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IPluginFactory*, int, LibVst.PClassInfo*, int>)&getClassInfo_Wrapper;
            vtbl[6] = (delegate*unmanaged[MemberFunction]<IPluginFactory*, byte*, byte*, void**, int>)&createInstance_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IPluginFactory, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IPluginFactory, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IPluginFactory, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Fill a PFactoryInfo structure with information about the plug-in vendor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getFactoryInfo(LibVst.PFactoryInfo* info)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPluginFactory*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPluginFactory), "getFactoryInfo");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPluginFactory*, LibVst.PFactoryInfo*, int>)Vtbl[3])(__self__, info);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPluginFactory*, LibVst.PFactoryInfo*, int>)Vtbl[3])((LibVst.IPluginFactory*)Unsafe.AsPointer(ref this), info);
            }
        }
        
        /// <summary>
        /// Returns the number of exported classes by this factory. If you are using the CPluginFactory
        /// implementation provided by the SDK, it returns the number of classes you registered with
        /// CPluginFactory::registerClass.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int countClasses()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPluginFactory*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPluginFactory), "countClasses");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPluginFactory*, int>)Vtbl[4])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPluginFactory*, int>)Vtbl[4])((LibVst.IPluginFactory*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Fill a PClassInfo structure with information about the class at the specified index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getClassInfo(int index, LibVst.PClassInfo* info)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPluginFactory*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPluginFactory), "getClassInfo");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPluginFactory*, int, LibVst.PClassInfo*, int>)Vtbl[5])(__self__, index, info);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPluginFactory*, int, LibVst.PClassInfo*, int>)Vtbl[5])((LibVst.IPluginFactory*)Unsafe.AsPointer(ref this), index, info);
            }
        }
        
        /// <summary>
        /// Create a new class instance.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult createInstance(LibVst.FIDString cid, LibVst.FIDString _iid, void** obj)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPluginFactory*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPluginFactory), "createInstance");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPluginFactory*, LibVst.FIDString, LibVst.FIDString, void**, int>)Vtbl[6])(__self__, cid, _iid, obj);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPluginFactory*, LibVst.FIDString, LibVst.FIDString, void**, int>)Vtbl[6])((LibVst.IPluginFactory*)Unsafe.AsPointer(ref this), cid, _iid, obj);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Fill a PFactoryInfo structure with information about the plug-in vendor.
        /// </summary>
        private static partial ComResult getFactoryInfo_ToManaged(IPluginFactory* self, LibVst.PFactoryInfo* info);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getFactoryInfo_Wrapper(IPluginFactory* self, LibVst.PFactoryInfo* info)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPluginFactory), "getFactoryInfo");
                try
                {
                    return getFactoryInfo_ToManaged(self, info);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getFactoryInfo_ToManaged(self, info);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Returns the number of exported classes by this factory. If you are using the CPluginFactory
        /// implementation provided by the SDK, it returns the number of classes you registered with
        /// CPluginFactory::registerClass.
        /// </summary>
        private static partial int countClasses_ToManaged(IPluginFactory* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int countClasses_Wrapper(IPluginFactory* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPluginFactory), "countClasses");
                try
                {
                    return countClasses_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return countClasses_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Fill a PClassInfo structure with information about the class at the specified index.
        /// </summary>
        private static partial ComResult getClassInfo_ToManaged(IPluginFactory* self, int index, LibVst.PClassInfo* info);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getClassInfo_Wrapper(IPluginFactory* self, int index, LibVst.PClassInfo* info)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPluginFactory), "getClassInfo");
                try
                {
                    return getClassInfo_ToManaged(self, index, info);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getClassInfo_ToManaged(self, index, info);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Create a new class instance.
        /// </summary>
        private static partial ComResult createInstance_ToManaged(IPluginFactory* self, LibVst.FIDString cid, LibVst.FIDString _iid, void** obj);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int createInstance_Wrapper(IPluginFactory* self, byte* cid, byte* _iid, void** obj)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPluginFactory), "createInstance");
                try
                {
                    return createInstance_ToManaged(self, cid, _iid, obj);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return createInstance_ToManaged(self, cid, _iid, obj);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPluginFactory, 0x7A4D811C, 0x52114A1F, 0xAED9D2EE, 0x0B43BF9F)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x1c, 0x81, 0x4d, 0x7a, 0x11, 0x52, 0x1f, 0x4a, 0xae, 0xd9, 0xd2, 0xee, 0x0b, 0x43, 0xbf, 0x9f })
                        : new ReadOnlySpan<byte>(new byte[] { 0x7a, 0x4d, 0x81, 0x1c, 0x52, 0x11, 0x4a, 0x1f, 0xae, 0xd9, 0xd2, 0xee, 0x0b, 0x43, 0xbf, 0x9f })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Basic Information about the class factory of the plug-in.
    /// </summary>
    /// <remarks>
    ///  pluginBase
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct PFactoryInfo
    {
        /// <summary>
        /// e.g. "Steinberg Media Technologies"
        /// </summary>
        public fixed byte vendor[64];
        
        /// <summary>
        /// e.g. "http://www.steinberg.de"
        /// </summary>
        public fixed byte url[256];
        
        /// <summary>
        /// e.g. "info@steinberg.de"
        /// </summary>
        public fixed byte email[128];
        
        /// <summary>
        /// (see FactoryFlags above)
        /// </summary>
        public int flags;
        
        /// <summary>
        /// 
        /// </summary>
        public enum FactoryFlags
        {
            /// <summary>
            /// Nothing
            /// </summary>
            kNoFlags = 0,
            
            /// <summary>
            /// The number of exported classes can change each time the Module is loaded. If this flag
            /// is set, the host does not cache class information. This leads to a longer startup time
            /// because the host always has to load the Module to get the current class information.
            /// </summary>
            kClassesDiscardable = 1 << 0,
            
            /// <summary>
            /// This flag is deprecated, do not use anymore, resp. it will get ignored from
            /// Cubase/Nuendo 12 and later.
            /// </summary>
            kLicenseCheck = 1 << 1,
            
            /// <summary>
            /// Component will not be unloaded until process exit
            /// </summary>
            kComponentNonDiscardable = 1 << 3,
            
            /// <summary>
            /// Components have entirely unicode encoded strings (True for VST 3 plug-ins so far).
            /// </summary>
            kUnicode = 1 << 4,
        }
        
        public enum ipluginbase
        {
            kURLSize = 256,
            
            kEmailSize = 128,
            
            kNameSize = 64,
        }
    }
    
    /// <summary>
    /// Basic Information about a class provided by the plug-in.
    /// </summary>
    /// <remarks>
    ///  pluginBase
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct PClassInfo
    {
        /// <summary>
        /// Class ID 16 Byte class GUID
        /// </summary>
        public Guid cid;
        
        /// <summary>
        /// Cardinality of the class, set to kManyInstances (see @ref PClassInfo::ClassCardinality)
        /// </summary>
        public int cardinality;
        
        /// <summary>
        /// Class category, host uses this to categorize interfaces
        /// </summary>
        public fixed byte category[32];
        
        /// <summary>
        /// Class name, visible to the user
        /// </summary>
        public fixed byte name[64];
        
        /// <summary>
        /// 
        /// </summary>
        public enum ClassCardinality
        {
            kManyInstances = 0x7FFFFFFF,
        }
        
        public enum ipluginbase
        {
            kCategorySize = 32,
            
            kNameSize = 64,
        }
    }
    
    /// <summary>
    /// IPluginFactory2 interface declaration
    /// Version 2 of class factory supporting PClassInfo2: IPluginFactory2
    /// </summary>
    /// <remarks>
    ///  pluginBase@copydoc IPluginFactory
    /// </remarks>
    public unsafe partial struct IPluginFactory2 : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 8;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            IPluginFactory.InitializeVtbl(vtbl);
            vtbl[7] = (delegate*unmanaged[MemberFunction]<IPluginFactory2*, int, LibVst.PClassInfo2*, int>)&getClassInfo2_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IPluginFactory2, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IPluginFactory2, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IPluginFactory2, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Fill a PFactoryInfo structure with information about the plug-in vendor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getFactoryInfo(LibVst.PFactoryInfo* info)
        {
            return Unsafe.As<IPluginFactory2, IPluginFactory>(ref this).getFactoryInfo(info);
        }
        
        /// <summary>
        /// Returns the number of exported classes by this factory. If you are using the CPluginFactory
        /// implementation provided by the SDK, it returns the number of classes you registered with
        /// CPluginFactory::registerClass.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int countClasses()
        {
            return Unsafe.As<IPluginFactory2, IPluginFactory>(ref this).countClasses();
        }
        
        /// <summary>
        /// Fill a PClassInfo structure with information about the class at the specified index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getClassInfo(int index, LibVst.PClassInfo* info)
        {
            return Unsafe.As<IPluginFactory2, IPluginFactory>(ref this).getClassInfo(index, info);
        }
        
        /// <summary>
        /// Create a new class instance.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult createInstance(LibVst.FIDString cid, LibVst.FIDString _iid, void** obj)
        {
            return Unsafe.As<IPluginFactory2, IPluginFactory>(ref this).createInstance(cid, _iid, obj);
        }
        
        /// <summary>
        /// Returns the class info (version 2) for a given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getClassInfo2(int index, LibVst.PClassInfo2* info)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPluginFactory2*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPluginFactory2), "getClassInfo2");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPluginFactory2*, int, LibVst.PClassInfo2*, int>)Vtbl[7])(__self__, index, info);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPluginFactory2*, int, LibVst.PClassInfo2*, int>)Vtbl[7])((LibVst.IPluginFactory2*)Unsafe.AsPointer(ref this), index, info);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns the class info (version 2) for a given index.
        /// </summary>
        private static partial ComResult getClassInfo2_ToManaged(IPluginFactory2* self, int index, LibVst.PClassInfo2* info);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getClassInfo2_Wrapper(IPluginFactory2* self, int index, LibVst.PClassInfo2* info)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPluginFactory2), "getClassInfo2");
                try
                {
                    return getClassInfo2_ToManaged(self, index, info);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getClassInfo2_ToManaged(self, index, info);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPluginFactory2, 0x0007B650, 0xF24B4C0B, 0xA464EDB9, 0xF00B2ABB)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x50, 0xb6, 0x07, 0x00, 0x4b, 0xf2, 0x0b, 0x4c, 0xa4, 0x64, 0xed, 0xb9, 0xf0, 0x0b, 0x2a, 0xbb })
                        : new ReadOnlySpan<byte>(new byte[] { 0x00, 0x07, 0xb6, 0x50, 0xf2, 0x4b, 0x4c, 0x0b, 0xa4, 0x64, 0xed, 0xb9, 0xf0, 0x0b, 0x2a, 0xbb })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Version 2 of Basic Information about a class provided by the plug-in.
    /// </summary>
    /// <remarks>
    ///  pluginBase
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct PClassInfo2
    {
        /// <summary>
        /// Class ID 16 Byte class GUID
        /// </summary>
        public Guid cid;
        
        /// <summary>
        /// Cardinality of the class, set to kManyInstances (see @ref PClassInfo::ClassCardinality)
        /// </summary>
        public int cardinality;
        
        /// <summary>
        /// Class category, host uses this to categorize interfaces
        /// </summary>
        public fixed byte category[32];
        
        /// <summary>
        /// Class name, visible to the user
        /// </summary>
        public fixed byte name[64];
        
        /// <summary>
        /// flags used for a specific category, must be defined where category is defined
        /// </summary>
        public uint classFlags;
        
        /// <summary>
        /// module specific subcategories, can be more than one, logically added by the OR operator
        /// </summary>
        public fixed byte subCategories[128];
        
        /// <summary>
        /// overwrite vendor information from factory info
        /// </summary>
        public fixed byte vendor[64];
        
        /// <summary>
        /// Version string (e.g. "1.0.0.512" with Major.Minor.Subversion.Build)
        /// </summary>
        public fixed byte version[64];
        
        /// <summary>
        /// SDK version used to build this class (e.g. "VST 3.0")
        /// </summary>
        public fixed byte sdkVersion[64];
        
        public enum ipluginbase
        {
            kVendorSize = 64,
            
            kVersionSize = 64,
            
            kSubCategoriesSize = 128,
        }
    }
    
    /// <summary>
    /// IPluginFactory3 interface declaration
    /// Version 3 of class factory supporting PClassInfoW: IPluginFactory3
    /// </summary>
    /// <remarks>
    ///  pluginBase@copydoc IPluginFactory
    /// </remarks>
    public unsafe partial struct IPluginFactory3 : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 10;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            IPluginFactory2.InitializeVtbl(vtbl);
            vtbl[8] = (delegate*unmanaged[MemberFunction]<IPluginFactory3*, int, LibVst.PClassInfoW*, int>)&getClassInfoUnicode_Wrapper;
            vtbl[9] = (delegate*unmanaged[MemberFunction]<IPluginFactory3*, LibVst.FUnknown*, int>)&setHostContext_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IPluginFactory3, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IPluginFactory3, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IPluginFactory3, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Fill a PFactoryInfo structure with information about the plug-in vendor.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getFactoryInfo(LibVst.PFactoryInfo* info)
        {
            return Unsafe.As<IPluginFactory3, IPluginFactory>(ref this).getFactoryInfo(info);
        }
        
        /// <summary>
        /// Returns the number of exported classes by this factory. If you are using the CPluginFactory
        /// implementation provided by the SDK, it returns the number of classes you registered with
        /// CPluginFactory::registerClass.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int countClasses()
        {
            return Unsafe.As<IPluginFactory3, IPluginFactory>(ref this).countClasses();
        }
        
        /// <summary>
        /// Fill a PClassInfo structure with information about the class at the specified index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getClassInfo(int index, LibVst.PClassInfo* info)
        {
            return Unsafe.As<IPluginFactory3, IPluginFactory>(ref this).getClassInfo(index, info);
        }
        
        /// <summary>
        /// Create a new class instance.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult createInstance(LibVst.FIDString cid, LibVst.FIDString _iid, void** obj)
        {
            return Unsafe.As<IPluginFactory3, IPluginFactory>(ref this).createInstance(cid, _iid, obj);
        }
        
        /// <summary>
        /// Returns the class info (version 2) for a given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getClassInfo2(int index, LibVst.PClassInfo2* info)
        {
            return Unsafe.As<IPluginFactory3, IPluginFactory2>(ref this).getClassInfo2(index, info);
        }
        
        /// <summary>
        /// Returns the unicode class info for a given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getClassInfoUnicode(int index, LibVst.PClassInfoW* info)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPluginFactory3*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPluginFactory3), "getClassInfoUnicode");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPluginFactory3*, int, LibVst.PClassInfoW*, int>)Vtbl[8])(__self__, index, info);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPluginFactory3*, int, LibVst.PClassInfoW*, int>)Vtbl[8])((LibVst.IPluginFactory3*)Unsafe.AsPointer(ref this), index, info);
            }
        }
        
        /// <summary>
        /// Receives information about host
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setHostContext(LibVst.FUnknown* context)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPluginFactory3*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPluginFactory3), "setHostContext");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPluginFactory3*, LibVst.FUnknown*, int>)Vtbl[9])(__self__, context);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPluginFactory3*, LibVst.FUnknown*, int>)Vtbl[9])((LibVst.IPluginFactory3*)Unsafe.AsPointer(ref this), context);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns the unicode class info for a given index.
        /// </summary>
        private static partial ComResult getClassInfoUnicode_ToManaged(IPluginFactory3* self, int index, LibVst.PClassInfoW* info);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getClassInfoUnicode_Wrapper(IPluginFactory3* self, int index, LibVst.PClassInfoW* info)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPluginFactory3), "getClassInfoUnicode");
                try
                {
                    return getClassInfoUnicode_ToManaged(self, index, info);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getClassInfoUnicode_ToManaged(self, index, info);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Receives information about host
        /// </summary>
        private static partial ComResult setHostContext_ToManaged(IPluginFactory3* self, LibVst.FUnknown* context);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setHostContext_Wrapper(IPluginFactory3* self, LibVst.FUnknown* context)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPluginFactory3), "setHostContext");
                try
                {
                    return setHostContext_ToManaged(self, context);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setHostContext_ToManaged(self, context);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPluginFactory3, 0x4555A2AB, 0xC1234E57, 0x9B122910, 0x36878931)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xab, 0xa2, 0x55, 0x45, 0x23, 0xc1, 0x57, 0x4e, 0x9b, 0x12, 0x29, 0x10, 0x36, 0x87, 0x89, 0x31 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x45, 0x55, 0xa2, 0xab, 0xc1, 0x23, 0x4e, 0x57, 0x9b, 0x12, 0x29, 0x10, 0x36, 0x87, 0x89, 0x31 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Unicode Version of Basic Information about a class provided by the plug-in
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct PClassInfoW
    {
        /// <summary>
        /// see @ref PClassInfo
        /// </summary>
        public Guid cid;
        
        /// <summary>
        /// see @ref PClassInfo
        /// </summary>
        public int cardinality;
        
        /// <summary>
        /// see @ref PClassInfo
        /// </summary>
        public fixed byte category[32];
        
        /// <summary>
        /// see @ref PClassInfo
        /// </summary>
        public fixed char name[64];
        
        /// <summary>
        /// flags used for a specific category, must be defined where category is defined
        /// </summary>
        public uint classFlags;
        
        /// <summary>
        /// module specific subcategories, can be more than one, logically added by the OR operator
        /// </summary>
        public fixed byte subCategories[128];
        
        /// <summary>
        /// overwrite vendor information from factory info
        /// </summary>
        public fixed char vendor[64];
        
        /// <summary>
        /// Version string (e.g. "1.0.0.512" with Major.Minor.Subversion.Build)
        /// </summary>
        public fixed char version[64];
        
        /// <summary>
        /// SDK version used to build this class (e.g. "VST 3.0")
        /// </summary>
        public fixed char sdkVersion[64];
        
        public enum ipluginbase
        {
            kVendorSize = 64,
            
            kVersionSize = 64,
            
            kSubCategoriesSize = 128,
        }
    }
    
    /// <summary>
    /// Interface to return an ascii string of variable size. 
    /// In order to manage memory allocation and deallocation properly, 
    /// this interface is used to transfer a string as result parameter of
    /// a method requires a string of unknown size. 
    /// - [host imp] or [plug imp]
    /// - [released: SX 4]
    /// </summary>
    public unsafe partial struct IStringResult : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IStringResult*, byte*, void>)&setText_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IStringResult, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IStringResult, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IStringResult, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// 
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void setText(byte* text)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IStringResult*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IStringResult), "setText");
                ((delegate*unmanaged[MemberFunction]<LibVst.IStringResult*, byte*, void>)Vtbl[3])(__self__, text);
                __evt__.Dispose();
            }
            else
            {
                ((delegate*unmanaged[MemberFunction]<LibVst.IStringResult*, byte*, void>)Vtbl[3])((LibVst.IStringResult*)Unsafe.AsPointer(ref this), text);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// 
        /// </summary>
        private static partial void setText_ToManaged(IStringResult* self, byte* text);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static void setText_Wrapper(IStringResult* self, byte* text)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IStringResult), "setText");
                try
                {
                    setText_ToManaged(self, text);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    setText_ToManaged(self, text);
                }
                catch
                {
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IStringResult, 0x550798BC, 0x872049DB, 0x84920A15, 0x3B50B7A8)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xbc, 0x98, 0x07, 0x55, 0x20, 0x87, 0xdb, 0x49, 0x84, 0x92, 0x0a, 0x15, 0x3b, 0x50, 0xb7, 0xa8 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x55, 0x07, 0x98, 0xbc, 0x87, 0x20, 0x49, 0xdb, 0x84, 0x92, 0x0a, 0x15, 0x3b, 0x50, 0xb7, 0xa8 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Callback interface passed to IPlugView.
    /// </summary>
    /// <remarks>
    ///  pluginGUI vstIHost vst300- [host imp]
    /// - [released: 3.0.0]
    /// - [mandatory]Enables a plug-in to resize the view and cause the host to resize the window.
    /// </remarks>
    public unsafe partial struct IPlugFrame : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IPlugFrame*, LibVst.IPlugView*, LibVst.ViewRect*, int>)&resizeView_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IPlugFrame, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IPlugFrame, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IPlugFrame, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Called to inform the host about the resize of a given view.
        /// Afterwards the host has to call IPlugView::onSize ().
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult resizeView(LibVst.IPlugView* view, LibVst.ViewRect* newSize)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPlugFrame*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPlugFrame), "resizeView");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPlugFrame*, LibVst.IPlugView*, LibVst.ViewRect*, int>)Vtbl[3])(__self__, view, newSize);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPlugFrame*, LibVst.IPlugView*, LibVst.ViewRect*, int>)Vtbl[3])((LibVst.IPlugFrame*)Unsafe.AsPointer(ref this), view, newSize);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Called to inform the host about the resize of a given view.
        /// Afterwards the host has to call IPlugView::onSize ().
        /// </summary>
        private static partial ComResult resizeView_ToManaged(IPlugFrame* self, LibVst.IPlugView* view, LibVst.ViewRect* newSize);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int resizeView_Wrapper(IPlugFrame* self, LibVst.IPlugView* view, LibVst.ViewRect* newSize)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPlugFrame), "resizeView");
                try
                {
                    return resizeView_ToManaged(self, view, newSize);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return resizeView_ToManaged(self, view, newSize);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPlugFrame, 0x367FAF01, 0xAFA94693, 0x8D4DA2A0, 0xED0882A3)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x01, 0xaf, 0x7f, 0x36, 0xa9, 0xaf, 0x93, 0x46, 0x8d, 0x4d, 0xa2, 0xa0, 0xed, 0x08, 0x82, 0xa3 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x36, 0x7f, 0xaf, 0x01, 0xaf, 0xa9, 0x46, 0x93, 0x8d, 0x4d, 0xa2, 0xa0, 0xed, 0x08, 0x82, 0xa3 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Plug-in definition of a view.
    /// </summary>
    /// <remarks>
    ///  pluginGUI vstIPlug vst300- [plug imp]
    /// - [released: 3.0.0]
    /// </remarks>
    /// <seealso cref="platformUITypeIPlugFrame, "/>
    /// <par>
    /// Sizing of a view
    /// Usually, the size of a plug-in view is fixed. But both the host and the plug-in can cause
    /// a view to be resized:@n - @b Host: If IPlugView::canResize () returns kResultTrue the host will set up the window
    /// so that the user can resize it. While the user resizes the window,
    /// IPlugView::checkSizeConstraint () is called, allowing the plug-in to change the size to a valid
    /// a valid supported rectangle size. The host then resizes the window to this rect and has to call IPlugView::onSize ().@n @n - @b Plug-in: The plug-in can call IPlugFrame::resizeView () and cause the host to resize the
    /// window.@n @n Afterwards, in the same callstack, the host has to call IPlugView::onSize () if a resize is needed (size was changed).
    /// Note that if the host calls IPlugView::getSize () before calling IPlugView::onSize () (if needed),
    /// it will get the current (old) size not the wanted one!!@n Here the calling sequence:@n - plug-in-&gt;host: IPlugFrame::resizeView (newSize)
    /// - host-&gt;plug-in (optional): IPlugView::getSize () returns the currentSize (not the newSize!)
    /// - host-&gt;plug-in: if newSize is different from the current size: IPlugView::onSize (newSize)
    /// - host-&gt;plug-in (optional): IPlugView::getSize () returns the newSize@n &lt;b&gt;Please only resize the platform representation of the view when IPlugView::onSize () is
    /// called.&lt;/b&gt;
    /// </par>
    /// <par>
    /// Keyboard handling
    /// The plug-in view receives keyboard events from the host. A view implementation must not handle
    /// keyboard events by the means of platform callbacks, but let the host pass them to the view. The host
    /// depends on a proper return value when IPlugView::onKeyDown is called, otherwise the plug-in view may
    /// cause a malfunction of the host's key command handling.
    /// </par>
    public unsafe partial struct IPlugView : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 15;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IPlugView*, byte*, int>)&isPlatformTypeSupported_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IPlugView*, void*, byte*, int>)&attached_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IPlugView*, int>)&removed_Wrapper;
            vtbl[6] = (delegate*unmanaged[MemberFunction]<IPlugView*, float, int>)&onWheel_Wrapper;
            vtbl[7] = (delegate*unmanaged[MemberFunction]<IPlugView*, ushort, short, short, int>)&onKeyDown_Wrapper;
            vtbl[8] = (delegate*unmanaged[MemberFunction]<IPlugView*, ushort, short, short, int>)&onKeyUp_Wrapper;
            vtbl[9] = (delegate*unmanaged[MemberFunction]<IPlugView*, LibVst.ViewRect*, int>)&getSize_Wrapper;
            vtbl[10] = (delegate*unmanaged[MemberFunction]<IPlugView*, LibVst.ViewRect*, int>)&onSize_Wrapper;
            vtbl[11] = (delegate*unmanaged[MemberFunction]<IPlugView*, byte, int>)&onFocus_Wrapper;
            vtbl[12] = (delegate*unmanaged[MemberFunction]<IPlugView*, LibVst.IPlugFrame*, int>)&setFrame_Wrapper;
            vtbl[13] = (delegate*unmanaged[MemberFunction]<IPlugView*, int>)&canResize_Wrapper;
            vtbl[14] = (delegate*unmanaged[MemberFunction]<IPlugView*, LibVst.ViewRect*, int>)&checkSizeConstraint_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IPlugView, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IPlugView, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IPlugView, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Is Platform UI Type supported
        /// </summary>
        /// <param name="type">: IDString of @ref platformUIType</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult isPlatformTypeSupported(LibVst.FIDString type)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPlugView*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPlugView), "isPlatformTypeSupported");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, LibVst.FIDString, int>)Vtbl[3])(__self__, type);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, LibVst.FIDString, int>)Vtbl[3])((LibVst.IPlugView*)Unsafe.AsPointer(ref this), type);
            }
        }
        
        /// <summary>
        /// The parent window of the view has been created, the (platform) representation of the view
        /// should now be created as well.
        /// Note that the parent is owned by the caller and you are not allowed to alter it in any way
        /// other than adding your own views.
        /// Note that in this call the plug-in could call a IPlugFrame::resizeView ()!
        /// </summary>
        /// <param name="type">: @ref platformUIType which should be created</param>
        /// <param name="parent">: platform handle of the parent window or view</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult attached(void* parent, LibVst.FIDString type)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPlugView*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPlugView), "attached");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, void*, LibVst.FIDString, int>)Vtbl[4])(__self__, parent, type);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, void*, LibVst.FIDString, int>)Vtbl[4])((LibVst.IPlugView*)Unsafe.AsPointer(ref this), parent, type);
            }
        }
        
        /// <summary>
        /// The parent window of the view is about to be destroyed.
        /// You have to remove all your own views from the parent window or view.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult removed()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPlugView*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPlugView), "removed");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, int>)Vtbl[5])(__self__);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, int>)Vtbl[5])((LibVst.IPlugView*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Handling of mouse wheel.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult onWheel(float distance)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPlugView*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPlugView), "onWheel");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, float, int>)Vtbl[6])(__self__, distance);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, float, int>)Vtbl[6])((LibVst.IPlugView*)Unsafe.AsPointer(ref this), distance);
            }
        }
        
        /// <summary>
        /// Handling of keyboard events : Key Down.
        /// </summary>
        /// <param name="key">: unicode code of key</param>
        /// <param name="keyCode">: virtual keycode for non ascii keys - see @ref VirtualKeyCodes in keycodes.h</param>
        /// <param name="modifiers">: any combination of modifiers - see @ref KeyModifier in keycodes.h</param>
        /// <returns>kResultTrue if the key is handled, otherwise kResultFalse. @n &lt;b&gt;Please note that kResultTrue must only be returned if the key has really been
        /// handled. &lt;/b&gt;Otherwise key command handling of the host might be blocked!</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult onKeyDown(ushort key, short keyCode, short modifiers)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPlugView*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPlugView), "onKeyDown");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, ushort, short, short, int>)Vtbl[7])(__self__, key, keyCode, modifiers);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, ushort, short, short, int>)Vtbl[7])((LibVst.IPlugView*)Unsafe.AsPointer(ref this), key, keyCode, modifiers);
            }
        }
        
        /// <summary>
        /// Handling of keyboard events : Key Up.
        /// </summary>
        /// <param name="key">: unicode code of key</param>
        /// <param name="keyCode">: virtual keycode for non ascii keys - see @ref VirtualKeyCodes in keycodes.h</param>
        /// <param name="modifiers">: any combination of KeyModifier - see @ref KeyModifier in keycodes.h</param>
        /// <returns>kResultTrue if the key is handled, otherwise return kResultFalse.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult onKeyUp(ushort key, short keyCode, short modifiers)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPlugView*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPlugView), "onKeyUp");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, ushort, short, short, int>)Vtbl[8])(__self__, key, keyCode, modifiers);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, ushort, short, short, int>)Vtbl[8])((LibVst.IPlugView*)Unsafe.AsPointer(ref this), key, keyCode, modifiers);
            }
        }
        
        /// <summary>
        /// Returns the size of the platform representation of the view.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getSize(LibVst.ViewRect* size)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPlugView*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPlugView), "getSize");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, LibVst.ViewRect*, int>)Vtbl[9])(__self__, size);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, LibVst.ViewRect*, int>)Vtbl[9])((LibVst.IPlugView*)Unsafe.AsPointer(ref this), size);
            }
        }
        
        /// <summary>
        /// Resizes the platform representation of the view to the given rect. Note that if the plug-in
        /// requests a resize (IPlugFrame::resizeView ()) onSize has to be called afterward.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult onSize(LibVst.ViewRect* newSize)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPlugView*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPlugView), "onSize");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, LibVst.ViewRect*, int>)Vtbl[10])(__self__, newSize);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, LibVst.ViewRect*, int>)Vtbl[10])((LibVst.IPlugView*)Unsafe.AsPointer(ref this), newSize);
            }
        }
        
        /// <summary>
        /// Focus changed message.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult onFocus(byte state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPlugView*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPlugView), "onFocus");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, byte, int>)Vtbl[11])(__self__, state);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, byte, int>)Vtbl[11])((LibVst.IPlugView*)Unsafe.AsPointer(ref this), state);
            }
        }
        
        /// <summary>
        /// Sets IPlugFrame object to allow the plug-in to inform the host about resizing.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setFrame(LibVst.IPlugFrame* frame)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPlugView*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPlugView), "setFrame");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, LibVst.IPlugFrame*, int>)Vtbl[12])(__self__, frame);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, LibVst.IPlugFrame*, int>)Vtbl[12])((LibVst.IPlugView*)Unsafe.AsPointer(ref this), frame);
            }
        }
        
        /// <summary>
        /// Is view sizable by user.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult canResize()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPlugView*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPlugView), "canResize");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, int>)Vtbl[13])(__self__);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, int>)Vtbl[13])((LibVst.IPlugView*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// On live resize this is called to check if the view can be resized to the given rect, if not
        /// adjust the rect to the allowed size.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult checkSizeConstraint(LibVst.ViewRect* rect)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPlugView*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPlugView), "checkSizeConstraint");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, LibVst.ViewRect*, int>)Vtbl[14])(__self__, rect);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPlugView*, LibVst.ViewRect*, int>)Vtbl[14])((LibVst.IPlugView*)Unsafe.AsPointer(ref this), rect);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Is Platform UI Type supported
        /// </summary>
        /// <param name="type">: IDString of @ref platformUIType</param>
        private static partial ComResult isPlatformTypeSupported_ToManaged(IPlugView* self, LibVst.FIDString type);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int isPlatformTypeSupported_Wrapper(IPlugView* self, byte* type)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPlugView), "isPlatformTypeSupported");
                try
                {
                    return isPlatformTypeSupported_ToManaged(self, type);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return isPlatformTypeSupported_ToManaged(self, type);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// The parent window of the view has been created, the (platform) representation of the view
        /// should now be created as well.
        /// Note that the parent is owned by the caller and you are not allowed to alter it in any way
        /// other than adding your own views.
        /// Note that in this call the plug-in could call a IPlugFrame::resizeView ()!
        /// </summary>
        /// <param name="type">: @ref platformUIType which should be created</param>
        /// <param name="parent">: platform handle of the parent window or view</param>
        private static partial ComResult attached_ToManaged(IPlugView* self, void* parent, LibVst.FIDString type);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int attached_Wrapper(IPlugView* self, void* parent, byte* type)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPlugView), "attached");
                try
                {
                    return attached_ToManaged(self, parent, type);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return attached_ToManaged(self, parent, type);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// The parent window of the view is about to be destroyed.
        /// You have to remove all your own views from the parent window or view.
        /// </summary>
        private static partial ComResult removed_ToManaged(IPlugView* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int removed_Wrapper(IPlugView* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPlugView), "removed");
                try
                {
                    return removed_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return removed_ToManaged(self);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Handling of mouse wheel.
        /// </summary>
        private static partial ComResult onWheel_ToManaged(IPlugView* self, float distance);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int onWheel_Wrapper(IPlugView* self, float distance)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPlugView), "onWheel");
                try
                {
                    return onWheel_ToManaged(self, distance);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return onWheel_ToManaged(self, distance);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Handling of keyboard events : Key Down.
        /// </summary>
        /// <param name="key">: unicode code of key</param>
        /// <param name="keyCode">: virtual keycode for non ascii keys - see @ref VirtualKeyCodes in keycodes.h</param>
        /// <param name="modifiers">: any combination of modifiers - see @ref KeyModifier in keycodes.h</param>
        /// <returns>kResultTrue if the key is handled, otherwise kResultFalse. @n &lt;b&gt;Please note that kResultTrue must only be returned if the key has really been
        /// handled. &lt;/b&gt;Otherwise key command handling of the host might be blocked!</returns>
        private static partial ComResult onKeyDown_ToManaged(IPlugView* self, ushort key, short keyCode, short modifiers);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int onKeyDown_Wrapper(IPlugView* self, ushort key, short keyCode, short modifiers)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPlugView), "onKeyDown");
                try
                {
                    return onKeyDown_ToManaged(self, key, keyCode, modifiers);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return onKeyDown_ToManaged(self, key, keyCode, modifiers);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Handling of keyboard events : Key Up.
        /// </summary>
        /// <param name="key">: unicode code of key</param>
        /// <param name="keyCode">: virtual keycode for non ascii keys - see @ref VirtualKeyCodes in keycodes.h</param>
        /// <param name="modifiers">: any combination of KeyModifier - see @ref KeyModifier in keycodes.h</param>
        /// <returns>kResultTrue if the key is handled, otherwise return kResultFalse.</returns>
        private static partial ComResult onKeyUp_ToManaged(IPlugView* self, ushort key, short keyCode, short modifiers);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int onKeyUp_Wrapper(IPlugView* self, ushort key, short keyCode, short modifiers)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPlugView), "onKeyUp");
                try
                {
                    return onKeyUp_ToManaged(self, key, keyCode, modifiers);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return onKeyUp_ToManaged(self, key, keyCode, modifiers);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Returns the size of the platform representation of the view.
        /// </summary>
        private static partial ComResult getSize_ToManaged(IPlugView* self, LibVst.ViewRect* size);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getSize_Wrapper(IPlugView* self, LibVst.ViewRect* size)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPlugView), "getSize");
                try
                {
                    return getSize_ToManaged(self, size);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getSize_ToManaged(self, size);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Resizes the platform representation of the view to the given rect. Note that if the plug-in
        /// requests a resize (IPlugFrame::resizeView ()) onSize has to be called afterward.
        /// </summary>
        private static partial ComResult onSize_ToManaged(IPlugView* self, LibVst.ViewRect* newSize);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int onSize_Wrapper(IPlugView* self, LibVst.ViewRect* newSize)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPlugView), "onSize");
                try
                {
                    return onSize_ToManaged(self, newSize);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return onSize_ToManaged(self, newSize);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Focus changed message.
        /// </summary>
        private static partial ComResult onFocus_ToManaged(IPlugView* self, byte state);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int onFocus_Wrapper(IPlugView* self, byte state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPlugView), "onFocus");
                try
                {
                    return onFocus_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return onFocus_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Sets IPlugFrame object to allow the plug-in to inform the host about resizing.
        /// </summary>
        private static partial ComResult setFrame_ToManaged(IPlugView* self, LibVst.IPlugFrame* frame);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setFrame_Wrapper(IPlugView* self, LibVst.IPlugFrame* frame)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPlugView), "setFrame");
                try
                {
                    return setFrame_ToManaged(self, frame);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setFrame_ToManaged(self, frame);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Is view sizable by user.
        /// </summary>
        private static partial ComResult canResize_ToManaged(IPlugView* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int canResize_Wrapper(IPlugView* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPlugView), "canResize");
                try
                {
                    return canResize_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return canResize_ToManaged(self);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// On live resize this is called to check if the view can be resized to the given rect, if not
        /// adjust the rect to the allowed size.
        /// </summary>
        private static partial ComResult checkSizeConstraint_ToManaged(IPlugView* self, LibVst.ViewRect* rect);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int checkSizeConstraint_Wrapper(IPlugView* self, LibVst.ViewRect* rect)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPlugView), "checkSizeConstraint");
                try
                {
                    return checkSizeConstraint_ToManaged(self, rect);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return checkSizeConstraint_ToManaged(self, rect);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPlugView, 0x5BC32507, 0xD06049EA, 0xA6151B52, 0x2B755B29)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x07, 0x25, 0xc3, 0x5b, 0x60, 0xd0, 0xea, 0x49, 0xa6, 0x15, 0x1b, 0x52, 0x2b, 0x75, 0x5b, 0x29 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x5b, 0xc3, 0x25, 0x07, 0xd0, 0x60, 0x49, 0xea, 0xa6, 0x15, 0x1b, 0x52, 0x2b, 0x75, 0x5b, 0x29 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Graphical rectangle structure. Used with IPlugView.
    /// </summary>
    /// <remarks>
    ///  pluginGUI
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct ViewRect
    {
        public int left;
        
        public int top;
        
        public int right;
        
        public int bottom;
    }
    
    /// <summary>
    /// Plug-in view content scale support
    /// </summary>
    /// <remarks>
    ///  pluginGUI vstIPlug vst366- [plug impl]
    /// - [extends IPlugView]
    /// - [released: 3.6.6]
    /// - [optional]This interface communicates the content scale factor from the host to the plug-in view on
    /// systems where plug-ins cannot get this information directly like Microsoft Windows.The host calls setContentScaleFactor directly before or after the plug-in view is attached and when
    /// the scale factor changes while the view is attached (system change or window moved to another screen
    /// with different scaling settings).The host may call setContentScaleFactor in a different context, for example: scaling the plug-in
    /// editor for better readability.When a plug-in handles this (by returning kResultTrue), it needs to scale the width and height of
    /// its view by the scale factor and inform the host via a IPlugFrame::resizeView(). The host will then
    /// call IPlugView::onSize().Note that the host is allowed to call setContentScaleFactor() at any time the IPlugView is valid.
    /// If this happens before the IPlugFrame object is set on your view, make sure that when the host calls
    /// IPlugView::getSize() afterwards you return the size of your view for that new scale factor.It is recommended to implement this interface on Microsoft Windows to let the host know that the
    /// plug-in is able to render in different scalings.
    /// </remarks>
    public unsafe partial struct IPlugViewContentScaleSupport : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IPlugViewContentScaleSupport*, float, int>)&setContentScaleFactor_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IPlugViewContentScaleSupport, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IPlugViewContentScaleSupport, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IPlugViewContentScaleSupport, FUnknown>(ref this).release();
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setContentScaleFactor(LibVst.ScaleFactor factor)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPlugViewContentScaleSupport*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPlugViewContentScaleSupport), "setContentScaleFactor");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPlugViewContentScaleSupport*, LibVst.ScaleFactor, int>)Vtbl[3])(__self__, factor);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPlugViewContentScaleSupport*, LibVst.ScaleFactor, int>)Vtbl[3])((LibVst.IPlugViewContentScaleSupport*)Unsafe.AsPointer(ref this), factor);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        private static partial ComResult setContentScaleFactor_ToManaged(IPlugViewContentScaleSupport* self, LibVst.ScaleFactor factor);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setContentScaleFactor_Wrapper(IPlugViewContentScaleSupport* self, float factor)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPlugViewContentScaleSupport), "setContentScaleFactor");
                try
                {
                    return setContentScaleFactor_ToManaged(self, factor);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setContentScaleFactor_ToManaged(self, factor);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPlugViewContentScaleSupport, 0x65ED9690, 0x8AC44525, 0x8AADEF7A, 0x72EA703F)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x90, 0x96, 0xed, 0x65, 0xc4, 0x8a, 0x25, 0x45, 0x8a, 0xad, 0xef, 0x7a, 0x72, 0xea, 0x70, 0x3f })
                        : new ReadOnlySpan<byte>(new byte[] { 0x65, 0xed, 0x96, 0x90, 0x8a, 0xc4, 0x45, 0x25, 0x8a, 0xad, 0xef, 0x7a, 0x72, 0xea, 0x70, 0x3f })
                    )));
            }
        }
    }
    
    public partial record struct ScaleFactor(float Value)
    {
        public static implicit operator float(ScaleFactor value) => value.Value;
        
        public static implicit operator ScaleFactor(float value) => new(value);
    }
    
    /// <summary>
    /// 
    /// </summary>
    public enum Direction
    {
        kNorth,
        
        kNorthEast,
        
        kEast,
        
        kSouthEast,
        
        kSouth,
        
        kSouthWest,
        
        kWest,
        
        kNorthWest,
        
        /// <summary>
        /// same position or center point of a geometry
        /// </summary>
        kNoDirection,
        
        kNumberOfDirections,
    }
    
    /// <summary>
    /// 
    /// </summary>
    public enum Orientation
    {
        kHorizontal,
        
        kVertical,
        
        kNumberOfOrientations,
    }
    
    /// <summary>
    /// Virtual Key Codes.
    /// OS-independent enumeration of virtual keycodes.
    /// </summary>
    public enum VirtualKeyCodes
    {
        KEY_BACK = 1,
        
        KEY_TAB,
        
        KEY_CLEAR,
        
        KEY_RETURN,
        
        KEY_PAUSE,
        
        KEY_ESCAPE,
        
        KEY_SPACE,
        
        KEY_NEXT,
        
        KEY_END,
        
        KEY_HOME,
        
        KEY_LEFT,
        
        KEY_UP,
        
        KEY_RIGHT,
        
        KEY_DOWN,
        
        KEY_PAGEUP,
        
        KEY_PAGEDOWN,
        
        KEY_SELECT,
        
        KEY_PRINT,
        
        KEY_ENTER,
        
        KEY_SNAPSHOT,
        
        KEY_INSERT,
        
        KEY_DELETE,
        
        KEY_HELP,
        
        KEY_NUMPAD0,
        
        KEY_NUMPAD1,
        
        KEY_NUMPAD2,
        
        KEY_NUMPAD3,
        
        KEY_NUMPAD4,
        
        KEY_NUMPAD5,
        
        KEY_NUMPAD6,
        
        KEY_NUMPAD7,
        
        KEY_NUMPAD8,
        
        KEY_NUMPAD9,
        
        KEY_MULTIPLY,
        
        KEY_ADD,
        
        KEY_SEPARATOR,
        
        KEY_SUBTRACT,
        
        KEY_DECIMAL,
        
        KEY_DIVIDE,
        
        KEY_F1,
        
        KEY_F2,
        
        KEY_F3,
        
        KEY_F4,
        
        KEY_F5,
        
        KEY_F6,
        
        KEY_F7,
        
        KEY_F8,
        
        KEY_F9,
        
        KEY_F10,
        
        KEY_F11,
        
        KEY_F12,
        
        KEY_NUMLOCK,
        
        KEY_SCROLL,
        
        KEY_SHIFT,
        
        KEY_CONTROL,
        
        KEY_ALT,
        
        /// <summary>
        /// only occurs on a Mac
        /// </summary>
        KEY_EQUALS,
        
        /// <summary>
        /// Windows only
        /// </summary>
        KEY_CONTEXTMENU,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_MEDIA_PLAY,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_MEDIA_STOP,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_MEDIA_PREV,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_MEDIA_NEXT,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_VOLUME_UP,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_VOLUME_DOWN,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_F13,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_F14,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_F15,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_F16,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_F17,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_F18,
        
        /// <summary>
        /// multimedia keys
        /// </summary>
        KEY_F19,
        
        /// <summary>
        /// Win-Key on Windows, Ctrl-Key on macOS
        /// </summary>
        KEY_SUPER,
        
        VKEY_FIRST_CODE = KEY_BACK,
        
        VKEY_LAST_CODE = KEY_SUPER,
        
        VKEY_FIRST_ASCII = 128,
    }
    
    /// <summary>
    /// OS-independent enumeration of virtual modifier-codes.
    /// </summary>
    public enum KeyModifier
    {
        /// <summary>
        /// same on Windows and macOS
        /// </summary>
        kShiftKey = 1 << 0,
        
        /// <summary>
        /// same on Windows and macOS
        /// </summary>
        kAlternateKey = 1 << 1,
        
        /// <summary>
        /// Windows: ctrl key; macOS: cmd key
        /// </summary>
        kCommandKey = 1 << 2,
        
        /// <summary>
        /// Wndows: win key, macOS: ctrl key
        /// </summary>
        kControlKey = 1 << 3,
    }
    
    public enum StandardColor
    {
        kBlack = 0,
        
        kWhite,
        
        kGray5,
        
        kGray10,
        
        kGray20,
        
        kGray30,
        
        kGray40,
        
        kGray50,
        
        kGray60,
        
        kGray70,
        
        kGray80,
        
        kGray90,
        
        kRed,
        
        kLtRed,
        
        kDkRed,
        
        kGreen,
        
        kLtGreen,
        
        kDkGreen,
        
        kBlue,
        
        kLtBlue,
        
        kDkBlue,
        
        kMagenta,
        
        kLtMagenta,
        
        kDkMagenta,
        
        kYellow,
        
        kLtYellow,
        
        kDkYellow,
        
        kOrange,
        
        kLtOrange,
        
        kDkOrange,
        
        kGold,
        
        kBlack50,
        
        kBlack70,
        
        kNumStandardColors,
        
        kLtGray = kGray20,
        
        kGray = kGray50,
        
        kDkGray = kGray70,
    }
    
    /// <summary>
    /// Attribute list used in IMessage and IStreamAttributes: Vst::IAttributeList
    /// </summary>
    /// <remarks>
    ///  vstIHost vst300- [host imp]
    /// - [released: 3.0.0]
    /// - [mandatory]An attribute list associates values with a key (id: some predefined keys can be found in @ref presetAttributes).
    /// </remarks>
    public unsafe partial struct IAttributeList : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 11;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IAttributeList*, byte*, long, int>)&setInt_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IAttributeList*, byte*, long*, int>)&getInt_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IAttributeList*, byte*, double, int>)&setFloat_Wrapper;
            vtbl[6] = (delegate*unmanaged[MemberFunction]<IAttributeList*, byte*, double*, int>)&getFloat_Wrapper;
            vtbl[7] = (delegate*unmanaged[MemberFunction]<IAttributeList*, byte*, char*, int>)&setString_Wrapper;
            vtbl[8] = (delegate*unmanaged[MemberFunction]<IAttributeList*, byte*, char*, uint, int>)&getString_Wrapper;
            vtbl[9] = (delegate*unmanaged[MemberFunction]<IAttributeList*, byte*, void*, uint, int>)&setBinary_Wrapper;
            vtbl[10] = (delegate*unmanaged[MemberFunction]<IAttributeList*, byte*, void**, uint*, int>)&getBinary_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IAttributeList, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IAttributeList, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IAttributeList, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Sets integer value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setInt(LibVst.AttrID id, long value)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributeList*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributeList), "setInt");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributeList*, LibVst.AttrID, long, int>)Vtbl[3])(__self__, id, value);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributeList*, LibVst.AttrID, long, int>)Vtbl[3])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this), id, value);
            }
        }
        
        /// <summary>
        /// Gets integer value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getInt(LibVst.AttrID id, long* value)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributeList*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributeList), "getInt");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributeList*, LibVst.AttrID, long*, int>)Vtbl[4])(__self__, id, value);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributeList*, LibVst.AttrID, long*, int>)Vtbl[4])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this), id, value);
            }
        }
        
        /// <summary>
        /// Sets float value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setFloat(LibVst.AttrID id, double value)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributeList*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributeList), "setFloat");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributeList*, LibVst.AttrID, double, int>)Vtbl[5])(__self__, id, value);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributeList*, LibVst.AttrID, double, int>)Vtbl[5])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this), id, value);
            }
        }
        
        /// <summary>
        /// Gets float value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getFloat(LibVst.AttrID id, double* value)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributeList*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributeList), "getFloat");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributeList*, LibVst.AttrID, double*, int>)Vtbl[6])(__self__, id, value);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributeList*, LibVst.AttrID, double*, int>)Vtbl[6])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this), id, value);
            }
        }
        
        /// <summary>
        /// Sets string value (UTF16) (must be null-terminated!).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setString(LibVst.AttrID id, char* @string)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributeList*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributeList), "setString");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributeList*, LibVst.AttrID, char*, int>)Vtbl[7])(__self__, id, @string);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributeList*, LibVst.AttrID, char*, int>)Vtbl[7])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this), id, @string);
            }
        }
        
        /// <summary>
        /// Gets string value (UTF16). Note that Size is in Byte, not the string Length!
        /// Do not forget to multiply the length by sizeof (TChar)!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getString(LibVst.AttrID id, char* @string, uint sizeInBytes)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributeList*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributeList), "getString");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributeList*, LibVst.AttrID, char*, uint, int>)Vtbl[8])(__self__, id, @string, sizeInBytes);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributeList*, LibVst.AttrID, char*, uint, int>)Vtbl[8])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this), id, @string, sizeInBytes);
            }
        }
        
        /// <summary>
        /// Sets binary data.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setBinary(LibVst.AttrID id, void* data, uint sizeInBytes)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributeList*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributeList), "setBinary");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributeList*, LibVst.AttrID, void*, uint, int>)Vtbl[9])(__self__, id, data, sizeInBytes);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributeList*, LibVst.AttrID, void*, uint, int>)Vtbl[9])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this), id, data, sizeInBytes);
            }
        }
        
        /// <summary>
        /// Gets binary data.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getBinary(LibVst.AttrID id, void** data, uint* sizeInBytes)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAttributeList*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAttributeList), "getBinary");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAttributeList*, LibVst.AttrID, void**, uint*, int>)Vtbl[10])(__self__, id, data, sizeInBytes);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAttributeList*, LibVst.AttrID, void**, uint*, int>)Vtbl[10])((LibVst.IAttributeList*)Unsafe.AsPointer(ref this), id, data, sizeInBytes);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Sets integer value.
        /// </summary>
        private static partial ComResult setInt_ToManaged(IAttributeList* self, LibVst.AttrID id, long value);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setInt_Wrapper(IAttributeList* self, byte* id, long value)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributeList), "setInt");
                try
                {
                    return setInt_ToManaged(self, id, value);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setInt_ToManaged(self, id, value);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets integer value.
        /// </summary>
        private static partial ComResult getInt_ToManaged(IAttributeList* self, LibVst.AttrID id, long* value);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getInt_Wrapper(IAttributeList* self, byte* id, long* value)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributeList), "getInt");
                try
                {
                    return getInt_ToManaged(self, id, value);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getInt_ToManaged(self, id, value);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Sets float value.
        /// </summary>
        private static partial ComResult setFloat_ToManaged(IAttributeList* self, LibVst.AttrID id, double value);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setFloat_Wrapper(IAttributeList* self, byte* id, double value)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributeList), "setFloat");
                try
                {
                    return setFloat_ToManaged(self, id, value);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setFloat_ToManaged(self, id, value);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets float value.
        /// </summary>
        private static partial ComResult getFloat_ToManaged(IAttributeList* self, LibVst.AttrID id, double* value);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getFloat_Wrapper(IAttributeList* self, byte* id, double* value)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributeList), "getFloat");
                try
                {
                    return getFloat_ToManaged(self, id, value);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getFloat_ToManaged(self, id, value);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Sets string value (UTF16) (must be null-terminated!).
        /// </summary>
        private static partial ComResult setString_ToManaged(IAttributeList* self, LibVst.AttrID id, char* @string);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setString_Wrapper(IAttributeList* self, byte* id, char* @string)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributeList), "setString");
                try
                {
                    return setString_ToManaged(self, id, @string);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setString_ToManaged(self, id, @string);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets string value (UTF16). Note that Size is in Byte, not the string Length!
        /// Do not forget to multiply the length by sizeof (TChar)!
        /// </summary>
        private static partial ComResult getString_ToManaged(IAttributeList* self, LibVst.AttrID id, char* @string, uint sizeInBytes);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getString_Wrapper(IAttributeList* self, byte* id, char* @string, uint sizeInBytes)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributeList), "getString");
                try
                {
                    return getString_ToManaged(self, id, @string, sizeInBytes);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getString_ToManaged(self, id, @string, sizeInBytes);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Sets binary data.
        /// </summary>
        private static partial ComResult setBinary_ToManaged(IAttributeList* self, LibVst.AttrID id, void* data, uint sizeInBytes);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setBinary_Wrapper(IAttributeList* self, byte* id, void* data, uint sizeInBytes)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributeList), "setBinary");
                try
                {
                    return setBinary_ToManaged(self, id, data, sizeInBytes);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setBinary_ToManaged(self, id, data, sizeInBytes);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets binary data.
        /// </summary>
        private static partial ComResult getBinary_ToManaged(IAttributeList* self, LibVst.AttrID id, void** data, uint* sizeInBytes);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getBinary_Wrapper(IAttributeList* self, byte* id, void** data, uint* sizeInBytes)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAttributeList), "getBinary");
                try
                {
                    return getBinary_ToManaged(self, id, data, sizeInBytes);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getBinary_ToManaged(self, id, data, sizeInBytes);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IAttributeList, 0x1E5F0AEB, 0xCC7F4533, 0xA2544011, 0x38AD5EE4)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xeb, 0x0a, 0x5f, 0x1e, 0x7f, 0xcc, 0x33, 0x45, 0xa2, 0x54, 0x40, 0x11, 0x38, 0xad, 0x5e, 0xe4 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x1e, 0x5f, 0x0a, 0xeb, 0xcc, 0x7f, 0x45, 0x33, 0xa2, 0x54, 0x40, 0x11, 0x38, 0xad, 0x5e, 0xe4 })
                    )));
            }
        }
    }
    
    public unsafe partial struct AttrID
    {
        public byte* Value;
        
        public static implicit operator byte*(AttrID value) => value.Value;
        
        public static implicit operator AttrID(byte* value) => new AttrID() { Value = value };
    }
    
    /// <summary>
    /// Meta attributes of a stream: Vst::IStreamAttributes
    /// </summary>
    /// <remarks>
    ///  vstIHost vst360- [host imp]
    /// - [extends IBStream]
    /// - [released: 3.6.0]
    /// - [optional]Interface to access preset meta information from stream, used, for example, in setState in order to inform the plug-in about
    /// the current context in which the preset loading occurs (Project context or Preset load (see @ref StateType))or used to get the full file path of the loaded preset (if available).@code {.cpp}
    /// //------------------------------------------------------------------------
    /// #include "pluginterfaces/base/ustring.h"
    /// #include "pluginterfaces/vst/vstpresetkeys.h"
    /// ...
    /// 
    /// tresult PLUGIN_API MyPlugin::setState (IBStream* state)
    /// {
    /// 	FUnknownPtr&lt;IStreamAttributes&gt; stream (state);
    /// 	if (stream)
    /// 	{
    /// 		IAttributeList* list = stream-&gt;getAttributes ();
    /// 		if (list)
    /// 		{
    /// 			// get the current type (project/Default..) of this state
    /// 			String128 string;
    /// 			if (list-&gt;getString (PresetAttributes::kStateType, string, 128 * sizeof (TChar)) == kResultTrue)
    /// 			{
    /// 				UString128 tmp (string);
    /// 				char ascii[128];
    /// 				tmp.toAscii (ascii, 128);
    /// 				if (!strncmp (ascii, StateType::kProject, strlen (StateType::kProject)))
    /// 				{
    /// 					// we are in project loading context...
    /// 				}
    /// 			}
    /// 
    /// 			// get the full file path of this state
    /// 			TChar fullPath[1024];
    /// 			if (list-&gt;getString (PresetAttributes::kFilePathStringType, fullPath, 1024 * sizeof (TChar)) == kResultTrue)
    /// 			{
    /// 				// here we have the full path ...
    /// 			}
    /// 		}
    /// 	}
    /// 
    /// 	//...read the state here.....
    /// 	return kResultTrue;
    /// }
    /// @endcode
    /// </remarks>
    public unsafe partial struct IStreamAttributes : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 5;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IStreamAttributes*, LibVst.String128*, int>)&getFileName_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IStreamAttributes*, LibVst.IAttributeList*>)&getAttributes_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IStreamAttributes, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IStreamAttributes, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IStreamAttributes, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Gets filename (without file extension) of the stream.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getFileName(LibVst.String128* name)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IStreamAttributes*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IStreamAttributes), "getFileName");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IStreamAttributes*, LibVst.String128*, int>)Vtbl[3])(__self__, name);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IStreamAttributes*, LibVst.String128*, int>)Vtbl[3])((LibVst.IStreamAttributes*)Unsafe.AsPointer(ref this), name);
            }
        }
        
        /// <summary>
        /// Gets meta information list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IAttributeList* getAttributes()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IStreamAttributes*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IStreamAttributes), "getAttributes");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IStreamAttributes*, LibVst.IAttributeList*>)Vtbl[4])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IStreamAttributes*, LibVst.IAttributeList*>)Vtbl[4])((LibVst.IStreamAttributes*)Unsafe.AsPointer(ref this));
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Gets filename (without file extension) of the stream.
        /// </summary>
        private static partial ComResult getFileName_ToManaged(IStreamAttributes* self, LibVst.String128* name);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getFileName_Wrapper(IStreamAttributes* self, LibVst.String128* name)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IStreamAttributes), "getFileName");
                try
                {
                    return getFileName_ToManaged(self, name);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getFileName_ToManaged(self, name);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets meta information list.
        /// </summary>
        private static partial LibVst.IAttributeList* getAttributes_ToManaged(IStreamAttributes* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static LibVst.IAttributeList* getAttributes_Wrapper(IStreamAttributes* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IStreamAttributes), "getAttributes");
                try
                {
                    return getAttributes_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getAttributes_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IStreamAttributes, 0xD6CE2FFC, 0xEFAF4B8C, 0x9E74F1BB, 0x12DA44B4)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xfc, 0x2f, 0xce, 0xd6, 0xaf, 0xef, 0x8c, 0x4b, 0x9e, 0x74, 0xf1, 0xbb, 0x12, 0xda, 0x44, 0xb4 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xd6, 0xce, 0x2f, 0xfc, 0xef, 0xaf, 0x4b, 0x8c, 0x9e, 0x74, 0xf1, 0xbb, 0x12, 0xda, 0x44, 0xb4 })
                    )));
            }
        }
    }
    
    public unsafe partial struct String128
    {
        public fixed char Value[128];
    }
    
    /// <summary>
    /// IComponent Interface
    /// Component base interface: Vst::IComponent
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst300- [plug imp]
    /// - [released: 3.0.0]
    /// - [mandatory]This is the basic interface for a VST component and must always be supported.
    /// It contains the common parts of any kind of processing class. The parts that
    /// are specific to a media type are defined in a separate interface. An implementation
    /// component must provide both the specific interface and IComponent.
    /// </remarks>
    /// <seealso cref="IPluginBase"/>
    public unsafe partial struct IComponent : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 14;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            IPluginBase.InitializeVtbl(vtbl);
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IComponent*, Guid*, int>)&getControllerClassId_Wrapper;
            vtbl[6] = (delegate*unmanaged[MemberFunction]<IComponent*, int, int>)&setIoMode_Wrapper;
            vtbl[7] = (delegate*unmanaged[MemberFunction]<IComponent*, int, int, int>)&getBusCount_Wrapper;
            vtbl[8] = (delegate*unmanaged[MemberFunction]<IComponent*, int, int, int, LibVst.BusInfo*, int>)&getBusInfo_Wrapper;
            vtbl[9] = (delegate*unmanaged[MemberFunction]<IComponent*, LibVst.RoutingInfo*, LibVst.RoutingInfo*, int>)&getRoutingInfo_Wrapper;
            vtbl[10] = (delegate*unmanaged[MemberFunction]<IComponent*, int, int, int, byte, int>)&activateBus_Wrapper;
            vtbl[11] = (delegate*unmanaged[MemberFunction]<IComponent*, byte, int>)&setActive_Wrapper;
            vtbl[12] = (delegate*unmanaged[MemberFunction]<IComponent*, LibVst.IBStream*, int>)&setState_Wrapper;
            vtbl[13] = (delegate*unmanaged[MemberFunction]<IComponent*, LibVst.IBStream*, int>)&getState_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IComponent, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IComponent, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IComponent, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// The host passes a number of interfaces as context to initialize the plug-in class.
        /// </summary>
        /// <param name="context,">passed by the host, is mandatory and should implement IHostApplication</param>
        /// <note>
        /// Extensive memory allocations etc. should be performed in this method rather than in
        /// the class' constructor! If the method does NOT return kResultOk, the object is released
        /// immediately. In this case terminate is not called!
        /// </note>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult initialize(LibVst.FUnknown* context)
        {
            return Unsafe.As<IComponent, IPluginBase>(ref this).initialize(context);
        }
        
        /// <summary>
        /// This function is called before the plug-in is unloaded and can be used for
        /// cleanups. You have to release all references to any host application interfaces.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult terminate()
        {
            return Unsafe.As<IComponent, IPluginBase>(ref this).terminate();
        }
        
        /// <summary>
        /// Called before initializing the component to get information about the controller class.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getControllerClassId(Guid* classId)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponent*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponent), "getControllerClassId");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponent*, Guid*, int>)Vtbl[5])(__self__, classId);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponent*, Guid*, int>)Vtbl[5])((LibVst.IComponent*)Unsafe.AsPointer(ref this), classId);
            }
        }
        
        /// <summary>
        /// Called before 'initialize' to set the component usage (optional). See @ref IoModes
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setIoMode(LibVst.IoMode mode)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponent*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponent), "setIoMode");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponent*, LibVst.IoMode, int>)Vtbl[6])(__self__, mode);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponent*, LibVst.IoMode, int>)Vtbl[6])((LibVst.IComponent*)Unsafe.AsPointer(ref this), mode);
            }
        }
        
        /// <summary>
        /// Called after the plug-in is initialized. See @ref MediaTypes, BusDirections
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getBusCount(LibVst.MediaType type, LibVst.BusDirection dir)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponent*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponent), "getBusCount");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponent*, LibVst.MediaType, LibVst.BusDirection, int>)Vtbl[7])(__self__, type, dir);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponent*, LibVst.MediaType, LibVst.BusDirection, int>)Vtbl[7])((LibVst.IComponent*)Unsafe.AsPointer(ref this), type, dir);
            }
        }
        
        /// <summary>
        /// Called after the plug-in is initialized. See @ref MediaTypes, BusDirections
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getBusInfo(LibVst.MediaType type, LibVst.BusDirection dir, int index, LibVst.BusInfo* bus)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponent*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponent), "getBusInfo");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponent*, LibVst.MediaType, LibVst.BusDirection, int, LibVst.BusInfo*, int>)Vtbl[8])(__self__, type, dir, index, bus);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponent*, LibVst.MediaType, LibVst.BusDirection, int, LibVst.BusInfo*, int>)Vtbl[8])((LibVst.IComponent*)Unsafe.AsPointer(ref this), type, dir, index, bus);
            }
        }
        
        /// <summary>
        /// Retrieves routing information (to be implemented when more than one regular input or output bus exists).
        /// The inInfo always refers to an input bus while the returned outInfo must refer to an output bus!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getRoutingInfo(LibVst.RoutingInfo* inInfo, LibVst.RoutingInfo* outInfo)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponent*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponent), "getRoutingInfo");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponent*, LibVst.RoutingInfo*, LibVst.RoutingInfo*, int>)Vtbl[9])(__self__, inInfo, outInfo);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponent*, LibVst.RoutingInfo*, LibVst.RoutingInfo*, int>)Vtbl[9])((LibVst.IComponent*)Unsafe.AsPointer(ref this), inInfo, outInfo);
            }
        }
        
        /// <summary>
        /// Called upon (de-)activating a bus in the host application. The plug-in should only processed
        /// an activated bus, the host could provide less see @ref AudioBusBuffers in the process call
        /// (see @ref IAudioProcessor::process) if last busses are not activated. An already activated bus 
        /// does not need to be reactivated after a IAudioProcessor::setBusArrangements call.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult activateBus(LibVst.MediaType type, LibVst.BusDirection dir, int index, byte state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponent*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponent), "activateBus");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponent*, LibVst.MediaType, LibVst.BusDirection, int, byte, int>)Vtbl[10])(__self__, type, dir, index, state);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponent*, LibVst.MediaType, LibVst.BusDirection, int, byte, int>)Vtbl[10])((LibVst.IComponent*)Unsafe.AsPointer(ref this), type, dir, index, state);
            }
        }
        
        /// <summary>
        /// Activates / deactivates the component.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setActive(byte state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponent*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponent), "setActive");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponent*, byte, int>)Vtbl[11])(__self__, state);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponent*, byte, int>)Vtbl[11])((LibVst.IComponent*)Unsafe.AsPointer(ref this), state);
            }
        }
        
        /// <summary>
        /// Sets complete state of component.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setState(LibVst.IBStream* state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponent*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponent), "setState");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponent*, LibVst.IBStream*, int>)Vtbl[12])(__self__, state);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponent*, LibVst.IBStream*, int>)Vtbl[12])((LibVst.IComponent*)Unsafe.AsPointer(ref this), state);
            }
        }
        
        /// <summary>
        /// Retrieves complete state of component.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getState(LibVst.IBStream* state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponent*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponent), "getState");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponent*, LibVst.IBStream*, int>)Vtbl[13])(__self__, state);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponent*, LibVst.IBStream*, int>)Vtbl[13])((LibVst.IComponent*)Unsafe.AsPointer(ref this), state);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Called before initializing the component to get information about the controller class.
        /// </summary>
        private static partial ComResult getControllerClassId_ToManaged(IComponent* self, Guid* classId);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getControllerClassId_Wrapper(IComponent* self, Guid* classId)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponent), "getControllerClassId");
                try
                {
                    return getControllerClassId_ToManaged(self, classId);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getControllerClassId_ToManaged(self, classId);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Called before 'initialize' to set the component usage (optional). See @ref IoModes
        /// </summary>
        private static partial ComResult setIoMode_ToManaged(IComponent* self, LibVst.IoMode mode);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setIoMode_Wrapper(IComponent* self, int mode)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponent), "setIoMode");
                try
                {
                    return setIoMode_ToManaged(self, mode);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setIoMode_ToManaged(self, mode);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Called after the plug-in is initialized. See @ref MediaTypes, BusDirections
        /// </summary>
        private static partial int getBusCount_ToManaged(IComponent* self, LibVst.MediaType type, LibVst.BusDirection dir);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getBusCount_Wrapper(IComponent* self, int type, int dir)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponent), "getBusCount");
                try
                {
                    return getBusCount_ToManaged(self, type, dir);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getBusCount_ToManaged(self, type, dir);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Called after the plug-in is initialized. See @ref MediaTypes, BusDirections
        /// </summary>
        private static partial ComResult getBusInfo_ToManaged(IComponent* self, LibVst.MediaType type, LibVst.BusDirection dir, int index, LibVst.BusInfo* bus);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getBusInfo_Wrapper(IComponent* self, int type, int dir, int index, LibVst.BusInfo* bus)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponent), "getBusInfo");
                try
                {
                    return getBusInfo_ToManaged(self, type, dir, index, bus);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getBusInfo_ToManaged(self, type, dir, index, bus);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Retrieves routing information (to be implemented when more than one regular input or output bus exists).
        /// The inInfo always refers to an input bus while the returned outInfo must refer to an output bus!
        /// </summary>
        private static partial ComResult getRoutingInfo_ToManaged(IComponent* self, LibVst.RoutingInfo* inInfo, LibVst.RoutingInfo* outInfo);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getRoutingInfo_Wrapper(IComponent* self, LibVst.RoutingInfo* inInfo, LibVst.RoutingInfo* outInfo)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponent), "getRoutingInfo");
                try
                {
                    return getRoutingInfo_ToManaged(self, inInfo, outInfo);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getRoutingInfo_ToManaged(self, inInfo, outInfo);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Called upon (de-)activating a bus in the host application. The plug-in should only processed
        /// an activated bus, the host could provide less see @ref AudioBusBuffers in the process call
        /// (see @ref IAudioProcessor::process) if last busses are not activated. An already activated bus 
        /// does not need to be reactivated after a IAudioProcessor::setBusArrangements call.
        /// </summary>
        private static partial ComResult activateBus_ToManaged(IComponent* self, LibVst.MediaType type, LibVst.BusDirection dir, int index, byte state);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int activateBus_Wrapper(IComponent* self, int type, int dir, int index, byte state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponent), "activateBus");
                try
                {
                    return activateBus_ToManaged(self, type, dir, index, state);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return activateBus_ToManaged(self, type, dir, index, state);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Activates / deactivates the component.
        /// </summary>
        private static partial ComResult setActive_ToManaged(IComponent* self, byte state);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setActive_Wrapper(IComponent* self, byte state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponent), "setActive");
                try
                {
                    return setActive_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setActive_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Sets complete state of component.
        /// </summary>
        private static partial ComResult setState_ToManaged(IComponent* self, LibVst.IBStream* state);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setState_Wrapper(IComponent* self, LibVst.IBStream* state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponent), "setState");
                try
                {
                    return setState_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setState_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Retrieves complete state of component.
        /// </summary>
        private static partial ComResult getState_ToManaged(IComponent* self, LibVst.IBStream* state);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getState_Wrapper(IComponent* self, LibVst.IBStream* state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponent), "getState");
                try
                {
                    return getState_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getState_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IComponent, 0xE831FF31, 0xF2D54301, 0x928EBBEE, 0x25697802)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x31, 0xff, 0x31, 0xe8, 0xd5, 0xf2, 0x01, 0x43, 0x92, 0x8e, 0xbb, 0xee, 0x25, 0x69, 0x78, 0x02 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xe8, 0x31, 0xff, 0x31, 0xf2, 0xd5, 0x43, 0x01, 0x92, 0x8e, 0xbb, 0xee, 0x25, 0x69, 0x78, 0x02 })
                    )));
            }
        }
    }
    
    public partial record struct IoMode(int Value)
    {
        public static implicit operator int(IoMode value) => value.Value;
        
        public static implicit operator IoMode(int value) => new(value);
    }
    
    public partial record struct MediaType(int Value)
    {
        public static implicit operator int(MediaType value) => value.Value;
        
        public static implicit operator MediaType(int value) => new(value);
    }
    
    public partial record struct BusDirection(int Value)
    {
        public static implicit operator int(BusDirection value) => value.Value;
        
        public static implicit operator BusDirection(int value) => new(value);
    }
    
    /// <summary>
    /// BusInfo:
    /// This is the structure used with getBusInfo, informing the host about what is a specific given bus.@n See also: Steinberg::Vst::IComponent::getBusInfo
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct BusInfo
    {
        /// <summary>
        /// Media type - has to be a value of @ref MediaTypes
        /// </summary>
        public LibVst.MediaType mediaType;
        
        /// <summary>
        /// input or output @ref BusDirections
        /// </summary>
        public LibVst.BusDirection direction;
        
        /// <summary>
        /// number of channels (if used then need to be recheck after @ref
        /// </summary>
        public int channelCount;
        
        /// <summary>
        /// name of the bus
        /// </summary>
        public LibVst.String128 name;
        
        /// <summary>
        /// main or aux - has to be a value of @ref BusTypes
        /// </summary>
        public LibVst.BusType busType;
        
        /// <summary>
        /// flags - a combination of @ref BusFlags
        /// </summary>
        public uint flags;
        
        public enum BusFlags
        {
            /// <summary>
            /// The bus should be activated by the host per default on instantiation (activateBus call is requested).
            /// By default a bus is inactive.
            /// </summary>
            kDefaultActive = 1 << 0,
            
            /// <summary>
            /// The bus does not contain ordinary audio data, but data used for control changes at sample rate.
            /// The data is in the same format as the audio data [-1..1].
            /// A host has to prevent unintended routing to speakers to prevent damage.
            /// Only valid for audio media type busses.
            /// [released: 3.7.0]
            /// </summary>
            kIsControlVoltage = 1 << 1,
        }
    }
    
    public partial record struct BusType(int Value)
    {
        public static implicit operator int(BusType value) => value.Value;
        
        public static implicit operator BusType(int value) => new(value);
    }
    
    /// <summary>
    /// Routing Information:
    /// When the plug-in supports multiple I/O busses, a host may want to know how the busses are related. The
    /// relation of an event-input-channel to an audio-output-bus in particular is of interest to the host
    /// (in order to relate MIDI-tracks to audio-channels)@n See also: IComponent::getRoutingInfo, @ref vst3Routing
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct RoutingInfo
    {
        /// <summary>
        /// media type see @ref MediaTypes
        /// </summary>
        public LibVst.MediaType mediaType;
        
        /// <summary>
        /// bus index
        /// </summary>
        public int busIndex;
        
        /// <summary>
        /// channel (-1 for all channels)
        /// </summary>
        public int channel;
    }
    
    /// <summary>
    /// List of events to process: Vst::IEventList
    /// </summary>
    /// <remarks>
    ///  vstIHost vst300- [host imp]
    /// - [released: 3.0.0]
    /// - [mandatory]
    /// </remarks>
    /// <seealso cref="ProcessData, Event"/>
    public unsafe partial struct IEventList : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 6;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IEventList*, int>)&getEventCount_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IEventList*, int, LibVst.Event*, int>)&getEvent_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IEventList*, LibVst.Event*, int>)&addEvent_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IEventList, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IEventList, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IEventList, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Returns the count of events.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getEventCount()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEventList*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEventList), "getEventCount");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEventList*, int>)Vtbl[3])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEventList*, int>)Vtbl[3])((LibVst.IEventList*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Gets parameter by index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getEvent(int index, LibVst.Event* e)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEventList*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEventList), "getEvent");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEventList*, int, LibVst.Event*, int>)Vtbl[4])(__self__, index, e);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEventList*, int, LibVst.Event*, int>)Vtbl[4])((LibVst.IEventList*)Unsafe.AsPointer(ref this), index, e);
            }
        }
        
        /// <summary>
        /// Adds a new event.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult addEvent(LibVst.Event* e)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEventList*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEventList), "addEvent");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEventList*, LibVst.Event*, int>)Vtbl[5])(__self__, e);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEventList*, LibVst.Event*, int>)Vtbl[5])((LibVst.IEventList*)Unsafe.AsPointer(ref this), e);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns the count of events.
        /// </summary>
        private static partial int getEventCount_ToManaged(IEventList* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getEventCount_Wrapper(IEventList* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEventList), "getEventCount");
                try
                {
                    return getEventCount_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getEventCount_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Gets parameter by index.
        /// </summary>
        private static partial ComResult getEvent_ToManaged(IEventList* self, int index, LibVst.Event* e);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getEvent_Wrapper(IEventList* self, int index, LibVst.Event* e)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEventList), "getEvent");
                try
                {
                    return getEvent_ToManaged(self, index, e);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getEvent_ToManaged(self, index, e);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Adds a new event.
        /// </summary>
        private static partial ComResult addEvent_ToManaged(IEventList* self, LibVst.Event* e);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int addEvent_Wrapper(IEventList* self, LibVst.Event* e)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEventList), "addEvent");
                try
                {
                    return addEvent_ToManaged(self, e);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return addEvent_ToManaged(self, e);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IEventList, 0x3A2C4214, 0x346349FE, 0xB2C4F397, 0xB9695A44)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x14, 0x42, 0x2c, 0x3a, 0x63, 0x34, 0xfe, 0x49, 0xb2, 0xc4, 0xf3, 0x97, 0xb9, 0x69, 0x5a, 0x44 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x3a, 0x2c, 0x42, 0x14, 0x34, 0x63, 0x49, 0xfe, 0xb2, 0xc4, 0xf3, 0x97, 0xb9, 0x69, 0x5a, 0x44 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Event
    /// </summary>
    /// <remarks>
    ///  vstEventGrpStructure representing a single Event of different types associated to a specific event (@ref kEvent) bus.
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct Event
    {
        /// <summary>
        /// event bus index
        /// </summary>
        public int busIndex;
        
        /// <summary>
        /// sample frames related to the current block start sample position
        /// </summary>
        public int sampleOffset;
        
        /// <summary>
        /// position in project
        /// </summary>
        public LibVst.TQuarterNotes ppqPosition;
        
        /// <summary>
        /// combination of @ref EventFlags
        /// </summary>
        public ushort flags;
        
        /// <summary>
        /// a value from @ref EventTypes
        /// </summary>
        public ushort type;
        
        [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Unicode)]
        public unsafe partial struct Union
        {
            /// <summary>
            /// type == kNoteOnEvent
            /// </summary>
            [FieldOffset(0)]
            public LibVst.NoteOnEvent noteOn;
            
            /// <summary>
            /// type == kNoteOffEvent
            /// </summary>
            [FieldOffset(0)]
            public LibVst.NoteOffEvent noteOff;
            
            /// <summary>
            /// type == kDataEvent
            /// </summary>
            [FieldOffset(0)]
            public LibVst.DataEvent data;
            
            /// <summary>
            /// type == kPolyPressureEvent
            /// </summary>
            [FieldOffset(0)]
            public LibVst.PolyPressureEvent polyPressure;
            
            /// <summary>
            /// type == kNoteExpressionValueEvent
            /// </summary>
            [FieldOffset(0)]
            public LibVst.NoteExpressionValueEvent noteExpressionValue;
            
            /// <summary>
            /// type == kNoteExpressionTextEvent
            /// </summary>
            [FieldOffset(0)]
            public LibVst.NoteExpressionTextEvent noteExpressionText;
            
            /// <summary>
            /// type == kChordEvent
            /// </summary>
            [FieldOffset(0)]
            public LibVst.ChordEvent chord;
            
            /// <summary>
            /// type == kScaleEvent
            /// </summary>
            [FieldOffset(0)]
            public LibVst.ScaleEvent scale;
            
            /// <summary>
            /// type == kLegacyMIDICCOutEvent
            /// </summary>
            [FieldOffset(0)]
            public LibVst.LegacyMIDICCOutEvent midiCCOut;
        }
        
        public LibVst.Event.Union union;
        
        /// <summary>
        /// Event Flags - used for Event::flags
        /// </summary>
        public enum EventFlags
        {
            /// <summary>
            /// indicates that the event is played live (directly from keyboard)
            /// </summary>
            kIsLive = 1 << 0,
            
            /// <summary>
            /// reserved for user (for internal use)
            /// </summary>
            kUserReserved1 = 1 << 14,
            
            /// <summary>
            /// reserved for user (for internal use)
            /// </summary>
            kUserReserved2 = 1 << 15,
        }
        
        /// <summary>
        /// Event Types - used for Event::type
        /// </summary>
        public enum EventTypes
        {
            /// <summary>
            /// is @ref NoteOnEvent
            /// </summary>
            kNoteOnEvent = 0,
            
            /// <summary>
            /// is @ref NoteOffEvent
            /// </summary>
            kNoteOffEvent = 1,
            
            /// <summary>
            /// is @ref DataEvent
            /// </summary>
            kDataEvent = 2,
            
            /// <summary>
            /// is @ref PolyPressureEvent
            /// </summary>
            kPolyPressureEvent = 3,
            
            /// <summary>
            /// is @ref NoteExpressionValueEvent
            /// </summary>
            kNoteExpressionValueEvent = 4,
            
            /// <summary>
            /// is @ref NoteExpressionTextEvent
            /// </summary>
            kNoteExpressionTextEvent = 5,
            
            /// <summary>
            /// is @ref ChordEvent
            /// </summary>
            kChordEvent = 6,
            
            /// <summary>
            /// is @ref ScaleEvent
            /// </summary>
            kScaleEvent = 7,
            
            /// <summary>
            /// is @ref LegacyMIDICCOutEvent
            /// </summary>
            kLegacyMIDICCOutEvent = 65535,
        }
    }
    
    public partial record struct TQuarterNotes(double Value)
    {
        public static implicit operator double(TQuarterNotes value) => value.Value;
        
        public static implicit operator TQuarterNotes(double value) => new(value);
    }
    
    /// <summary>
    /// Note-on event specific data. Used in @ref Event (union)
    /// </summary>
    /// <remarks>
    ///  vstEventGrpPitch uses the twelve-tone equal temperament tuning (12-TET).
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct NoteOnEvent
    {
        /// <summary>
        /// channel index in event bus
        /// </summary>
        public short channel;
        
        /// <summary>
        /// range [0, 127] = [C-2, G8] with A3=440Hz (12-TET: twelve-tone equal temperament)
        /// </summary>
        public short pitch;
        
        /// <summary>
        /// 1.f = +1 cent, -1.f = -1 cent
        /// </summary>
        public float tuning;
        
        /// <summary>
        /// range [0.0, 1.0]
        /// </summary>
        public float velocity;
        
        /// <summary>
        /// in sample frames (optional, Note Off has to follow in any case!)
        /// </summary>
        public int length;
        
        /// <summary>
        /// note identifier (if not available then -1)
        /// </summary>
        public int noteId;
    }
    
    /// <summary>
    /// Note-off event specific data. Used in @ref Event (union)
    /// </summary>
    /// <remarks>
    ///  vstEventGrp
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct NoteOffEvent
    {
        /// <summary>
        /// channel index in event bus
        /// </summary>
        public short channel;
        
        /// <summary>
        /// range [0, 127] = [C-2, G8] with A3=440Hz (12-TET)
        /// </summary>
        public short pitch;
        
        /// <summary>
        /// range [0.0, 1.0]
        /// </summary>
        public float velocity;
        
        /// <summary>
        /// associated noteOn identifier (if not available then -1)
        /// </summary>
        public int noteId;
        
        /// <summary>
        /// 1.f = +1 cent, -1.f = -1 cent
        /// </summary>
        public float tuning;
    }
    
    /// <summary>
    /// Data event specific data. Used in @ref Event (union)
    /// </summary>
    /// <remarks>
    ///  vstEventGrp
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct DataEvent
    {
        /// <summary>
        /// size in bytes of the data block bytes
        /// </summary>
        public uint size;
        
        /// <summary>
        /// type of this data block (see @ref DataTypes)
        /// </summary>
        public uint type;
        
        /// <summary>
        /// pointer to the data block
        /// </summary>
        public byte* bytes;
        
        /// <summary>
        /// Value for DataEvent::type
        /// </summary>
        public enum DataTypes
        {
            /// <summary>
            /// for MIDI system exclusive message
            /// </summary>
            kMidiSysEx = 0,
        }
    }
    
    /// <summary>
    /// PolyPressure event specific data. Used in @ref Event (union)
    /// </summary>
    /// <remarks>
    ///  vstEventGrp
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct PolyPressureEvent
    {
        /// <summary>
        /// channel index in event bus
        /// </summary>
        public short channel;
        
        /// <summary>
        /// range [0, 127] = [C-2, G8] with A3=440Hz
        /// </summary>
        public short pitch;
        
        /// <summary>
        /// range [0.0, 1.0]
        /// </summary>
        public float pressure;
        
        /// <summary>
        /// event should be applied to the noteId (if not -1)
        /// </summary>
        public int noteId;
    }
    
    /// <summary>
    /// Note Expression Value event. Used in @ref Event (union)
    /// A note expression event affects one single playing note (referring its noteId).
    /// This kind of event is send from host to the plug-in like other events (NoteOnEvent, NoteOffEvent,...) in @ref ProcessData during the process call.
    /// Note expression events for a specific noteId can only occur after a NoteOnEvent. The host must take care that the event list (@ref IEventList) is properly sorted.
    /// Expression events are always absolute normalized values [0.0, 1.0].
    /// The predefined types have a predefined mapping of the normalized values (see @ref NoteExpressionTypeIDs)
    /// </summary>
    /// <seealso cref="INoteExpressionController"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct NoteExpressionValueEvent
    {
        /// <summary>
        /// see @ref NoteExpressionTypeID
        /// </summary>
        public uint typeId;
        
        /// <summary>
        /// associated note identifier to apply the change
        /// </summary>
        public int noteId;
        
        /// <summary>
        /// normalized value [0.0, 1.0].
        /// </summary>
        public double value;
    }
    
    /// <summary>
    /// Note Expression Text event. Used in Event (union)
    /// A Expression event affects one single playing note.
    /// </summary>
    /// <seealso cref="NoteExpressionTypeInfo"/>
    /// <seealso cref="INoteExpressionController"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct NoteExpressionTextEvent
    {
        /// <summary>
        /// see @ref NoteExpressionTypeID (kTextTypeID or kPhoneticTypeID)
        /// </summary>
        public uint typeId;
        
        /// <summary>
        /// associated note identifier to apply the change
        /// </summary>
        public int noteId;
        
        /// <summary>
        /// the number of characters (TChar) between the beginning of text and the terminating
        /// null character (without including the terminating null character itself)
        /// </summary>
        public uint textLen;
        
        /// <summary>
        /// UTF-16, null terminated
        /// </summary>
        public char* text;
    }
    
    /// <summary>
    /// Chord event specific data. Used in @ref Event (union)
    /// </summary>
    /// <remarks>
    ///  vstEventGrp
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct ChordEvent
    {
        /// <summary>
        /// range [0, 127] = [C-2, G8] with A3=440Hz
        /// </summary>
        public short root;
        
        /// <summary>
        /// range [0, 127] = [C-2, G8] with A3=440Hz
        /// </summary>
        public short bassNote;
        
        /// <summary>
        /// root is bit 0
        /// </summary>
        public short mask;
        
        /// <summary>
        /// the number of characters (TChar) between the beginning of text and the terminating
        /// null character (without including the terminating null character itself)
        /// </summary>
        public ushort textLen;
        
        /// <summary>
        /// UTF-16, null terminated Hosts Chord Name
        /// </summary>
        public char* text;
    }
    
    /// <summary>
    /// Scale event specific data. Used in @ref Event (union)
    /// </summary>
    /// <remarks>
    ///  vstEventGrp
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct ScaleEvent
    {
        /// <summary>
        /// range [0, 127] = root Note/Transpose Factor
        /// </summary>
        public short root;
        
        /// <summary>
        /// Bit 0 =  C,  Bit 1 = C#, ... (0x5ab5 = Major Scale)
        /// </summary>
        public short mask;
        
        /// <summary>
        /// the number of characters (TChar) between the beginning of text and the terminating
        /// null character (without including the terminating null character itself)
        /// </summary>
        public ushort textLen;
        
        /// <summary>
        /// UTF-16, null terminated, Hosts Scale Name
        /// </summary>
        public char* text;
    }
    
    /// <summary>
    /// Legacy MIDI CC Out event specific data. Used in @ref Event (union)
    /// </summary>
    /// <remarks>
    ///  vstEventGrp- [released: 3.6.12]This kind of event is reserved for generating MIDI CC as output event for kEvent Bus during the process call.
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct LegacyMIDICCOutEvent
    {
        /// <summary>
        /// see enum ControllerNumbers [0, 255]
        /// </summary>
        public byte controlNumber;
        
        /// <summary>
        /// channel index in event bus [0, 15]
        /// </summary>
        public sbyte channel;
        
        /// <summary>
        /// value of Controller [0, 127]
        /// </summary>
        public sbyte value;
        
        /// <summary>
        /// [0, 127] used for pitch bend (kPitchBend) and polyPressure (kCtrlPolyPressure)
        /// </summary>
        public sbyte value2;
    }
    
    /// <summary>
    /// All parameter changes of a processing block: Vst::IParameterChanges
    /// </summary>
    /// <remarks>
    ///  vstIHost vst300- [host imp]
    /// - [released: 3.0.0]
    /// - [mandatory]This interface is used to transmit any changes to be applied to parameters
    /// in the current processing block. A change can be caused by GUI interaction as
    /// well as automation. They are transmitted as a list of queues (@ref IParamValueQueue)containing only queues for parameters that actually did change.
    /// See @ref IParamValueQueue, @ref ProcessData
    /// </remarks>
    public unsafe partial struct IParameterChanges : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 6;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IParameterChanges*, int>)&getParameterCount_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IParameterChanges*, int, LibVst.IParamValueQueue*>)&getParameterData_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IParameterChanges*, LibVst.ParamID*, int*, LibVst.IParamValueQueue*>)&addParameterData_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IParameterChanges, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IParameterChanges, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IParameterChanges, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Returns count of Parameter changes in the list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getParameterCount()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IParameterChanges*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IParameterChanges), "getParameterCount");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IParameterChanges*, int>)Vtbl[3])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IParameterChanges*, int>)Vtbl[3])((LibVst.IParameterChanges*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Returns the queue at a given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IParamValueQueue* getParameterData(int index)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IParameterChanges*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IParameterChanges), "getParameterData");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IParameterChanges*, int, LibVst.IParamValueQueue*>)Vtbl[4])(__self__, index);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IParameterChanges*, int, LibVst.IParamValueQueue*>)Vtbl[4])((LibVst.IParameterChanges*)Unsafe.AsPointer(ref this), index);
            }
        }
        
        /// <summary>
        /// Adds a new parameter queue with a given ID at the end of the list,
        /// returns it and its index in the parameter changes list.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IParamValueQueue* addParameterData(LibVst.ParamID* id, int* index)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IParameterChanges*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IParameterChanges), "addParameterData");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IParameterChanges*, LibVst.ParamID*, int*, LibVst.IParamValueQueue*>)Vtbl[5])(__self__, id, index);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IParameterChanges*, LibVst.ParamID*, int*, LibVst.IParamValueQueue*>)Vtbl[5])((LibVst.IParameterChanges*)Unsafe.AsPointer(ref this), id, index);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns count of Parameter changes in the list.
        /// </summary>
        private static partial int getParameterCount_ToManaged(IParameterChanges* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getParameterCount_Wrapper(IParameterChanges* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IParameterChanges), "getParameterCount");
                try
                {
                    return getParameterCount_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getParameterCount_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Returns the queue at a given index.
        /// </summary>
        private static partial LibVst.IParamValueQueue* getParameterData_ToManaged(IParameterChanges* self, int index);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static LibVst.IParamValueQueue* getParameterData_Wrapper(IParameterChanges* self, int index)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IParameterChanges), "getParameterData");
                try
                {
                    return getParameterData_ToManaged(self, index);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getParameterData_ToManaged(self, index);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Adds a new parameter queue with a given ID at the end of the list,
        /// returns it and its index in the parameter changes list.
        /// </summary>
        private static partial LibVst.IParamValueQueue* addParameterData_ToManaged(IParameterChanges* self, LibVst.ParamID* id, int* index);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static LibVst.IParamValueQueue* addParameterData_Wrapper(IParameterChanges* self, LibVst.ParamID* id, int* index)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IParameterChanges), "addParameterData");
                try
                {
                    return addParameterData_ToManaged(self, id, index);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return addParameterData_ToManaged(self, id, index);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IParameterChanges, 0xA4779663, 0x0BB64A56, 0xB44384A8, 0x466FEB9D)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x63, 0x96, 0x77, 0xa4, 0xb6, 0x0b, 0x56, 0x4a, 0xb4, 0x43, 0x84, 0xa8, 0x46, 0x6f, 0xeb, 0x9d })
                        : new ReadOnlySpan<byte>(new byte[] { 0xa4, 0x77, 0x96, 0x63, 0x0b, 0xb6, 0x4a, 0x56, 0xb4, 0x43, 0x84, 0xa8, 0x46, 0x6f, 0xeb, 0x9d })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Queue of changes for a specific parameter: Vst::IParamValueQueue
    /// </summary>
    /// <remarks>
    ///  vstIHost vst300- [host imp]
    /// - [released: 3.0.0]
    /// - [mandatory]The change queue can be interpreted as segment of an automation curve. For each
    /// processing block, a segment with the size of the block is transmitted to the processor.
    /// The curve is expressed as sampling points of a linear approximation of
    /// the original automation curve. If the original already is a linear curve, it can
    /// be transmitted precisely. A non-linear curve has to be converted to a linear
    /// approximation by the host. Every point of the value queue defines a linear
    /// section of the curve as a straight line from the previous point of a block to
    /// the new one. So the plug-in can calculate the value of the curve for any sample
    /// position in the block.&lt;b&gt;Implicit Points:&lt;/b&gt;@n In each processing block, the section of the curve for each parameter is transmitted.
    /// In order to reduce the amount of points, the point at block position 0 can be omitted.
    /// - If the curve has a slope of 0 over a period of multiple blocks, only one point is
    /// transmitted for the block where the constant curve section starts. The queue for the following
    /// blocks will be empty as long as the curve slope is 0.
    /// - If the curve has a constant slope other than 0 over the period of several blocks, only
    /// the value for the last sample of the block is transmitted. In this case, the last valid point
    /// is at block position -1. The processor can calculate the value for each sample in the block
    /// by using a linear interpolation:@code {.cpp}
    /// //------------------------------------------------------------------------
    /// double x1 = -1; // position of last point related to current buffer
    /// double y1 = currentParameterValue; // last transmitted value
    /// 
    /// int32 pointTime = 0;
    /// ParamValue pointValue = 0;
    /// IParamValueQueue::getPoint (0, pointTime, pointValue);
    /// 
    /// double x2 = pointTime;
    /// double y2 = pointValue;
    /// 
    /// double slope = (y2 - y1) / (x2 - x1);
    /// double offset = y1 - (slope * x1);
    /// 
    /// double curveValue = (slope * bufferTime) + offset; // bufferTime is any position in buffer
    /// @endcode@b Jumps: @n A jump in the automation curve has to be transmitted as two points: one with the
    /// old value and one with the new value at the next sample position. html "automation.jpg"See @ref IParameterChanges, @ref ProcessData
    /// </remarks>
    public unsafe partial struct IParamValueQueue : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 7;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IParamValueQueue*, uint>)&getParameterId_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IParamValueQueue*, int>)&getPointCount_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IParamValueQueue*, int, int*, LibVst.ParamValue*, int>)&getPoint_Wrapper;
            vtbl[6] = (delegate*unmanaged[MemberFunction]<IParamValueQueue*, int, double, int*, int>)&addPoint_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IParamValueQueue, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IParamValueQueue, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IParamValueQueue, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Returns its associated ID.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint getParameterId()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IParamValueQueue*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IParamValueQueue), "getParameterId");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IParamValueQueue*, uint>)Vtbl[3])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IParamValueQueue*, uint>)Vtbl[3])((LibVst.IParamValueQueue*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Returns count of points in the queue.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getPointCount()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IParamValueQueue*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IParamValueQueue), "getPointCount");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IParamValueQueue*, int>)Vtbl[4])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IParamValueQueue*, int>)Vtbl[4])((LibVst.IParamValueQueue*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Gets the value and offset at a given index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getPoint(int index, int* sampleOffset, LibVst.ParamValue* value)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IParamValueQueue*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IParamValueQueue), "getPoint");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IParamValueQueue*, int, int*, LibVst.ParamValue*, int>)Vtbl[5])(__self__, index, sampleOffset, value);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IParamValueQueue*, int, int*, LibVst.ParamValue*, int>)Vtbl[5])((LibVst.IParamValueQueue*)Unsafe.AsPointer(ref this), index, sampleOffset, value);
            }
        }
        
        /// <summary>
        /// Adds a new value at the end of the queue, its index is returned.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult addPoint(int sampleOffset, LibVst.ParamValue value, int* index)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IParamValueQueue*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IParamValueQueue), "addPoint");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IParamValueQueue*, int, LibVst.ParamValue, int*, int>)Vtbl[6])(__self__, sampleOffset, value, index);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IParamValueQueue*, int, LibVst.ParamValue, int*, int>)Vtbl[6])((LibVst.IParamValueQueue*)Unsafe.AsPointer(ref this), sampleOffset, value, index);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns its associated ID.
        /// </summary>
        private static partial LibVst.ParamID getParameterId_ToManaged(IParamValueQueue* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static uint getParameterId_Wrapper(IParamValueQueue* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IParamValueQueue), "getParameterId");
                try
                {
                    return getParameterId_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getParameterId_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Returns count of points in the queue.
        /// </summary>
        private static partial int getPointCount_ToManaged(IParamValueQueue* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getPointCount_Wrapper(IParamValueQueue* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IParamValueQueue), "getPointCount");
                try
                {
                    return getPointCount_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getPointCount_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Gets the value and offset at a given index.
        /// </summary>
        private static partial ComResult getPoint_ToManaged(IParamValueQueue* self, int index, int* sampleOffset, LibVst.ParamValue* value);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getPoint_Wrapper(IParamValueQueue* self, int index, int* sampleOffset, LibVst.ParamValue* value)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IParamValueQueue), "getPoint");
                try
                {
                    return getPoint_ToManaged(self, index, sampleOffset, value);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getPoint_ToManaged(self, index, sampleOffset, value);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Adds a new value at the end of the queue, its index is returned.
        /// </summary>
        private static partial ComResult addPoint_ToManaged(IParamValueQueue* self, int sampleOffset, LibVst.ParamValue value, int* index);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int addPoint_Wrapper(IParamValueQueue* self, int sampleOffset, double value, int* index)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IParamValueQueue), "addPoint");
                try
                {
                    return addPoint_ToManaged(self, sampleOffset, value, index);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return addPoint_ToManaged(self, sampleOffset, value, index);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IParamValueQueue, 0x01263A18, 0xED074F6F, 0x98C9D356, 0x4686F9BA)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x18, 0x3a, 0x26, 0x01, 0x07, 0xed, 0x6f, 0x4f, 0x98, 0xc9, 0xd3, 0x56, 0x46, 0x86, 0xf9, 0xba })
                        : new ReadOnlySpan<byte>(new byte[] { 0x01, 0x26, 0x3a, 0x18, 0xed, 0x07, 0x4f, 0x6f, 0x98, 0xc9, 0xd3, 0x56, 0x46, 0x86, 0xf9, 0xba })
                    )));
            }
        }
    }
    
    public partial record struct ParamID(uint Value)
    {
        public static implicit operator uint(ParamID value) => value.Value;
        
        public static implicit operator ParamID(uint value) => new(value);
    }
    
    public partial record struct ParamValue(double Value)
    {
        public static implicit operator double(ParamValue value) => value.Value;
        
        public static implicit operator ParamValue(double value) => new(value);
    }
    
    /// <summary>
    /// Audio processing interface: Vst::IAudioProcessor
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst300- [plug imp]
    /// - [extends IComponent]
    /// - [released: 3.0.0]
    /// - [mandatory]This interface must always be supported by audio processing plug-ins.
    /// </remarks>
    public unsafe partial struct IAudioProcessor : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 11;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IAudioProcessor*, LibVst.SpeakerArrangement*, int, LibVst.SpeakerArrangement*, int, int>)&setBusArrangements_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IAudioProcessor*, int, int, LibVst.SpeakerArrangement*, int>)&getBusArrangement_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IAudioProcessor*, int, int>)&canProcessSampleSize_Wrapper;
            vtbl[6] = (delegate*unmanaged[MemberFunction]<IAudioProcessor*, uint>)&getLatencySamples_Wrapper;
            vtbl[7] = (delegate*unmanaged[MemberFunction]<IAudioProcessor*, LibVst.ProcessSetup*, int>)&setupProcessing_Wrapper;
            vtbl[8] = (delegate*unmanaged[MemberFunction]<IAudioProcessor*, byte, int>)&setProcessing_Wrapper;
            vtbl[9] = (delegate*unmanaged[MemberFunction]<IAudioProcessor*, LibVst.ProcessData*, int>)&process_Wrapper;
            vtbl[10] = (delegate*unmanaged[MemberFunction]<IAudioProcessor*, uint>)&getTailSamples_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IAudioProcessor, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IAudioProcessor, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IAudioProcessor, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Try to set (host =&gt; plug-in) a wanted arrangement for inputs and outputs.
        /// The host should always deliver the same number of input and output busses than the plug-in
        /// needs (see @ref IComponent::getBusCount). The plug-in has 3 possibilities to react on this
        /// setBusArrangements call:@n 1. The plug-in accepts these arrangements, then it should modify, if needed, its busses to match 
        /// these new arrangements (later on asked by the host with IComponent::getBusInfo () or
        /// IAudioProcessor::getBusArrangement ()) and then should return kResultTrue.@n 2. The plug-in does not accept or support these requested arrangements for all
        /// inputs/outputs or just for some or only one bus, but the plug-in can try to adapt its current
        /// arrangements according to the requested ones (requested arrangements for kMain busses should be
        /// handled with more priority than the ones for kAux busses), then it should modify its busses arrangements
        /// and should return kResultFalse.@n 3. Same than the point 2 above the plug-in does not support these requested arrangements 
        /// but the plug-in cannot find corresponding arrangements, the plug-in could keep its current arrangement
        /// or fall back to a default arrangement by modifying its busses arrangements and should return kResultFalse.@n
        /// </summary>
        /// <param name="inputs">pointer to an array of /ref SpeakerArrangement</param>
        /// <param name="numIns">number of /ref SpeakerArrangement in inputs array</param>
        /// <param name="outputs">pointer to an array of /ref SpeakerArrangement</param>
        /// <param name="numOuts">number of /ref SpeakerArrangement in outputs array 
        /// Returns kResultTrue when Arrangements is supported and is the current one, else returns kResultFalse.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setBusArrangements(LibVst.SpeakerArrangement* inputs, int numIns, LibVst.SpeakerArrangement* outputs, int numOuts)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAudioProcessor*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAudioProcessor), "setBusArrangements");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAudioProcessor*, LibVst.SpeakerArrangement*, int, LibVst.SpeakerArrangement*, int, int>)Vtbl[3])(__self__, inputs, numIns, outputs, numOuts);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAudioProcessor*, LibVst.SpeakerArrangement*, int, LibVst.SpeakerArrangement*, int, int>)Vtbl[3])((LibVst.IAudioProcessor*)Unsafe.AsPointer(ref this), inputs, numIns, outputs, numOuts);
            }
        }
        
        /// <summary>
        /// Gets the bus arrangement for a given direction (input/output) and index.
        /// Note: IComponent::getBusInfo () and IAudioProcessor::getBusArrangement () should be always return the same 
        /// information about the busses arrangements.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getBusArrangement(LibVst.BusDirection dir, int index, LibVst.SpeakerArrangement* arr)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAudioProcessor*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAudioProcessor), "getBusArrangement");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAudioProcessor*, LibVst.BusDirection, int, LibVst.SpeakerArrangement*, int>)Vtbl[4])(__self__, dir, index, arr);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAudioProcessor*, LibVst.BusDirection, int, LibVst.SpeakerArrangement*, int>)Vtbl[4])((LibVst.IAudioProcessor*)Unsafe.AsPointer(ref this), dir, index, arr);
            }
        }
        
        /// <summary>
        /// Asks if a given sample size is supported see @ref SymbolicSampleSizes.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult canProcessSampleSize(int symbolicSampleSize)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAudioProcessor*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAudioProcessor), "canProcessSampleSize");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAudioProcessor*, int, int>)Vtbl[5])(__self__, symbolicSampleSize);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAudioProcessor*, int, int>)Vtbl[5])((LibVst.IAudioProcessor*)Unsafe.AsPointer(ref this), symbolicSampleSize);
            }
        }
        
        /// <summary>
        /// Gets the current Latency in samples.
        /// The returned value defines the group delay or the latency of the plug-in. For example, if the plug-in internally needs
        /// to look in advance (like compressors) 512 samples then this plug-in should report 512 as latency.
        /// If during the use of the plug-in this latency change, the plug-in has to inform the host by
        /// using IComponentHandler::restartComponent (kLatencyChanged), this could lead to audio playback interruption
        /// because the host has to recompute its internal mixer delay compensation.
        /// Note that for player live recording this latency should be zero or small.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint getLatencySamples()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAudioProcessor*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAudioProcessor), "getLatencySamples");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAudioProcessor*, uint>)Vtbl[6])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAudioProcessor*, uint>)Vtbl[6])((LibVst.IAudioProcessor*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Called in disable state (setActive not called with true) before setProcessing is called and processing will begin.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setupProcessing(LibVst.ProcessSetup* setup)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAudioProcessor*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAudioProcessor), "setupProcessing");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAudioProcessor*, LibVst.ProcessSetup*, int>)Vtbl[7])(__self__, setup);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAudioProcessor*, LibVst.ProcessSetup*, int>)Vtbl[7])((LibVst.IAudioProcessor*)Unsafe.AsPointer(ref this), setup);
            }
        }
        
        /// <summary>
        /// Informs the plug-in about the processing state. This will be called before any process calls
        /// start with true and after with false.
        /// Note that setProcessing (false) may be called after setProcessing (true) without any process
        /// calls.
        /// Note this function could be called in the UI or in Processing Thread, thats why the plug-in
        /// should only light operation (no memory allocation or big setup reconfiguration), 
        /// this could be used to reset some buffers (like Delay line or Reverb).
        /// The host has to be sure that it is called only when the plug-in is enable (setActive (true)
        /// was called).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setProcessing(byte state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAudioProcessor*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAudioProcessor), "setProcessing");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAudioProcessor*, byte, int>)Vtbl[8])(__self__, state);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAudioProcessor*, byte, int>)Vtbl[8])((LibVst.IAudioProcessor*)Unsafe.AsPointer(ref this), state);
            }
        }
        
        /// <summary>
        /// The Process call, where all information (parameter changes, event, audio buffer) are passed.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult process(LibVst.ProcessData* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAudioProcessor*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAudioProcessor), "process");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAudioProcessor*, LibVst.ProcessData*, int>)Vtbl[9])(__self__, data);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAudioProcessor*, LibVst.ProcessData*, int>)Vtbl[9])((LibVst.IAudioProcessor*)Unsafe.AsPointer(ref this), data);
            }
        }
        
        /// <summary>
        /// Gets tail size in samples. For example, if the plug-in is a Reverb plug-in and it knows that
        /// the maximum length of the Reverb is 2sec, then it has to return in getTailSamples() 
        /// (in VST2 it was getGetTailSize ()): 2*sampleRate.
        /// This information could be used by host for offline processing, process optimization and 
        /// downmix (avoiding signal cut (clicks)).
        /// It should return:
        /// - kNoTail when no tail
        /// - x * sampleRate when x Sec tail.
        /// - kInfiniteTail when infinite tail.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint getTailSamples()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAudioProcessor*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAudioProcessor), "getTailSamples");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAudioProcessor*, uint>)Vtbl[10])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAudioProcessor*, uint>)Vtbl[10])((LibVst.IAudioProcessor*)Unsafe.AsPointer(ref this));
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Try to set (host =&gt; plug-in) a wanted arrangement for inputs and outputs.
        /// The host should always deliver the same number of input and output busses than the plug-in
        /// needs (see @ref IComponent::getBusCount). The plug-in has 3 possibilities to react on this
        /// setBusArrangements call:@n 1. The plug-in accepts these arrangements, then it should modify, if needed, its busses to match 
        /// these new arrangements (later on asked by the host with IComponent::getBusInfo () or
        /// IAudioProcessor::getBusArrangement ()) and then should return kResultTrue.@n 2. The plug-in does not accept or support these requested arrangements for all
        /// inputs/outputs or just for some or only one bus, but the plug-in can try to adapt its current
        /// arrangements according to the requested ones (requested arrangements for kMain busses should be
        /// handled with more priority than the ones for kAux busses), then it should modify its busses arrangements
        /// and should return kResultFalse.@n 3. Same than the point 2 above the plug-in does not support these requested arrangements 
        /// but the plug-in cannot find corresponding arrangements, the plug-in could keep its current arrangement
        /// or fall back to a default arrangement by modifying its busses arrangements and should return kResultFalse.@n
        /// </summary>
        /// <param name="inputs">pointer to an array of /ref SpeakerArrangement</param>
        /// <param name="numIns">number of /ref SpeakerArrangement in inputs array</param>
        /// <param name="outputs">pointer to an array of /ref SpeakerArrangement</param>
        /// <param name="numOuts">number of /ref SpeakerArrangement in outputs array 
        /// Returns kResultTrue when Arrangements is supported and is the current one, else returns kResultFalse.</param>
        private static partial ComResult setBusArrangements_ToManaged(IAudioProcessor* self, LibVst.SpeakerArrangement* inputs, int numIns, LibVst.SpeakerArrangement* outputs, int numOuts);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setBusArrangements_Wrapper(IAudioProcessor* self, LibVst.SpeakerArrangement* inputs, int numIns, LibVst.SpeakerArrangement* outputs, int numOuts)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAudioProcessor), "setBusArrangements");
                try
                {
                    return setBusArrangements_ToManaged(self, inputs, numIns, outputs, numOuts);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setBusArrangements_ToManaged(self, inputs, numIns, outputs, numOuts);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets the bus arrangement for a given direction (input/output) and index.
        /// Note: IComponent::getBusInfo () and IAudioProcessor::getBusArrangement () should be always return the same 
        /// information about the busses arrangements.
        /// </summary>
        private static partial ComResult getBusArrangement_ToManaged(IAudioProcessor* self, LibVst.BusDirection dir, int index, LibVst.SpeakerArrangement* arr);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getBusArrangement_Wrapper(IAudioProcessor* self, int dir, int index, LibVst.SpeakerArrangement* arr)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAudioProcessor), "getBusArrangement");
                try
                {
                    return getBusArrangement_ToManaged(self, dir, index, arr);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getBusArrangement_ToManaged(self, dir, index, arr);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Asks if a given sample size is supported see @ref SymbolicSampleSizes.
        /// </summary>
        private static partial ComResult canProcessSampleSize_ToManaged(IAudioProcessor* self, int symbolicSampleSize);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int canProcessSampleSize_Wrapper(IAudioProcessor* self, int symbolicSampleSize)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAudioProcessor), "canProcessSampleSize");
                try
                {
                    return canProcessSampleSize_ToManaged(self, symbolicSampleSize);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return canProcessSampleSize_ToManaged(self, symbolicSampleSize);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets the current Latency in samples.
        /// The returned value defines the group delay or the latency of the plug-in. For example, if the plug-in internally needs
        /// to look in advance (like compressors) 512 samples then this plug-in should report 512 as latency.
        /// If during the use of the plug-in this latency change, the plug-in has to inform the host by
        /// using IComponentHandler::restartComponent (kLatencyChanged), this could lead to audio playback interruption
        /// because the host has to recompute its internal mixer delay compensation.
        /// Note that for player live recording this latency should be zero or small.
        /// </summary>
        private static partial uint getLatencySamples_ToManaged(IAudioProcessor* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static uint getLatencySamples_Wrapper(IAudioProcessor* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAudioProcessor), "getLatencySamples");
                try
                {
                    return getLatencySamples_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getLatencySamples_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Called in disable state (setActive not called with true) before setProcessing is called and processing will begin.
        /// </summary>
        private static partial ComResult setupProcessing_ToManaged(IAudioProcessor* self, LibVst.ProcessSetup* setup);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setupProcessing_Wrapper(IAudioProcessor* self, LibVst.ProcessSetup* setup)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAudioProcessor), "setupProcessing");
                try
                {
                    return setupProcessing_ToManaged(self, setup);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setupProcessing_ToManaged(self, setup);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Informs the plug-in about the processing state. This will be called before any process calls
        /// start with true and after with false.
        /// Note that setProcessing (false) may be called after setProcessing (true) without any process
        /// calls.
        /// Note this function could be called in the UI or in Processing Thread, thats why the plug-in
        /// should only light operation (no memory allocation or big setup reconfiguration), 
        /// this could be used to reset some buffers (like Delay line or Reverb).
        /// The host has to be sure that it is called only when the plug-in is enable (setActive (true)
        /// was called).
        /// </summary>
        private static partial ComResult setProcessing_ToManaged(IAudioProcessor* self, byte state);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setProcessing_Wrapper(IAudioProcessor* self, byte state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAudioProcessor), "setProcessing");
                try
                {
                    return setProcessing_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setProcessing_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// The Process call, where all information (parameter changes, event, audio buffer) are passed.
        /// </summary>
        private static partial ComResult process_ToManaged(IAudioProcessor* self, LibVst.ProcessData* data);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int process_Wrapper(IAudioProcessor* self, LibVst.ProcessData* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAudioProcessor), "process");
                try
                {
                    return process_ToManaged(self, data);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return process_ToManaged(self, data);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets tail size in samples. For example, if the plug-in is a Reverb plug-in and it knows that
        /// the maximum length of the Reverb is 2sec, then it has to return in getTailSamples() 
        /// (in VST2 it was getGetTailSize ()): 2*sampleRate.
        /// This information could be used by host for offline processing, process optimization and 
        /// downmix (avoiding signal cut (clicks)).
        /// It should return:
        /// - kNoTail when no tail
        /// - x * sampleRate when x Sec tail.
        /// - kInfiniteTail when infinite tail.
        /// </summary>
        private static partial uint getTailSamples_ToManaged(IAudioProcessor* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static uint getTailSamples_Wrapper(IAudioProcessor* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAudioProcessor), "getTailSamples");
                try
                {
                    return getTailSamples_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getTailSamples_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IAudioProcessor, 0x42043F99, 0xB7DA453C, 0xA569E79D, 0x9AAEC33D)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x99, 0x3f, 0x04, 0x42, 0xda, 0xb7, 0x3c, 0x45, 0xa5, 0x69, 0xe7, 0x9d, 0x9a, 0xae, 0xc3, 0x3d })
                        : new ReadOnlySpan<byte>(new byte[] { 0x42, 0x04, 0x3f, 0x99, 0xb7, 0xda, 0x45, 0x3c, 0xa5, 0x69, 0xe7, 0x9d, 0x9a, 0xae, 0xc3, 0x3d })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Speaker Arrangements Types
    /// 
    /// </summary>
    public enum SpeakerArrangement : ulong
    {
        kSpeakerL = 1<<0,
        
        kSpeakerR = 1<<1,
        
        kSpeakerC = 1<<2,
        
        kSpeakerLfe = 1<<3,
        
        kSpeakerLs = 1<<4,
        
        kSpeakerRs = 1<<5,
        
        kSpeakerLc = 1<<6,
        
        kSpeakerRc = 1<<7,
        
        kSpeakerS = 1<<8,
        
        kSpeakerCs = kSpeakerS,
        
        kSpeakerSl = 1<<9,
        
        kSpeakerSr = 1<<10,
        
        kSpeakerTc = 1<<11,
        
        kSpeakerTfl = 1<<12,
        
        kSpeakerTfc = 1<<13,
        
        kSpeakerTfr = 1<<14,
        
        kSpeakerTrl = 1<<15,
        
        kSpeakerTrc = 1<<16,
        
        kSpeakerTrr = 1<<17,
        
        kSpeakerLfe2 = 1<<18,
        
        kSpeakerM = 1<<19,
        
        kSpeakerACN0 = 1UL << 20,
        
        kSpeakerACN1 = 1UL << 21,
        
        kSpeakerACN2 = 1UL << 22,
        
        kSpeakerACN3 = 1UL << 23,
        
        kSpeakerACN4 = 1UL << 38,
        
        kSpeakerACN5 = 1UL << 39,
        
        kSpeakerACN6 = 1UL << 40,
        
        kSpeakerACN7 = 1UL << 41,
        
        kSpeakerACN8 = 1UL << 42,
        
        kSpeakerACN9 = 1UL << 43,
        
        kSpeakerACN10 = 1UL << 44,
        
        kSpeakerACN11 = 1UL << 45,
        
        kSpeakerACN12 = 1UL << 46,
        
        kSpeakerACN13 = 1UL << 47,
        
        kSpeakerACN14 = 1UL << 48,
        
        kSpeakerACN15 = 1UL << 49,
        
        kSpeakerTsl = 1UL << 24,
        
        kSpeakerTsr = 1UL << 25,
        
        kSpeakerLcs = 1UL << 26,
        
        kSpeakerRcs = 1UL << 27,
        
        kSpeakerBfl = 1UL << 28,
        
        kSpeakerBfc = 1UL << 29,
        
        kSpeakerBfr = 1UL << 30,
        
        kSpeakerPl = 1UL << 31,
        
        kSpeakerPr = 1UL << 32,
        
        kSpeakerBsl = 1UL << 33,
        
        kSpeakerBsr = 1UL << 34,
        
        kSpeakerBrl = 1UL << 35,
        
        kSpeakerBrc = 1UL << 36,
        
        kSpeakerBrr = 1UL << 37,
        
        kEmpty = 0,
        
        kMono = kSpeakerM,
        
        kStereo = kSpeakerL | kSpeakerR,
        
        kStereoSurround = kSpeakerLs | kSpeakerRs,
        
        kStereoCenter = kSpeakerLc | kSpeakerRc,
        
        kStereoSide = kSpeakerSl | kSpeakerSr,
        
        kStereoCLfe = kSpeakerC | kSpeakerLfe,
        
        kStereoTF = kSpeakerTfl | kSpeakerTfr,
        
        kStereoTS = kSpeakerTsl | kSpeakerTsr,
        
        kStereoTR = kSpeakerTrl | kSpeakerTrr,
        
        kStereoBF = kSpeakerBfl | kSpeakerBfr,
        
        kCineFront = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLc | kSpeakerRc,
        
        k30Cine = kSpeakerL | kSpeakerR | kSpeakerC,
        
        k31Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe,
        
        k30Music = kSpeakerL | kSpeakerR | kSpeakerCs,
        
        k31Music = kSpeakerL | kSpeakerR | kSpeakerLfe | kSpeakerCs,
        
        k40Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerCs,
        
        k41Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerCs,
        
        k40Music = kSpeakerL | kSpeakerR | kSpeakerLs | kSpeakerRs,
        
        k41Music = kSpeakerL | kSpeakerR | kSpeakerLfe | kSpeakerLs | kSpeakerRs,
        
        k50 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs,
        
        k51 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs,
        
        k60Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerCs,
        
        k61Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerCs,
        
        k60Music = kSpeakerL | kSpeakerR | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr,
        
        k61Music = kSpeakerL | kSpeakerR | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr,
        
        k70Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc,
        
        k71Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc,
        
        k71CineFullFront = k71Cine,
        
        k70Music = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr,
        
        k71Music = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr,
        
        k71CineFullRear = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerLcs | kSpeakerRcs,
        
        k71CineSideFill = k71Music,
        
        k71Proximity = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerPl | kSpeakerPr,
        
        k80Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerCs,
        
        k81Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerCs,
        
        k80Music = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerCs | kSpeakerSl | kSpeakerSr,
        
        k81Music = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerCs | kSpeakerSl | kSpeakerSr,
        
        k90Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerSl | kSpeakerSr,
        
        k91Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerSl | kSpeakerSr,
        
        k100Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerCs | kSpeakerSl | kSpeakerSr,
        
        k101Cine = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerCs | kSpeakerSl | kSpeakerSr,
        
        kAmbi1stOrderACN = kSpeakerACN0 | kSpeakerACN1 | kSpeakerACN2 | kSpeakerACN3,
        
        kAmbi2cdOrderACN = kAmbi1stOrderACN | kSpeakerACN4 | kSpeakerACN5 | kSpeakerACN6 | kSpeakerACN7 | kSpeakerACN8,
        
        kAmbi3rdOrderACN = kAmbi2cdOrderACN | kSpeakerACN9 | kSpeakerACN10 | kSpeakerACN11 | kSpeakerACN12 | kSpeakerACN13 | kSpeakerACN14 | kSpeakerACN15,
        
        k80Cube = kSpeakerL | kSpeakerR | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k40_4 = k80Cube,
        
        k71CineTopCenter = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerCs | kSpeakerTc,
        
        k71CineCenterHigh = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerCs | kSpeakerTfc,
        
        k70CineFrontHigh = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfr,
        
        k70MPEG3D = k70CineFrontHigh,
        
        k50_2 = k70CineFrontHigh,
        
        k71CineFrontHigh = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfr,
        
        k71MPEG3D = k71CineFrontHigh,
        
        k51_2 = k71CineFrontHigh,
        
        k71CineSideHigh = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerTsl | kSpeakerTsr,
        
        k81MPEG3D = kSpeakerL | kSpeakerR | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerBfc,
        
        k41_4_1 = k81MPEG3D,
        
        k90 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k50_4 = k90,
        
        k91 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k51_4 = k91,
        
        k50_4_1 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerBfc,
        
        k51_4_1 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerBfc,
        
        k70_2 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTsl | kSpeakerTsr,
        
        k71_2 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTsl | kSpeakerTsr,
        
        k91Atmos = k71_2,
        
        k70_3 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrc,
        
        k72_3 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrc | kSpeakerLfe2,
        
        k70_4 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k71_4 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k111MPEG3D = k71_4,
        
        k70_6 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerTsl | kSpeakerTsr,
        
        k71_6 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerTsl | kSpeakerTsr,
        
        k90_4 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k91_4 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k90_6 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerTsl | kSpeakerTsr,
        
        k91_6 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerTsl | kSpeakerTsr,
        
        k100 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerTc | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k50_5 = k100,
        
        k101 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerTc | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k101MPEG3D = k101,
        
        k51_5 = k101,
        
        k102 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerLfe2,
        
        k52_5 = k102,
        
        k110 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerTc | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k50_6 = k110,
        
        k111 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerTc | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k51_6 = k111,
        
        k122 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerLfe2,
        
        k72_5 = k122,
        
        k130 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTc | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k131 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTc | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr,
        
        k140 = kSpeakerL | kSpeakerR | kSpeakerLs | kSpeakerRs | kSpeakerSl | kSpeakerSr | kSpeakerTfl | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerBfl | kSpeakerBfr | kSpeakerBrl | kSpeakerBrr,
        
        k60_4_4 = k140,
        
        k220 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerCs | kSpeakerSl | kSpeakerSr | kSpeakerTc | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrc | kSpeakerTrr | kSpeakerTsl | kSpeakerTsr | kSpeakerBfl | kSpeakerBfc | kSpeakerBfr,
        
        k100_9_3 = k220,
        
        k222 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerLc | kSpeakerRc | kSpeakerCs | kSpeakerSl | kSpeakerSr | kSpeakerTc | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrc | kSpeakerTrr | kSpeakerLfe2 | kSpeakerTsl | kSpeakerTsr | kSpeakerBfl | kSpeakerBfc | kSpeakerBfr,
        
        k102_9_3 = k222,
        
        k50_5_3 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerBfl | kSpeakerBfc | kSpeakerBfr,
        
        k51_5_3 = kSpeakerL | kSpeakerR | kSpeakerC | kSpeakerLfe | kSpeakerLs | kSpeakerRs | kSpeakerTfl | kSpeakerTfc | kSpeakerTfr | kSpeakerTrl | kSpeakerTrr | kSpeakerBfl | kSpeakerBfc | kSpeakerBfr,
    }
    
    /// <summary>
    /// Audio processing setup.
    /// </summary>
    /// <seealso cref="IAudioProcessor::setupProcessing"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct ProcessSetup
    {
        /// <summary>
        /// @ref ProcessModes
        /// </summary>
        public int processMode;
        
        /// <summary>
        /// @ref SymbolicSampleSizes
        /// </summary>
        public int symbolicSampleSize;
        
        /// <summary>
        /// maximum number of samples per audio block
        /// </summary>
        public int maxSamplesPerBlock;
        
        /// <summary>
        /// sample rate
        /// </summary>
        public LibVst.SampleRate sampleRate;
    }
    
    public partial record struct SampleRate(double Value)
    {
        public static implicit operator double(SampleRate value) => value.Value;
        
        public static implicit operator SampleRate(double value) => new(value);
    }
    
    /// <summary>
    /// Any data needed in audio processing.
    /// The host prepares AudioBusBuffers for each input/output bus,
    /// regardless of the bus activation state. Bus buffer indices always match
    /// with bus indices used in IComponent::getBusInfo of media type kAudio.
    /// </summary>
    /// <seealso cref="AudioBusBuffers, IParameterChanges, IEventList, ProcessContext, IProcessContextRequirements"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct ProcessData
    {
        /// <summary>
        /// processing mode - value of @ref ProcessModes
        /// </summary>
        public int processMode;
        
        /// <summary>
        /// sample size - value of @ref SymbolicSampleSizes
        /// </summary>
        public int symbolicSampleSize;
        
        /// <summary>
        /// number of samples to process
        /// </summary>
        public int numSamples;
        
        /// <summary>
        /// number of audio input busses
        /// </summary>
        public int numInputs;
        
        /// <summary>
        /// number of audio output busses
        /// </summary>
        public int numOutputs;
        
        /// <summary>
        /// buffers of input busses
        /// </summary>
        public LibVst.AudioBusBuffers* inputs;
        
        /// <summary>
        /// buffers of output busses
        /// </summary>
        public LibVst.AudioBusBuffers* outputs;
        
        /// <summary>
        /// incoming parameter changes for this block
        /// </summary>
        public LibVst.IParameterChanges* inputParameterChanges;
        
        /// <summary>
        /// outgoing parameter changes for this block (optional)
        /// </summary>
        public LibVst.IParameterChanges* outputParameterChanges;
        
        /// <summary>
        /// incoming events for this block (optional)
        /// </summary>
        public LibVst.IEventList* inputEvents;
        
        /// <summary>
        /// outgoing events for this block (optional)
        /// </summary>
        public LibVst.IEventList* outputEvents;
        
        /// <summary>
        /// processing context (optional, but most welcome)
        /// </summary>
        public LibVst.ProcessContext* processContext;
    }
    
    /// <summary>
    /// Processing buffers of an audio bus.
    /// This structure contains the processing buffer for each channel of an audio bus.
    /// - The number of channels (numChannels) must always match the current bus arrangement.
    /// It could be set to value '0' when the host wants to flush the parameters (when the plug-in is not processed).
    /// - The size of the channel buffer array must always match the number of channels. So the host
    /// must always supply an array for the channel buffers, regardless if the
    /// bus is active or not. However, if an audio bus is currently inactive, the actual sample
    /// buffer addresses are safe to be null.
    /// - The silence flag is set when every sample of the according buffer has the value '0'. It is
    /// intended to be used as help for optimizations allowing a plug-in to reduce processing activities.
    /// But even if this flag is set for a channel, the channel buffers must still point to valid memory!
    /// This flag is optional. A host is free to support it or not.
    /// .
    /// </summary>
    /// <seealso cref="ProcessData"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct AudioBusBuffers
    {
        /// <summary>
        /// number of audio channels in bus
        /// </summary>
        public int numChannels;
        
        /// <summary>
        /// Bitset of silence state per channel
        /// </summary>
        public ulong silenceFlags;
        
        [StructLayout(LayoutKind.Explicit, CharSet = CharSet.Unicode)]
        public unsafe partial struct Union
        {
            /// <summary>
            /// sample buffers to process with 32-bit precision
            /// </summary>
            [FieldOffset(0)]
            public LibVst.Sample32** channelBuffers32;
            
            /// <summary>
            /// sample buffers to process with 64-bit precision
            /// </summary>
            [FieldOffset(0)]
            public LibVst.Sample64** channelBuffers64;
        }
        
        public LibVst.AudioBusBuffers.Union union;
    }
    
    public partial record struct Sample32(float Value)
    {
        public static implicit operator float(Sample32 value) => value.Value;
        
        public static implicit operator Sample32(float value) => new(value);
    }
    
    public partial record struct Sample64(double Value)
    {
        public static implicit operator double(Sample64 value) => value.Value;
        
        public static implicit operator Sample64(double value) => new(value);
    }
    
    /// <summary>
    /// Audio processing context.
    /// For each processing block the host provides timing information and musical parameters that can
    /// change over time. For a host that supports jumps (like cycle) it is possible to split up a
    /// processing block into multiple parts in order to provide a correct project time inside of every
    /// block, but this behavior is not mandatory. Since the timing will be correct at the beginning of the
    /// next block again, a host that is dependent on a fixed processing block size can choose to neglect
    /// this problem.
    /// </summary>
    /// <seealso cref="IAudioProcessor, ProcessData"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct ProcessContext
    {
        /// <summary>
        /// a combination of the values from @ref StatesAndFlags
        /// </summary>
        public uint state;
        
        /// <summary>
        /// current sample rate					(always valid)
        /// </summary>
        public double sampleRate;
        
        /// <summary>
        /// project time in samples				(always valid)
        /// </summary>
        public LibVst.TSamples projectTimeSamples;
        
        /// <summary>
        /// system time in nanoseconds					(optional)
        /// </summary>
        public long systemTime;
        
        /// <summary>
        /// project time, without loop					(optional)
        /// </summary>
        public LibVst.TSamples continousTimeSamples;
        
        /// <summary>
        /// musical position in quarter notes (1.0 equals 1 quarter note) (optional)
        /// </summary>
        public LibVst.TQuarterNotes projectTimeMusic;
        
        /// <summary>
        /// last bar start position, in quarter notes	(optional)
        /// </summary>
        public LibVst.TQuarterNotes barPositionMusic;
        
        /// <summary>
        /// cycle start in quarter notes				(optional)
        /// </summary>
        public LibVst.TQuarterNotes cycleStartMusic;
        
        /// <summary>
        /// cycle end in quarter notes					(optional)
        /// </summary>
        public LibVst.TQuarterNotes cycleEndMusic;
        
        /// <summary>
        /// tempo in BPM (Beats Per Minute)			(optional)
        /// </summary>
        public double tempo;
        
        /// <summary>
        /// time signature numerator (e.g. 3 for 3/4)	(optional)
        /// </summary>
        public int timeSigNumerator;
        
        /// <summary>
        /// time signature denominator (e.g. 4 for 3/4) (optional)
        /// </summary>
        public int timeSigDenominator;
        
        /// <summary>
        /// musical info								(optional)
        /// </summary>
        public LibVst.Chord chord;
        
        /// <summary>
        /// SMPTE (sync) offset in subframes (1/80 of frame) (optional)
        /// </summary>
        public int smpteOffsetSubframes;
        
        /// <summary>
        /// frame rate									(optional)
        /// </summary>
        public LibVst.FrameRate frameRate;
        
        /// <summary>
        /// MIDI Clock Resolution (24 Per Quarter Note), can be negative (nearest) (optional)
        /// </summary>
        public int samplesToNextClock;
        
        /// <summary>
        /// Transport state 
        /// &amp;
        /// other flags
        /// </summary>
        public enum StatesAndFlags
        {
            /// <summary>
            /// currently playing
            /// </summary>
            kPlaying = 1 << 1,
            
            /// <summary>
            /// cycle is active
            /// </summary>
            kCycleActive = 1 << 2,
            
            /// <summary>
            /// currently recording
            /// </summary>
            kRecording = 1 << 3,
            
            /// <summary>
            /// systemTime contains valid information
            /// </summary>
            kSystemTimeValid = 1 << 8,
            
            /// <summary>
            /// continousTimeSamples contains valid information
            /// </summary>
            kContTimeValid = 1 << 17,
            
            /// <summary>
            /// projectTimeMusic contains valid information
            /// </summary>
            kProjectTimeMusicValid = 1 << 9,
            
            /// <summary>
            /// barPositionMusic contains valid information
            /// </summary>
            kBarPositionValid = 1 << 11,
            
            /// <summary>
            /// cycleStartMusic and barPositionMusic contain valid information
            /// </summary>
            kCycleValid = 1 << 12,
            
            /// <summary>
            /// tempo contains valid information
            /// </summary>
            kTempoValid = 1 << 10,
            
            /// <summary>
            /// timeSigNumerator and timeSigDenominator contain valid information
            /// </summary>
            kTimeSigValid = 1 << 13,
            
            /// <summary>
            /// chord contains valid information
            /// </summary>
            kChordValid = 1 << 18,
            
            /// <summary>
            /// smpteOffset and frameRate contain valid information
            /// </summary>
            kSmpteValid = 1 << 14,
            
            /// <summary>
            /// samplesToNextClock valid
            /// </summary>
            kClockValid = 1 << 15,
        }
    }
    
    public partial record struct TSamples(long Value)
    {
        public static implicit operator long(TSamples value) => value.Value;
        
        public static implicit operator TSamples(long value) => new(value);
    }
    
    /// <summary>
    /// Description of a chord.
    /// A chord is described with a key note, a root note and the@copydoc chordMask
    /// </summary>
    /// <seealso cref="ProcessContext"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct Chord
    {
        /// <summary>
        /// key note in chord
        /// </summary>
        public byte keyNote;
        
        /// <summary>
        /// lowest note in chord
        /// </summary>
        public byte rootNote;
        
        /// <summary>
        /// Bitmask of a chord. @n 1st bit set: minor second; 2nd bit set: major second, and so on. @n There is @b no bit for the keynote (root of the chord) because it is inherently always present. @n Examples:
        /// - XXXX 0000 0100 1000 (= 0x0048) -&gt; major chord
        /// - XXXX 0000 0100 0100 (= 0x0044) -&gt; minor chord
        /// - XXXX 0010 0100 0100 (= 0x0244) -&gt; minor chord with minor seventh
        /// </summary>
        public short chordMask;
        
        public enum Masks
        {
            /// <summary>
            /// mask for chordMask
            /// </summary>
            kChordMask = 0x0FFF,
            
            /// <summary>
            /// reserved for future use
            /// </summary>
            kReservedMask = 0xF000,
        }
    }
    
    /// <summary>
    /// Frame Rate 
    /// A frame rate describes the number of image (frame) displayed per second.
    /// Some examples:
    /// - 23.976 fps     is framesPerSecond: 24 and flags: kPullDownRate
    /// - 24 fps         is framesPerSecond: 24 and flags: 0
    /// - 25 fps         is framesPerSecond: 25 and flags: 0
    /// - 29.97 drop fps is framesPerSecond: 30 and flags: kDropRate|kPullDownRate
    /// - 29.97 fps      is framesPerSecond: 30 and flags: kPullDownRate
    /// - 30 fps         is framesPerSecond: 30 and flags: 0
    /// - 30 drop fps    is framesPerSecond: 30 and flags: kDropRate
    /// - 50 fps         is framesPerSecond: 50 and flags: 0
    /// - 59.94 fps	     is framesPerSecond: 60 and flags: kPullDownRate
    /// - 60 fps         is framesPerSecond: 60 and flags: 0
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct FrameRate
    {
        /// <summary>
        /// frame rate
        /// </summary>
        public uint framesPerSecond;
        
        /// <summary>
        /// flags #FrameRateFlags
        /// </summary>
        public uint flags;
        
        /// <summary>
        /// 
        /// </summary>
        public enum FrameRateFlags
        {
            kPullDownRate = 1 << 0,
            
            kDropRate = 1 << 1,
        }
    }
    
    /// <summary>
    /// Extended IAudioProcessor interface for a component: Vst::IAudioPresentationLatency
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst310- [plug imp]
    /// - [extends IAudioProcessor]
    /// - [released: 3.1.0]
    /// - [optional]Inform the plug-in about how long from the moment of generation/acquiring (from file or from Input)
    /// it will take for its input to arrive, and how long it will take for its output to be presented (to output or to speaker).Note for Input Presentation Latency: when reading from file, the first plug-in will have an input presentation latency set to zero.
    /// When monitoring audio input from an audio device, the initial input latency is the input latency of the audio device itself.Note for Output Presentation Latency: when writing to a file, the last plug-in will have an output presentation latency set to zero.
    /// When the output of this plug-in is connected to an audio device, the initial output latency is the output
    /// latency of the audio device itself.A value of zero either means no latency or an unknown latency.Each plug-in adding a latency (returning a none zero value for IAudioProcessor::getLatencySamples) will modify the input 
    /// presentation latency of the next plug-ins in the mixer routing graph and will modify the output presentation latency 
    /// of the previous plug-ins.@n html "iaudiopresentationlatency_usage.png"@n
    /// </remarks>
    /// <seealso cref="IAudioProcessor"/>
    /// <seealso cref="IComponent"/>
    public unsafe partial struct IAudioPresentationLatency : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IAudioPresentationLatency*, int, int, uint, int>)&setAudioPresentationLatencySamples_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IAudioPresentationLatency, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IAudioPresentationLatency, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IAudioPresentationLatency, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Informs the plug-in about the Audio Presentation Latency in samples for a given direction (kInput/kOutput) and bus index.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setAudioPresentationLatencySamples(LibVst.BusDirection dir, int busIndex, uint latencyInSamples)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAudioPresentationLatency*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAudioPresentationLatency), "setAudioPresentationLatencySamples");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAudioPresentationLatency*, LibVst.BusDirection, int, uint, int>)Vtbl[3])(__self__, dir, busIndex, latencyInSamples);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAudioPresentationLatency*, LibVst.BusDirection, int, uint, int>)Vtbl[3])((LibVst.IAudioPresentationLatency*)Unsafe.AsPointer(ref this), dir, busIndex, latencyInSamples);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Informs the plug-in about the Audio Presentation Latency in samples for a given direction (kInput/kOutput) and bus index.
        /// </summary>
        private static partial ComResult setAudioPresentationLatencySamples_ToManaged(IAudioPresentationLatency* self, LibVst.BusDirection dir, int busIndex, uint latencyInSamples);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setAudioPresentationLatencySamples_Wrapper(IAudioPresentationLatency* self, int dir, int busIndex, uint latencyInSamples)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAudioPresentationLatency), "setAudioPresentationLatencySamples");
                try
                {
                    return setAudioPresentationLatencySamples_ToManaged(self, dir, busIndex, latencyInSamples);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setAudioPresentationLatencySamples_ToManaged(self, dir, busIndex, latencyInSamples);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IAudioPresentationLatency, 0x309ECE78, 0xEB7D4fae, 0x8B2225D9, 0x09FD08B6)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x78, 0xce, 0x9e, 0x30, 0x7d, 0xeb, 0xae, 0x4f, 0x8b, 0x22, 0x25, 0xd9, 0x09, 0xfd, 0x08, 0xb6 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x30, 0x9e, 0xce, 0x78, 0xeb, 0x7d, 0x4f, 0xae, 0x8b, 0x22, 0x25, 0xd9, 0x09, 0xfd, 0x08, 0xb6 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Extended IAudioProcessor interface for a component: Vst::IProcessContextRequirements
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst370- [plug imp]
    /// - [extends IAudioProcessor]
    /// - [released: 3.7.0]
    /// - [mandatory]To get accurate process context information (Vst::ProcessContext), it is now required to implement this interface and
    /// return the desired bit mask of flags which your audio effect needs. If you do not implement this
    /// interface, you may not get any information at all of the process function.The host asks for this information once between initialize and setActive. It cannot be changed afterwards.This gives the host the opportunity to better optimize the audio process graph when it knows which
    /// plug-ins need which information.Plug-Ins built with an earlier SDK version (
    /// &lt;
    /// 3.7) will still get the old information, but the information
    /// may not be as accurate as when using this interface.
    /// </remarks>
    public unsafe partial struct IProcessContextRequirements : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IProcessContextRequirements*, uint>)&getProcessContextRequirements_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IProcessContextRequirements, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IProcessContextRequirements, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IProcessContextRequirements, FUnknown>(ref this).release();
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint getProcessContextRequirements()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IProcessContextRequirements*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IProcessContextRequirements), "getProcessContextRequirements");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IProcessContextRequirements*, uint>)Vtbl[3])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IProcessContextRequirements*, uint>)Vtbl[3])((LibVst.IProcessContextRequirements*)Unsafe.AsPointer(ref this));
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        private static partial uint getProcessContextRequirements_ToManaged(IProcessContextRequirements* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static uint getProcessContextRequirements_Wrapper(IProcessContextRequirements* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IProcessContextRequirements), "getProcessContextRequirements");
                try
                {
                    return getProcessContextRequirements_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getProcessContextRequirements_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        public enum Flags
        {
            /// <summary>
            /// kSystemTimeValid
            /// </summary>
            kNeedSystemTime = 1 << 0,
            
            /// <summary>
            /// kContTimeValid
            /// </summary>
            kNeedContinousTimeSamples = 1 << 1,
            
            /// <summary>
            /// kProjectTimeMusicValid
            /// </summary>
            kNeedProjectTimeMusic = 1 << 2,
            
            /// <summary>
            /// kBarPositionValid
            /// </summary>
            kNeedBarPositionMusic = 1 << 3,
            
            /// <summary>
            /// kCycleValid
            /// </summary>
            kNeedCycleMusic = 1 << 4,
            
            /// <summary>
            /// kClockValid
            /// </summary>
            kNeedSamplesToNextClock = 1 << 5,
            
            /// <summary>
            /// kTempoValid
            /// </summary>
            kNeedTempo = 1 << 6,
            
            /// <summary>
            /// kTimeSigValid
            /// </summary>
            kNeedTimeSignature = 1 << 7,
            
            /// <summary>
            /// kChordValid
            /// </summary>
            kNeedChord = 1 << 8,
            
            /// <summary>
            /// kSmpteValid
            /// </summary>
            kNeedFrameRate = 1 << 9,
            
            /// <summary>
            /// kPlaying, kCycleActive, kRecording
            /// </summary>
            kNeedTransportState = 1 << 10,
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IProcessContextRequirements, 0x2A654303, 0xEF764E3D, 0x95B5FE83, 0x730EF6D0)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x03, 0x43, 0x65, 0x2a, 0x76, 0xef, 0x3d, 0x4e, 0x95, 0xb5, 0xfe, 0x83, 0x73, 0x0e, 0xf6, 0xd0 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x2a, 0x65, 0x43, 0x03, 0xef, 0x76, 0x4e, 0x3d, 0x95, 0xb5, 0xfe, 0x83, 0x73, 0x0e, 0xf6, 0xd0 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Extended plug-in interface IEditController: Vst::IAutomationState
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst365- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.6.5]
    /// - [optional]Hosts can inform the plug-in about its current automation state (Read/Write/Nothing).
    /// </remarks>
    public unsafe partial struct IAutomationState : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IAutomationState*, int, int>)&setAutomationState_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IAutomationState, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IAutomationState, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IAutomationState, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Sets the current Automation state.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setAutomationState(int state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IAutomationState*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IAutomationState), "setAutomationState");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IAutomationState*, int, int>)Vtbl[3])(__self__, state);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IAutomationState*, int, int>)Vtbl[3])((LibVst.IAutomationState*)Unsafe.AsPointer(ref this), state);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Sets the current Automation state.
        /// </summary>
        private static partial ComResult setAutomationState_ToManaged(IAutomationState* self, int state);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setAutomationState_Wrapper(IAutomationState* self, int state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IAutomationState), "setAutomationState");
                try
                {
                    return setAutomationState_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setAutomationState_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// 
        /// </summary>
        public enum AutomationStates
        {
            /// <summary>
            /// Not Read and not Write
            /// </summary>
            kNoAutomation = 0,
            
            /// <summary>
            /// Read state
            /// </summary>
            kReadState = 1 << 0,
            
            /// <summary>
            /// Write state
            /// </summary>
            kWriteState = 1 << 1,
            
            /// <summary>
            /// Read and Write enable
            /// </summary>
            kReadWriteState = kReadState | kWriteState,
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IAutomationState, 0xB4E8287F, 0x1BB346AA, 0x83A46667, 0x68937BAB)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x7f, 0x28, 0xe8, 0xb4, 0xb3, 0x1b, 0xaa, 0x46, 0x83, 0xa4, 0x66, 0x67, 0x68, 0x93, 0x7b, 0xab })
                        : new ReadOnlySpan<byte>(new byte[] { 0xb4, 0xe8, 0x28, 0x7f, 0x1b, 0xb3, 0x46, 0xaa, 0x83, 0xa4, 0x66, 0x67, 0x68, 0x93, 0x7b, 0xab })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Context Menu interface: Vst::IContextMenu
    /// </summary>
    /// <remarks>
    ///  vstIHost vst350- [host imp]
    /// - [create with IComponentHandler3::createContextMenu(..)]
    /// - [released: 3.5.0]
    /// - [optional]A context menu is composed of Item (entry). A Item is defined by a name, a tag, a flag
    /// and a associated target (called when this item will be selected/executed). 
    /// With IContextMenu the plug-in can retrieve a Item, add a Item, remove a Item and pop-up the menu.
    /// </remarks>
    /// <seealso cref="IComponentHandler3 for more information."/>
    public unsafe partial struct IContextMenu : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 8;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IContextMenu*, int>)&getItemCount_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IContextMenu*, int, LibVst.Item*, LibVst.IContextMenuTarget**, int>)&getItem_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IContextMenu*, LibVst.Item*, LibVst.IContextMenuTarget*, int>)&addItem_Wrapper;
            vtbl[6] = (delegate*unmanaged[MemberFunction]<IContextMenu*, LibVst.Item*, LibVst.IContextMenuTarget*, int>)&removeItem_Wrapper;
            vtbl[7] = (delegate*unmanaged[MemberFunction]<IContextMenu*, int, int, int>)&popup_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IContextMenu, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IContextMenu, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IContextMenu, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Gets the number of menu items.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getItemCount()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IContextMenu*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IContextMenu), "getItemCount");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IContextMenu*, int>)Vtbl[3])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IContextMenu*, int>)Vtbl[3])((LibVst.IContextMenu*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Gets a menu item and its target (target could be not assigned).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getItem(int index, LibVst.Item* item, LibVst.IContextMenuTarget** target)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IContextMenu*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IContextMenu), "getItem");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IContextMenu*, int, LibVst.Item*, LibVst.IContextMenuTarget**, int>)Vtbl[4])(__self__, index, item, target);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IContextMenu*, int, LibVst.Item*, LibVst.IContextMenuTarget**, int>)Vtbl[4])((LibVst.IContextMenu*)Unsafe.AsPointer(ref this), index, item, target);
            }
        }
        
        /// <summary>
        /// Adds a menu item and its target.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult addItem(LibVst.Item* item, LibVst.IContextMenuTarget* target)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IContextMenu*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IContextMenu), "addItem");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IContextMenu*, LibVst.Item*, LibVst.IContextMenuTarget*, int>)Vtbl[5])(__self__, item, target);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IContextMenu*, LibVst.Item*, LibVst.IContextMenuTarget*, int>)Vtbl[5])((LibVst.IContextMenu*)Unsafe.AsPointer(ref this), item, target);
            }
        }
        
        /// <summary>
        /// Removes a menu item.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult removeItem(LibVst.Item* item, LibVst.IContextMenuTarget* target)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IContextMenu*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IContextMenu), "removeItem");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IContextMenu*, LibVst.Item*, LibVst.IContextMenuTarget*, int>)Vtbl[6])(__self__, item, target);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IContextMenu*, LibVst.Item*, LibVst.IContextMenuTarget*, int>)Vtbl[6])((LibVst.IContextMenu*)Unsafe.AsPointer(ref this), item, target);
            }
        }
        
        /// <summary>
        /// Pop-ups the menu. Coordinates are relative to the top-left position of the plug-ins view.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult popup(LibVst.UCoord x, LibVst.UCoord y)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IContextMenu*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IContextMenu), "popup");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IContextMenu*, LibVst.UCoord, LibVst.UCoord, int>)Vtbl[7])(__self__, x, y);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IContextMenu*, LibVst.UCoord, LibVst.UCoord, int>)Vtbl[7])((LibVst.IContextMenu*)Unsafe.AsPointer(ref this), x, y);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Gets the number of menu items.
        /// </summary>
        private static partial int getItemCount_ToManaged(IContextMenu* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getItemCount_Wrapper(IContextMenu* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IContextMenu), "getItemCount");
                try
                {
                    return getItemCount_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getItemCount_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Gets a menu item and its target (target could be not assigned).
        /// </summary>
        private static partial ComResult getItem_ToManaged(IContextMenu* self, int index, LibVst.Item* item, LibVst.IContextMenuTarget** target);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getItem_Wrapper(IContextMenu* self, int index, LibVst.Item* item, LibVst.IContextMenuTarget** target)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IContextMenu), "getItem");
                try
                {
                    return getItem_ToManaged(self, index, item, target);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getItem_ToManaged(self, index, item, target);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Adds a menu item and its target.
        /// </summary>
        private static partial ComResult addItem_ToManaged(IContextMenu* self, LibVst.Item* item, LibVst.IContextMenuTarget* target);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int addItem_Wrapper(IContextMenu* self, LibVst.Item* item, LibVst.IContextMenuTarget* target)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IContextMenu), "addItem");
                try
                {
                    return addItem_ToManaged(self, item, target);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return addItem_ToManaged(self, item, target);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Removes a menu item.
        /// </summary>
        private static partial ComResult removeItem_ToManaged(IContextMenu* self, LibVst.Item* item, LibVst.IContextMenuTarget* target);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int removeItem_Wrapper(IContextMenu* self, LibVst.Item* item, LibVst.IContextMenuTarget* target)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IContextMenu), "removeItem");
                try
                {
                    return removeItem_ToManaged(self, item, target);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return removeItem_ToManaged(self, item, target);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Pop-ups the menu. Coordinates are relative to the top-left position of the plug-ins view.
        /// </summary>
        private static partial ComResult popup_ToManaged(IContextMenu* self, LibVst.UCoord x, LibVst.UCoord y);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int popup_Wrapper(IContextMenu* self, int x, int y)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IContextMenu), "popup");
                try
                {
                    return popup_ToManaged(self, x, y);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return popup_ToManaged(self, x, y);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IContextMenu, 0x2E93C863, 0x0C9C4588, 0x97DBECF5, 0xAD17817D)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x63, 0xc8, 0x93, 0x2e, 0x9c, 0x0c, 0x88, 0x45, 0x97, 0xdb, 0xec, 0xf5, 0xad, 0x17, 0x81, 0x7d })
                        : new ReadOnlySpan<byte>(new byte[] { 0x2e, 0x93, 0xc8, 0x63, 0x0c, 0x9c, 0x45, 0x88, 0x97, 0xdb, 0xec, 0xf5, 0xad, 0x17, 0x81, 0x7d })
                    )));
            }
        }
    }
    
    /// <summary>
    /// IContextMenuItem is an entry element of the context menu.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct IContextMenuItem
    {
        /// <summary>
        /// Name of the item
        /// </summary>
        public LibVst.String128 name;
        
        /// <summary>
        /// Identifier tag of the item
        /// </summary>
        public int tag;
        
        /// <summary>
        /// Flags of the item
        /// </summary>
        public int flags;
        
        public enum Flags
        {
            /// <summary>
            /// Item is a separator
            /// </summary>
            kIsSeparator = 1 << 0,
            
            /// <summary>
            /// Item is disabled
            /// </summary>
            kIsDisabled = 1 << 1,
            
            /// <summary>
            /// Item is checked
            /// </summary>
            kIsChecked = 1 << 2,
            
            /// <summary>
            /// Item is a group start (like sub folder)
            /// </summary>
            kIsGroupStart = 1 << 3 | kIsDisabled,
            
            /// <summary>
            /// Item is a group end
            /// </summary>
            kIsGroupEnd = 1 << 4 | kIsSeparator,
        }
    }
    
    public partial record struct Item(LibVst.IContextMenuItem Value)
    {
        public static implicit operator LibVst.IContextMenuItem(Item value) => value.Value;
        
        public static implicit operator Item(LibVst.IContextMenuItem value) => new(value);
    }
    
    /// <summary>
    /// Context Menu Item Target interface: Vst::IContextMenuTarget
    /// </summary>
    /// <remarks>
    ///  vstIHost vstIPlug vst350- [host imp]
    /// - [plug imp]
    /// - [released: 3.5.0]
    /// - [optional]A receiver of a menu item should implement this interface, which will be called after the user has selected
    /// this menu item.
    /// </remarks>
    /// <seealso cref="IComponentHandler3 for more information."/>
    public unsafe partial struct IContextMenuTarget : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IContextMenuTarget*, int, int>)&executeMenuItem_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IContextMenuTarget, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IContextMenuTarget, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IContextMenuTarget, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Called when an menu item was executed.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult executeMenuItem(int tag)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IContextMenuTarget*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IContextMenuTarget), "executeMenuItem");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IContextMenuTarget*, int, int>)Vtbl[3])(__self__, tag);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IContextMenuTarget*, int, int>)Vtbl[3])((LibVst.IContextMenuTarget*)Unsafe.AsPointer(ref this), tag);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Called when an menu item was executed.
        /// </summary>
        private static partial ComResult executeMenuItem_ToManaged(IContextMenuTarget* self, int tag);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int executeMenuItem_Wrapper(IContextMenuTarget* self, int tag)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IContextMenuTarget), "executeMenuItem");
                try
                {
                    return executeMenuItem_ToManaged(self, tag);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return executeMenuItem_ToManaged(self, tag);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IContextMenuTarget, 0x3CDF2E75, 0x85D34144, 0xBF86D36B, 0xD7C4894D)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x75, 0x2e, 0xdf, 0x3c, 0xd3, 0x85, 0x44, 0x41, 0xbf, 0x86, 0xd3, 0x6b, 0xd7, 0xc4, 0x89, 0x4d })
                        : new ReadOnlySpan<byte>(new byte[] { 0x3c, 0xdf, 0x2e, 0x75, 0x85, 0xd3, 0x41, 0x44, 0xbf, 0x86, 0xd3, 0x6b, 0xd7, 0xc4, 0x89, 0x4d })
                    )));
            }
        }
    }
    
    public partial record struct UCoord(int Value)
    {
        public static implicit operator int(UCoord value) => value.Value;
        
        public static implicit operator UCoord(int value) => new(value);
    }
    
    /// <summary>
    /// Extended host callback interface Vst::IComponentHandler3 for an edit controller.
    /// </summary>
    /// <remarks>
    ///  vstIHost vst350- [host imp]
    /// - [extends IComponentHandler]
    /// - [released: 3.5.0]
    /// - [optional]A plug-in can ask the host to create a context menu for a given exported parameter ID or a generic context menu.@nThe host may pre-fill this context menu with specific items regarding the parameter ID like "Show automation for parameter",
    /// "MIDI learn" etc...@nThe plug-in can use the context menu in two ways :
    /// - add its own items to the menu via the IContextMenu interface and call IContextMenu::popup(..) to create the pop-up. See the @ref IContextMenuExample.- extract the host menu items and add them to a context menu created by the plug-in.@b Note: You can and should use this even if you do not add your own items to the menu as this is considered to be a big user value. IContextMenuExample Examples- For example, Cubase adds its owned entries in the context menu opened with right-click on an exported parameter when the plug-in uses createContextMenu. html "contextmenuexample.png"@n - Adding plug-in specific items to the context menu:@code {.cpp}
    /// //------------------------------------------------------------------------
    /// class PluginContextMenuTarget : public IContextMenuTarget, public FObject
    /// {
    /// public:
    /// 	PluginContextMenuTarget () {}
    /// 
    /// 	virtual tresult PLUGIN_API executeMenuItem (int32 tag)
    /// 	{
    /// 		// this will be called if the user has executed one of the menu items of the plug-in.
    /// 		// It will not be called for items of the host.
    /// 		switch (tag)
    /// 		{
    /// 			case 1: break;
    /// 			case 2: break;
    /// 		}
    /// 		return kResultTrue;
    /// 	}
    /// 
    /// 	OBJ_METHODS(PluginContextMenuTarget, FObject)
    /// 	DEFINE_INTERFACES
    /// 		DEF_INTERFACE (IContextMenuTarget)
    /// 	END_DEFINE_INTERFACES (FObject)
    /// 	REFCOUNT_METHODS(FObject)
    /// };
    /// 
    /// // The following is the code to create the context menu
    /// void popupContextMenu (IComponentHandler* componentHandler, IPlugView* view, const ParamID* paramID, UCoord x, UCoord y)
    /// {
    /// 	if (componentHandler == 0 || view == 0)
    /// 		return;
    /// 	FUnknownPtr&lt;IComponentHandler3&gt; handler (componentHandler);
    /// 	if (handler == 0)
    /// 		return;
    /// 	IContextMenu* menu = handler-&gt;createContextMenu (view, paramID);
    /// 	if (menu)
    /// 	{
    /// 		// here you can add your entries (optional)
    /// 		PluginContextMenuTarget* target = new PluginContextMenuTarget ();
    /// 		
    /// 		IContextMenu::Item item = {0};
    /// 		UString128 ("My Item 1").copyTo (item.name, 128);
    /// 		item.tag = 1;
    /// 		menu-&gt;addItem (item, target);
    /// 
    /// 		UString128 ("My Item 2").copyTo (item.name, 128);
    /// 		item.tag = 2;
    /// 		menu-&gt;addItem (item, target);
    /// 		target-&gt;release ();
    /// 		//--end of adding new entries
    /// 		
    /// 		// here the the context menu will be pop-up (and it waits a user interaction)
    /// 		menu-&gt;popup (x, y);
    /// 		menu-&gt;release ();
    /// 	}
    /// }
    /// @endcode
    /// </remarks>
    /// <seealso cref="IContextMenu"/>
    /// <seealso cref="IContextMenuTarget"/>
    public unsafe partial struct IComponentHandler3 : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IComponentHandler3*, LibVst.IPlugView*, LibVst.ParamID*, LibVst.IContextMenu*>)&createContextMenu_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IComponentHandler3, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IComponentHandler3, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IComponentHandler3, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Creates a host context menu for a plug-in:
        /// - If paramID is zero, the host may create a generic context menu.
        /// - The IPlugView object must be valid.
        /// - The return IContextMenu object needs to be released afterwards by the plug-in.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IContextMenu* createContextMenu(LibVst.IPlugView* plugView, LibVst.ParamID* paramID)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponentHandler3*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponentHandler3), "createContextMenu");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandler3*, LibVst.IPlugView*, LibVst.ParamID*, LibVst.IContextMenu*>)Vtbl[3])(__self__, plugView, paramID);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandler3*, LibVst.IPlugView*, LibVst.ParamID*, LibVst.IContextMenu*>)Vtbl[3])((LibVst.IComponentHandler3*)Unsafe.AsPointer(ref this), plugView, paramID);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Creates a host context menu for a plug-in:
        /// - If paramID is zero, the host may create a generic context menu.
        /// - The IPlugView object must be valid.
        /// - The return IContextMenu object needs to be released afterwards by the plug-in.
        /// </summary>
        private static partial LibVst.IContextMenu* createContextMenu_ToManaged(IComponentHandler3* self, LibVst.IPlugView* plugView, LibVst.ParamID* paramID);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static LibVst.IContextMenu* createContextMenu_Wrapper(IComponentHandler3* self, LibVst.IPlugView* plugView, LibVst.ParamID* paramID)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponentHandler3), "createContextMenu");
                try
                {
                    return createContextMenu_ToManaged(self, plugView, paramID);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return createContextMenu_ToManaged(self, plugView, paramID);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IComponentHandler3, 0x69F11617, 0xD26B400D, 0xA4B6B964, 0x7B6EBBAB)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x17, 0x16, 0xf1, 0x69, 0x6b, 0xd2, 0x0d, 0x40, 0xa4, 0xb6, 0xb9, 0x64, 0x7b, 0x6e, 0xbb, 0xab })
                        : new ReadOnlySpan<byte>(new byte[] { 0x69, 0xf1, 0x16, 0x17, 0xd2, 0x6b, 0x40, 0x0d, 0xa4, 0xb6, 0xb9, 0x64, 0x7b, 0x6e, 0xbb, 0xab })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Host callback interface for an edit controller: Vst::IComponentHandler
    /// </summary>
    /// <remarks>
    ///  vstIHost vst300- [host imp]
    /// - [released: 3.0.0]
    /// - [mandatory]Allow transfer of parameter editing to component (processor) via host and support automation.
    /// Cause the host to react on configuration changes (restartComponent).
    /// </remarks>
    /// <seealso cref="IEditController"/>
    public unsafe partial struct IComponentHandler : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 7;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IComponentHandler*, uint, int>)&beginEdit_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IComponentHandler*, uint, double, int>)&performEdit_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IComponentHandler*, uint, int>)&endEdit_Wrapper;
            vtbl[6] = (delegate*unmanaged[MemberFunction]<IComponentHandler*, int, int>)&restartComponent_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IComponentHandler, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IComponentHandler, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IComponentHandler, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// To be called before calling a performEdit (e.g. on mouse-click-down event).
        /// This must be called in the UI-Thread context!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult beginEdit(LibVst.ParamID id)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponentHandler*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponentHandler), "beginEdit");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandler*, LibVst.ParamID, int>)Vtbl[3])(__self__, id);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandler*, LibVst.ParamID, int>)Vtbl[3])((LibVst.IComponentHandler*)Unsafe.AsPointer(ref this), id);
            }
        }
        
        /// <summary>
        /// Called between beginEdit and endEdit to inform the handler that a given parameter has a new
        /// value. This must be called in the UI-Thread context!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult performEdit(LibVst.ParamID id, LibVst.ParamValue valueNormalized)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponentHandler*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponentHandler), "performEdit");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandler*, LibVst.ParamID, LibVst.ParamValue, int>)Vtbl[4])(__self__, id, valueNormalized);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandler*, LibVst.ParamID, LibVst.ParamValue, int>)Vtbl[4])((LibVst.IComponentHandler*)Unsafe.AsPointer(ref this), id, valueNormalized);
            }
        }
        
        /// <summary>
        /// To be called after calling a performEdit (e.g. on mouse-click-up event).
        /// This must be called in the UI-Thread context!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult endEdit(LibVst.ParamID id)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponentHandler*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponentHandler), "endEdit");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandler*, LibVst.ParamID, int>)Vtbl[5])(__self__, id);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandler*, LibVst.ParamID, int>)Vtbl[5])((LibVst.IComponentHandler*)Unsafe.AsPointer(ref this), id);
            }
        }
        
        /// <summary>
        /// Instructs host to restart the component. This must be called in the UI-Thread context!
        /// </summary>
        /// <param name="flags">is a combination of RestartFlags</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult restartComponent(int flags)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponentHandler*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponentHandler), "restartComponent");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandler*, int, int>)Vtbl[6])(__self__, flags);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandler*, int, int>)Vtbl[6])((LibVst.IComponentHandler*)Unsafe.AsPointer(ref this), flags);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// To be called before calling a performEdit (e.g. on mouse-click-down event).
        /// This must be called in the UI-Thread context!
        /// </summary>
        private static partial ComResult beginEdit_ToManaged(IComponentHandler* self, LibVst.ParamID id);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int beginEdit_Wrapper(IComponentHandler* self, uint id)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponentHandler), "beginEdit");
                try
                {
                    return beginEdit_ToManaged(self, id);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return beginEdit_ToManaged(self, id);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Called between beginEdit and endEdit to inform the handler that a given parameter has a new
        /// value. This must be called in the UI-Thread context!
        /// </summary>
        private static partial ComResult performEdit_ToManaged(IComponentHandler* self, LibVst.ParamID id, LibVst.ParamValue valueNormalized);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int performEdit_Wrapper(IComponentHandler* self, uint id, double valueNormalized)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponentHandler), "performEdit");
                try
                {
                    return performEdit_ToManaged(self, id, valueNormalized);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return performEdit_ToManaged(self, id, valueNormalized);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// To be called after calling a performEdit (e.g. on mouse-click-up event).
        /// This must be called in the UI-Thread context!
        /// </summary>
        private static partial ComResult endEdit_ToManaged(IComponentHandler* self, LibVst.ParamID id);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int endEdit_Wrapper(IComponentHandler* self, uint id)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponentHandler), "endEdit");
                try
                {
                    return endEdit_ToManaged(self, id);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return endEdit_ToManaged(self, id);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Instructs host to restart the component. This must be called in the UI-Thread context!
        /// </summary>
        /// <param name="flags">is a combination of RestartFlags</param>
        private static partial ComResult restartComponent_ToManaged(IComponentHandler* self, int flags);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int restartComponent_Wrapper(IComponentHandler* self, int flags)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponentHandler), "restartComponent");
                try
                {
                    return restartComponent_ToManaged(self, flags);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return restartComponent_ToManaged(self, flags);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IComponentHandler, 0x93A0BEA3, 0x0BD045DB, 0x8E890B0C, 0xC1E46AC6)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xa3, 0xbe, 0xa0, 0x93, 0xd0, 0x0b, 0xdb, 0x45, 0x8e, 0x89, 0x0b, 0x0c, 0xc1, 0xe4, 0x6a, 0xc6 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x93, 0xa0, 0xbe, 0xa3, 0x0b, 0xd0, 0x45, 0xdb, 0x8e, 0x89, 0x0b, 0x0c, 0xc1, 0xe4, 0x6a, 0xc6 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Extended host callback interface for an edit controller: Vst::IComponentHandler2
    /// </summary>
    /// <remarks>
    ///  vstIHost vst310- [host imp]
    /// - [extends IComponentHandler]
    /// - [released: 3.1.0]
    /// - [optional]One part handles:
    /// - Setting dirty state of the plug-in
    /// - Requesting the host to open the editorThe other part handles parameter group editing from the plug-in UI. It wraps a set of @ref IComponentHandler::beginEdit /@ref Steinberg::Vst::IComponentHandler::performEdit / @ref Steinberg::Vst::IComponentHandler::endEdit functions (see @ref IComponentHandler)which should use the same timestamp in the host when writing automation.
    /// This allows for better synchronizing of multiple parameter changes at once. IComponentHandler2Example Examples of different use cases@code {.cpp}
    /// //--------------------------------------
    /// // we are in the editcontroller...
    /// // in case of multiple switch buttons (with associated ParamID 1 and 3)
    /// // on mouse down :
    /// hostHandler2-&gt;startGroupEdit ();
    /// hostHandler-&gt;beginEdit (1);
    /// hostHandler-&gt;beginEdit (3);
    /// hostHandler-&gt;performEdit (1, 1.0);
    /// hostHandler-&gt;performEdit (3, 0.0); // the opposite of paramID 1 for example
    /// ....
    /// // on mouse up :
    /// hostHandler-&gt;endEdit (1);
    /// hostHandler-&gt;endEdit (3);
    /// hostHandler2-&gt;finishGroupEdit ();
    /// ....
    /// ....
    /// //--------------------------------------
    /// // in case of multiple faders (with associated ParamID 1 and 3)
    /// // on mouse down :
    /// hostHandler2-&gt;startGroupEdit ();
    /// hostHandler-&gt;beginEdit (1);
    /// hostHandler-&gt;beginEdit (3);
    /// hostHandler2-&gt;finishGroupEdit ();
    /// ....
    /// // on mouse move :
    /// hostHandler2-&gt;startGroupEdit ();
    /// hostHandler-&gt;performEdit (1, x); // x the wanted value
    /// hostHandler-&gt;performEdit (3, x);
    /// hostHandler2-&gt;finishGroupEdit ();
    /// ....
    /// // on mouse up :
    /// hostHandler2-&gt;startGroupEdit ();
    /// hostHandler-&gt;endEdit (1);
    /// hostHandler-&gt;endEdit (3);
    /// hostHandler2-&gt;finishGroupEdit ();
    /// @endcode
    /// </remarks>
    /// <seealso cref="IEditControllerIComponentHandler,"/>
    public unsafe partial struct IComponentHandler2 : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 7;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IComponentHandler2*, byte, int>)&setDirty_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IComponentHandler2*, byte*, int>)&requestOpenEditor_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IComponentHandler2*, int>)&startGroupEdit_Wrapper;
            vtbl[6] = (delegate*unmanaged[MemberFunction]<IComponentHandler2*, int>)&finishGroupEdit_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IComponentHandler2, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IComponentHandler2, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IComponentHandler2, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Tells host that the plug-in is dirty (something besides parameters has changed since last save),
        /// if true the host should apply a save before quitting.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setDirty(byte state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponentHandler2*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponentHandler2), "setDirty");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandler2*, byte, int>)Vtbl[3])(__self__, state);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandler2*, byte, int>)Vtbl[3])((LibVst.IComponentHandler2*)Unsafe.AsPointer(ref this), state);
            }
        }
        
        /// <summary>
        /// Tells host that it should open the plug-in editor the next time it's possible.
        /// You should use this instead of showing an alert and blocking the program flow (especially on loading projects).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult requestOpenEditor(LibVst.FIDString name)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponentHandler2*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponentHandler2), "requestOpenEditor");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandler2*, LibVst.FIDString, int>)Vtbl[4])(__self__, name);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandler2*, LibVst.FIDString, int>)Vtbl[4])((LibVst.IComponentHandler2*)Unsafe.AsPointer(ref this), name);
            }
        }
        
        /// <summary>
        /// Starts the group editing (call before a @ref IComponentHandler::beginEdit), the host will keep the current timestamp at this call and will use it for all @ref IComponentHandler::beginEdit / @ref IComponentHandler::performEdit / @ref IComponentHandler::endEdit calls until a @ref finishGroupEdit ().
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult startGroupEdit()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponentHandler2*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponentHandler2), "startGroupEdit");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandler2*, int>)Vtbl[5])(__self__);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandler2*, int>)Vtbl[5])((LibVst.IComponentHandler2*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Finishes the group editing started by a @ref startGroupEdit (call after a @ref IComponentHandler::endEdit).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult finishGroupEdit()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponentHandler2*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponentHandler2), "finishGroupEdit");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandler2*, int>)Vtbl[6])(__self__);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandler2*, int>)Vtbl[6])((LibVst.IComponentHandler2*)Unsafe.AsPointer(ref this));
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Tells host that the plug-in is dirty (something besides parameters has changed since last save),
        /// if true the host should apply a save before quitting.
        /// </summary>
        private static partial ComResult setDirty_ToManaged(IComponentHandler2* self, byte state);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setDirty_Wrapper(IComponentHandler2* self, byte state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponentHandler2), "setDirty");
                try
                {
                    return setDirty_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setDirty_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Tells host that it should open the plug-in editor the next time it's possible.
        /// You should use this instead of showing an alert and blocking the program flow (especially on loading projects).
        /// </summary>
        private static partial ComResult requestOpenEditor_ToManaged(IComponentHandler2* self, LibVst.FIDString name);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int requestOpenEditor_Wrapper(IComponentHandler2* self, byte* name)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponentHandler2), "requestOpenEditor");
                try
                {
                    return requestOpenEditor_ToManaged(self, name);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return requestOpenEditor_ToManaged(self, name);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Starts the group editing (call before a @ref IComponentHandler::beginEdit), the host will keep the current timestamp at this call and will use it for all @ref IComponentHandler::beginEdit / @ref IComponentHandler::performEdit / @ref IComponentHandler::endEdit calls until a @ref finishGroupEdit ().
        /// </summary>
        private static partial ComResult startGroupEdit_ToManaged(IComponentHandler2* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int startGroupEdit_Wrapper(IComponentHandler2* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponentHandler2), "startGroupEdit");
                try
                {
                    return startGroupEdit_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return startGroupEdit_ToManaged(self);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Finishes the group editing started by a @ref startGroupEdit (call after a @ref IComponentHandler::endEdit).
        /// </summary>
        private static partial ComResult finishGroupEdit_ToManaged(IComponentHandler2* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int finishGroupEdit_Wrapper(IComponentHandler2* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponentHandler2), "finishGroupEdit");
                try
                {
                    return finishGroupEdit_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return finishGroupEdit_ToManaged(self);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IComponentHandler2, 0xF040B4B3, 0xA36045EC, 0xABCDC045, 0xB4D5A2CC)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xb3, 0xb4, 0x40, 0xf0, 0x60, 0xa3, 0xec, 0x45, 0xab, 0xcd, 0xc0, 0x45, 0xb4, 0xd5, 0xa2, 0xcc })
                        : new ReadOnlySpan<byte>(new byte[] { 0xf0, 0x40, 0xb4, 0xb3, 0xa3, 0x60, 0x45, 0xec, 0xab, 0xcd, 0xc0, 0x45, 0xb4, 0xd5, 0xa2, 0xcc })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Extended host callback interface for an edit controller: Vst::IComponentHandlerBusActivation
    /// </summary>
    /// <remarks>
    ///  vstIHost vst368- [host imp]
    /// - [extends IComponentHandler]
    /// - [released: 3.6.8]
    /// - [optional]Allows the plug-in to request the host to activate or deactivate a specific bus. 
    /// If the host accepts this request, it will call later on @ref IComponent::activateBus. This is particularly useful for instruments with more than 1 outputs, where the user could request
    /// from the plug-in UI a given output bus activation.@code {.cpp}
    /// 	// somewhere in your code when you need to inform the host to enable a specific Bus.
    /// 	FUnknownPtr&lt;IComponentHandlerBusActivation&gt; busActivation (componentHandler);
    /// 	if (busActivation)
    /// 	{
    /// 		// here we want to activate our audio input sidechain (the 2cd input bus: index 1)
    /// 		busActivation-&gt;requestBusActivation (kAudio, kInput, 1, true);
    /// 	}
    /// @endcode
    /// </remarks>
    /// <seealso cref="IComponentHandler"/>
    public unsafe partial struct IComponentHandlerBusActivation : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IComponentHandlerBusActivation*, int, int, int, byte, int>)&requestBusActivation_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IComponentHandlerBusActivation, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IComponentHandlerBusActivation, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IComponentHandlerBusActivation, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// request the host to activate or deactivate a specific bus.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult requestBusActivation(LibVst.MediaType type, LibVst.BusDirection dir, int index, byte state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IComponentHandlerBusActivation*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IComponentHandlerBusActivation), "requestBusActivation");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandlerBusActivation*, LibVst.MediaType, LibVst.BusDirection, int, byte, int>)Vtbl[3])(__self__, type, dir, index, state);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IComponentHandlerBusActivation*, LibVst.MediaType, LibVst.BusDirection, int, byte, int>)Vtbl[3])((LibVst.IComponentHandlerBusActivation*)Unsafe.AsPointer(ref this), type, dir, index, state);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// request the host to activate or deactivate a specific bus.
        /// </summary>
        private static partial ComResult requestBusActivation_ToManaged(IComponentHandlerBusActivation* self, LibVst.MediaType type, LibVst.BusDirection dir, int index, byte state);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int requestBusActivation_Wrapper(IComponentHandlerBusActivation* self, int type, int dir, int index, byte state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IComponentHandlerBusActivation), "requestBusActivation");
                try
                {
                    return requestBusActivation_ToManaged(self, type, dir, index, state);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return requestBusActivation_ToManaged(self, type, dir, index, state);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IComponentHandlerBusActivation, 0x067D02C1, 0x5B4E274D, 0xA92D90FD, 0x6EAF7240)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xc1, 0x02, 0x7d, 0x06, 0x4e, 0x5b, 0x4d, 0x27, 0xa9, 0x2d, 0x90, 0xfd, 0x6e, 0xaf, 0x72, 0x40 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x06, 0x7d, 0x02, 0xc1, 0x5b, 0x4e, 0x27, 0x4d, 0xa9, 0x2d, 0x90, 0xfd, 0x6e, 0xaf, 0x72, 0x40 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Extended host callback interface for an edit controller: Vst::IProgress
    /// </summary>
    /// <remarks>
    ///  vstIHost vst370- [host imp]
    /// - [extends IComponentHandler]
    /// - [released: 3.7.0]
    /// - [optional]Allows the plug-in to request the host to create a progress for some specific tasks which take
    /// some time. The host can visualize the progress as read-only UI elements. For example,
    /// after loading a project where a plug-in needs to load extra
    /// data (e.g. samples) in a background thread, this enables the host to get and visualize the current status of the loading
    /// progress and to inform the user when the loading is finished.
    /// Note: During the progress, the host can unload the plug-in at any time. Make sure that the plug-in 
    /// supports this use case. IProgressExample Example@code {.cpp}
    /// //--------------------------------------
    /// // we are in the editcontroller:
    /// // as member: IProgress::ID mProgressID;
    /// 
    /// FUnknownPtr&lt;IProgress&gt; progress (componentHandler);
    /// if (progress)
    /// 	progress-&gt;start (IProgress::ProgressType::UIBackgroundTask, STR ("Load Samples..."), mProgressID);
    /// 
    /// // ...
    /// myProgressValue += incProgressStep;
    /// FUnknownPtr&lt;IProgress&gt; progress (componentHandler);
    /// if (progress)
    /// 	progress-&gt;update (mProgressID, myProgressValue);
    /// 
    /// // ...
    /// FUnknownPtr&lt;IProgress&gt; progress (componentHandler);
    /// if (progress)
    /// 	progress-&gt;finish (mProgressID);
    /// @endcode
    /// </remarks>
    /// <seealso cref="IComponentHandler"/>
    public unsafe partial struct IProgress : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 6;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IProgress*, ProgressType, char*, LibVst.ID*, int>)&start_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IProgress*, ulong, double, int>)&update_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IProgress*, ulong, int>)&finish_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IProgress, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IProgress, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IProgress, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Start a new progress of a given type and optional Description. outID is as ID created by the
        /// host to identify this newly created progress (for update and finish method)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult start(ProgressType type, char* optionalDescription, LibVst.ID* outID)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IProgress*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IProgress), "start");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IProgress*, ProgressType, char*, LibVst.ID*, int>)Vtbl[3])(__self__, type, optionalDescription, outID);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IProgress*, ProgressType, char*, LibVst.ID*, int>)Vtbl[3])((LibVst.IProgress*)Unsafe.AsPointer(ref this), type, optionalDescription, outID);
            }
        }
        
        /// <summary>
        /// Update the progress value (normValue between [0, 1]) associated to the given id
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult update(LibVst.ID id, LibVst.ParamValue normValue)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IProgress*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IProgress), "update");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IProgress*, LibVst.ID, LibVst.ParamValue, int>)Vtbl[4])(__self__, id, normValue);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IProgress*, LibVst.ID, LibVst.ParamValue, int>)Vtbl[4])((LibVst.IProgress*)Unsafe.AsPointer(ref this), id, normValue);
            }
        }
        
        /// <summary>
        /// Finish the progress associated to the given id
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult finish(LibVst.ID id)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IProgress*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IProgress), "finish");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IProgress*, LibVst.ID, int>)Vtbl[5])(__self__, id);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IProgress*, LibVst.ID, int>)Vtbl[5])((LibVst.IProgress*)Unsafe.AsPointer(ref this), id);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Start a new progress of a given type and optional Description. outID is as ID created by the
        /// host to identify this newly created progress (for update and finish method)
        /// </summary>
        private static partial ComResult start_ToManaged(IProgress* self, ProgressType type, char* optionalDescription, LibVst.ID* outID);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int start_Wrapper(IProgress* self, ProgressType type, char* optionalDescription, LibVst.ID* outID)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IProgress), "start");
                try
                {
                    return start_ToManaged(self, type, optionalDescription, outID);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return start_ToManaged(self, type, optionalDescription, outID);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Update the progress value (normValue between [0, 1]) associated to the given id
        /// </summary>
        private static partial ComResult update_ToManaged(IProgress* self, LibVst.ID id, LibVst.ParamValue normValue);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int update_Wrapper(IProgress* self, ulong id, double normValue)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IProgress), "update");
                try
                {
                    return update_ToManaged(self, id, normValue);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return update_ToManaged(self, id, normValue);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Finish the progress associated to the given id
        /// </summary>
        private static partial ComResult finish_ToManaged(IProgress* self, LibVst.ID id);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int finish_Wrapper(IProgress* self, ulong id)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IProgress), "finish");
                try
                {
                    return finish_ToManaged(self, id);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return finish_ToManaged(self, id);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// 
        /// </summary>
        public enum ProgressType : uint
        {
            /// <summary>
            /// plug-in state is restored async (in a background Thread)
            /// </summary>
            AsyncStateRestoration = 0,
            
            /// <summary>
            /// a plug-in task triggered by a UI action
            /// </summary>
            UIBackgroundTask,
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IProgress, 0x00C9DC5B, 0x9D904254, 0x91A388C8, 0xB4E91B69)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x5b, 0xdc, 0xc9, 0x00, 0x90, 0x9d, 0x54, 0x42, 0x91, 0xa3, 0x88, 0xc8, 0xb4, 0xe9, 0x1b, 0x69 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x00, 0xc9, 0xdc, 0x5b, 0x9d, 0x90, 0x42, 0x54, 0x91, 0xa3, 0x88, 0xc8, 0xb4, 0xe9, 0x1b, 0x69 })
                    )));
            }
        }
    }
    
    public partial record struct ID(ulong Value)
    {
        public static implicit operator ulong(ID value) => value.Value;
        
        public static implicit operator ID(ulong value) => new(value);
    }
    
    /// <summary>
    /// Edit controller component interface: Vst::IEditController
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst300- [plug imp]
    /// - [released: 3.0.0]
    /// - [mandatory]The controller part of an effect or instrument with parameter handling (export, definition, conversion...).
    /// </remarks>
    /// <seealso cref="IMidiMappingIComponent::getControllerClassId,"/>
    public unsafe partial struct IEditController : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 18;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            IPluginBase.InitializeVtbl(vtbl);
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IEditController*, LibVst.IBStream*, int>)&setComponentState_Wrapper;
            vtbl[6] = (delegate*unmanaged[MemberFunction]<IEditController*, LibVst.IBStream*, int>)&setState_Wrapper;
            vtbl[7] = (delegate*unmanaged[MemberFunction]<IEditController*, LibVst.IBStream*, int>)&getState_Wrapper;
            vtbl[8] = (delegate*unmanaged[MemberFunction]<IEditController*, int>)&getParameterCount_Wrapper;
            vtbl[9] = (delegate*unmanaged[MemberFunction]<IEditController*, int, LibVst.ParameterInfo*, int>)&getParameterInfo_Wrapper;
            vtbl[10] = (delegate*unmanaged[MemberFunction]<IEditController*, uint, double, LibVst.String128*, int>)&getParamStringByValue_Wrapper;
            vtbl[11] = (delegate*unmanaged[MemberFunction]<IEditController*, uint, char*, LibVst.ParamValue*, int>)&getParamValueByString_Wrapper;
            vtbl[12] = (delegate*unmanaged[MemberFunction]<IEditController*, uint, double, double>)&normalizedParamToPlain_Wrapper;
            vtbl[13] = (delegate*unmanaged[MemberFunction]<IEditController*, uint, double, double>)&plainParamToNormalized_Wrapper;
            vtbl[14] = (delegate*unmanaged[MemberFunction]<IEditController*, uint, double>)&getParamNormalized_Wrapper;
            vtbl[15] = (delegate*unmanaged[MemberFunction]<IEditController*, uint, double, int>)&setParamNormalized_Wrapper;
            vtbl[16] = (delegate*unmanaged[MemberFunction]<IEditController*, LibVst.IComponentHandler*, int>)&setComponentHandler_Wrapper;
            vtbl[17] = (delegate*unmanaged[MemberFunction]<IEditController*, byte*, LibVst.IPlugView*>)&createView_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IEditController, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IEditController, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IEditController, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// The host passes a number of interfaces as context to initialize the plug-in class.
        /// </summary>
        /// <param name="context,">passed by the host, is mandatory and should implement IHostApplication</param>
        /// <note>
        /// Extensive memory allocations etc. should be performed in this method rather than in
        /// the class' constructor! If the method does NOT return kResultOk, the object is released
        /// immediately. In this case terminate is not called!
        /// </note>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult initialize(LibVst.FUnknown* context)
        {
            return Unsafe.As<IEditController, IPluginBase>(ref this).initialize(context);
        }
        
        /// <summary>
        /// This function is called before the plug-in is unloaded and can be used for
        /// cleanups. You have to release all references to any host application interfaces.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult terminate()
        {
            return Unsafe.As<IEditController, IPluginBase>(ref this).terminate();
        }
        
        /// <summary>
        /// Receives the component state.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setComponentState(LibVst.IBStream* state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEditController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEditController), "setComponentState");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.IBStream*, int>)Vtbl[5])(__self__, state);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.IBStream*, int>)Vtbl[5])((LibVst.IEditController*)Unsafe.AsPointer(ref this), state);
            }
        }
        
        /// <summary>
        /// Sets the controller state.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setState(LibVst.IBStream* state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEditController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEditController), "setState");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.IBStream*, int>)Vtbl[6])(__self__, state);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.IBStream*, int>)Vtbl[6])((LibVst.IEditController*)Unsafe.AsPointer(ref this), state);
            }
        }
        
        /// <summary>
        /// Gets the controller state.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getState(LibVst.IBStream* state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEditController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEditController), "getState");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.IBStream*, int>)Vtbl[7])(__self__, state);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.IBStream*, int>)Vtbl[7])((LibVst.IEditController*)Unsafe.AsPointer(ref this), state);
            }
        }
        
        /// <summary>
        /// parameters -------------------------
        /// Returns the number of parameters exported.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getParameterCount()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEditController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEditController), "getParameterCount");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, int>)Vtbl[8])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, int>)Vtbl[8])((LibVst.IEditController*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Gets for a given index the parameter information.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getParameterInfo(int paramIndex, LibVst.ParameterInfo* info)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEditController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEditController), "getParameterInfo");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, int, LibVst.ParameterInfo*, int>)Vtbl[9])(__self__, paramIndex, info);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, int, LibVst.ParameterInfo*, int>)Vtbl[9])((LibVst.IEditController*)Unsafe.AsPointer(ref this), paramIndex, info);
            }
        }
        
        /// <summary>
        /// Gets for a given paramID and normalized value its associated string representation.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getParamStringByValue(LibVst.ParamID id, LibVst.ParamValue valueNormalized, LibVst.String128* @string)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEditController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEditController), "getParamStringByValue");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.ParamID, LibVst.ParamValue, LibVst.String128*, int>)Vtbl[10])(__self__, id, valueNormalized, @string);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.ParamID, LibVst.ParamValue, LibVst.String128*, int>)Vtbl[10])((LibVst.IEditController*)Unsafe.AsPointer(ref this), id, valueNormalized, @string);
            }
        }
        
        /// <summary>
        /// Gets for a given paramID and string its normalized value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getParamValueByString(LibVst.ParamID id, char* @string, LibVst.ParamValue* valueNormalized)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEditController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEditController), "getParamValueByString");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.ParamID, char*, LibVst.ParamValue*, int>)Vtbl[11])(__self__, id, @string, valueNormalized);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.ParamID, char*, LibVst.ParamValue*, int>)Vtbl[11])((LibVst.IEditController*)Unsafe.AsPointer(ref this), id, @string, valueNormalized);
            }
        }
        
        /// <summary>
        /// Returns for a given paramID and a normalized value its plain representation
        /// (for example -6 for -6dB - see @ref vst3AutomationIntro).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double normalizedParamToPlain(LibVst.ParamID id, LibVst.ParamValue valueNormalized)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEditController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEditController), "normalizedParamToPlain");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.ParamID, LibVst.ParamValue, double>)Vtbl[12])(__self__, id, valueNormalized);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.ParamID, LibVst.ParamValue, double>)Vtbl[12])((LibVst.IEditController*)Unsafe.AsPointer(ref this), id, valueNormalized);
            }
        }
        
        /// <summary>
        /// Returns for a given paramID and a plain value its normalized value. (see @ref vst3AutomationIntro)
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double plainParamToNormalized(LibVst.ParamID id, LibVst.ParamValue plainValue)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEditController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEditController), "plainParamToNormalized");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.ParamID, LibVst.ParamValue, double>)Vtbl[13])(__self__, id, plainValue);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.ParamID, LibVst.ParamValue, double>)Vtbl[13])((LibVst.IEditController*)Unsafe.AsPointer(ref this), id, plainValue);
            }
        }
        
        /// <summary>
        /// Returns the normalized value of the parameter associated to the paramID.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double getParamNormalized(LibVst.ParamID id)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEditController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEditController), "getParamNormalized");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.ParamID, double>)Vtbl[14])(__self__, id);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.ParamID, double>)Vtbl[14])((LibVst.IEditController*)Unsafe.AsPointer(ref this), id);
            }
        }
        
        /// <summary>
        /// Sets the normalized value to the parameter associated to the paramID. The controller must never
        /// pass this value-change back to the host via the IComponentHandler. It should update the according
        /// GUI element(s) only!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setParamNormalized(LibVst.ParamID id, LibVst.ParamValue value)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEditController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEditController), "setParamNormalized");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.ParamID, LibVst.ParamValue, int>)Vtbl[15])(__self__, id, value);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.ParamID, LibVst.ParamValue, int>)Vtbl[15])((LibVst.IEditController*)Unsafe.AsPointer(ref this), id, value);
            }
        }
        
        /// <summary>
        /// handler ----------------------------
        /// Gets from host a handler which allows the Plugin-in to communicate with the host.
        /// Note: This is mandatory if the host is using the IEditController!
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setComponentHandler(LibVst.IComponentHandler* handler)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEditController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEditController), "setComponentHandler");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.IComponentHandler*, int>)Vtbl[16])(__self__, handler);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.IComponentHandler*, int>)Vtbl[16])((LibVst.IEditController*)Unsafe.AsPointer(ref this), handler);
            }
        }
        
        /// <summary>
        /// view -------------------------------
        /// Creates the editor view of the plug-in, currently only "editor" is supported, see @ref ViewType. The life time of the editor view will never exceed the life time of this controller instance.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IPlugView* createView(LibVst.FIDString name)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEditController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEditController), "createView");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.FIDString, LibVst.IPlugView*>)Vtbl[17])(__self__, name);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEditController*, LibVst.FIDString, LibVst.IPlugView*>)Vtbl[17])((LibVst.IEditController*)Unsafe.AsPointer(ref this), name);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Receives the component state.
        /// </summary>
        private static partial ComResult setComponentState_ToManaged(IEditController* self, LibVst.IBStream* state);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setComponentState_Wrapper(IEditController* self, LibVst.IBStream* state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEditController), "setComponentState");
                try
                {
                    return setComponentState_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setComponentState_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Sets the controller state.
        /// </summary>
        private static partial ComResult setState_ToManaged(IEditController* self, LibVst.IBStream* state);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setState_Wrapper(IEditController* self, LibVst.IBStream* state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEditController), "setState");
                try
                {
                    return setState_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setState_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets the controller state.
        /// </summary>
        private static partial ComResult getState_ToManaged(IEditController* self, LibVst.IBStream* state);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getState_Wrapper(IEditController* self, LibVst.IBStream* state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEditController), "getState");
                try
                {
                    return getState_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getState_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// parameters -------------------------
        /// Returns the number of parameters exported.
        /// </summary>
        private static partial int getParameterCount_ToManaged(IEditController* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getParameterCount_Wrapper(IEditController* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEditController), "getParameterCount");
                try
                {
                    return getParameterCount_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getParameterCount_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Gets for a given index the parameter information.
        /// </summary>
        private static partial ComResult getParameterInfo_ToManaged(IEditController* self, int paramIndex, LibVst.ParameterInfo* info);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getParameterInfo_Wrapper(IEditController* self, int paramIndex, LibVst.ParameterInfo* info)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEditController), "getParameterInfo");
                try
                {
                    return getParameterInfo_ToManaged(self, paramIndex, info);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getParameterInfo_ToManaged(self, paramIndex, info);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets for a given paramID and normalized value its associated string representation.
        /// </summary>
        private static partial ComResult getParamStringByValue_ToManaged(IEditController* self, LibVst.ParamID id, LibVst.ParamValue valueNormalized, LibVst.String128* @string);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getParamStringByValue_Wrapper(IEditController* self, uint id, double valueNormalized, LibVst.String128* @string)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEditController), "getParamStringByValue");
                try
                {
                    return getParamStringByValue_ToManaged(self, id, valueNormalized, @string);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getParamStringByValue_ToManaged(self, id, valueNormalized, @string);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets for a given paramID and string its normalized value.
        /// </summary>
        private static partial ComResult getParamValueByString_ToManaged(IEditController* self, LibVst.ParamID id, char* @string, LibVst.ParamValue* valueNormalized);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getParamValueByString_Wrapper(IEditController* self, uint id, char* @string, LibVst.ParamValue* valueNormalized)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEditController), "getParamValueByString");
                try
                {
                    return getParamValueByString_ToManaged(self, id, @string, valueNormalized);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getParamValueByString_ToManaged(self, id, @string, valueNormalized);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Returns for a given paramID and a normalized value its plain representation
        /// (for example -6 for -6dB - see @ref vst3AutomationIntro).
        /// </summary>
        private static partial LibVst.ParamValue normalizedParamToPlain_ToManaged(IEditController* self, LibVst.ParamID id, LibVst.ParamValue valueNormalized);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static double normalizedParamToPlain_Wrapper(IEditController* self, uint id, double valueNormalized)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEditController), "normalizedParamToPlain");
                try
                {
                    return normalizedParamToPlain_ToManaged(self, id, valueNormalized);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return normalizedParamToPlain_ToManaged(self, id, valueNormalized);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Returns for a given paramID and a plain value its normalized value. (see @ref vst3AutomationIntro)
        /// </summary>
        private static partial LibVst.ParamValue plainParamToNormalized_ToManaged(IEditController* self, LibVst.ParamID id, LibVst.ParamValue plainValue);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static double plainParamToNormalized_Wrapper(IEditController* self, uint id, double plainValue)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEditController), "plainParamToNormalized");
                try
                {
                    return plainParamToNormalized_ToManaged(self, id, plainValue);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return plainParamToNormalized_ToManaged(self, id, plainValue);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Returns the normalized value of the parameter associated to the paramID.
        /// </summary>
        private static partial LibVst.ParamValue getParamNormalized_ToManaged(IEditController* self, LibVst.ParamID id);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static double getParamNormalized_Wrapper(IEditController* self, uint id)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEditController), "getParamNormalized");
                try
                {
                    return getParamNormalized_ToManaged(self, id);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getParamNormalized_ToManaged(self, id);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Sets the normalized value to the parameter associated to the paramID. The controller must never
        /// pass this value-change back to the host via the IComponentHandler. It should update the according
        /// GUI element(s) only!
        /// </summary>
        private static partial ComResult setParamNormalized_ToManaged(IEditController* self, LibVst.ParamID id, LibVst.ParamValue value);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setParamNormalized_Wrapper(IEditController* self, uint id, double value)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEditController), "setParamNormalized");
                try
                {
                    return setParamNormalized_ToManaged(self, id, value);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setParamNormalized_ToManaged(self, id, value);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// handler ----------------------------
        /// Gets from host a handler which allows the Plugin-in to communicate with the host.
        /// Note: This is mandatory if the host is using the IEditController!
        /// </summary>
        private static partial ComResult setComponentHandler_ToManaged(IEditController* self, LibVst.IComponentHandler* handler);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setComponentHandler_Wrapper(IEditController* self, LibVst.IComponentHandler* handler)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEditController), "setComponentHandler");
                try
                {
                    return setComponentHandler_ToManaged(self, handler);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setComponentHandler_ToManaged(self, handler);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// view -------------------------------
        /// Creates the editor view of the plug-in, currently only "editor" is supported, see @ref ViewType. The life time of the editor view will never exceed the life time of this controller instance.
        /// </summary>
        private static partial LibVst.IPlugView* createView_ToManaged(IEditController* self, LibVst.FIDString name);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static LibVst.IPlugView* createView_Wrapper(IEditController* self, byte* name)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEditController), "createView");
                try
                {
                    return createView_ToManaged(self, name);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return createView_ToManaged(self, name);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IEditController, 0xDCD7BBE3, 0x7742448D, 0xA874AACC, 0x979C759E)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xe3, 0xbb, 0xd7, 0xdc, 0x42, 0x77, 0x8d, 0x44, 0xa8, 0x74, 0xaa, 0xcc, 0x97, 0x9c, 0x75, 0x9e })
                        : new ReadOnlySpan<byte>(new byte[] { 0xdc, 0xd7, 0xbb, 0xe3, 0x77, 0x42, 0x44, 0x8d, 0xa8, 0x74, 0xaa, 0xcc, 0x97, 0x9c, 0x75, 0x9e })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Controller Parameter Info.
    /// A parameter info describes a parameter of the controller.
    /// The id must always be the same for a parameter as this uniquely identifies the parameter.
    /// </summary>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct ParameterInfo
    {
        /// <summary>
        /// unique identifier of this parameter (named tag too)
        /// </summary>
        public LibVst.ParamID id;
        
        /// <summary>
        /// parameter title (e.g. "Volume")
        /// </summary>
        public LibVst.String128 title;
        
        /// <summary>
        /// parameter shortTitle (e.g. "Vol")
        /// </summary>
        public LibVst.String128 shortTitle;
        
        /// <summary>
        /// parameter unit (e.g. "dB")
        /// </summary>
        public LibVst.String128 units;
        
        /// <summary>
        /// number of discrete steps (0: continuous, 1: toggle, discrete value otherwise 
        /// (corresponding to max - min, for example: 127 for a min = 0 and a max = 127) - see @ref vst3ParameterIntro)
        /// </summary>
        public int stepCount;
        
        /// <summary>
        /// default normalized value [0,1] (in case of discrete value: defaultNormalizedValue = defDiscreteValue / stepCount)
        /// </summary>
        public LibVst.ParamValue defaultNormalizedValue;
        
        /// <summary>
        /// id of unit this parameter belongs to (see @ref vst3Units)
        /// </summary>
        public LibVst.UnitID unitId;
        
        /// <summary>
        /// ParameterFlags (see below)
        /// </summary>
        public int flags;
        
        public enum ParameterFlags
        {
            /// <summary>
            /// no flags wanted
            /// </summary>
            kNoFlags = 0,
            
            /// <summary>
            /// parameter can be automated
            /// </summary>
            kCanAutomate = 1 << 0,
            
            /// <summary>
            /// parameter cannot be changed from outside the plug-in (implies that kCanAutomate is NOT set)
            /// </summary>
            kIsReadOnly = 1 << 1,
            
            /// <summary>
            /// attempts to set the parameter value out of the limits will result in a wrap around [SDK 3.0.2]
            /// </summary>
            kIsWrapAround = 1 << 2,
            
            /// <summary>
            /// parameter should be displayed as list in generic editor or automation editing [SDK 3.1.0]
            /// </summary>
            kIsList = 1 << 3,
            
            /// <summary>
            /// parameter should be NOT displayed and cannot be changed from outside the plug-in 
            /// (implies that kCanAutomate is NOT set and kIsReadOnly is set) [SDK 3.7.0]
            /// </summary>
            kIsHidden = 1 << 4,
            
            /// <summary>
            /// parameter is a program change (unitId gives info about associated unit 
            /// - see @ref vst3ProgramLists)
            /// </summary>
            kIsProgramChange = 1 << 15,
            
            /// <summary>
            /// special bypass parameter (only one allowed): plug-in can handle bypass
            /// (highly recommended to export a bypass parameter for effect plug-in)
            /// </summary>
            kIsBypass = 1 << 16,
        }
    }
    
    public partial record struct UnitID(int Value)
    {
        public static implicit operator int(UnitID value) => value.Value;
        
        public static implicit operator UnitID(int value) => new(value);
    }
    
    /// <summary>
    /// Edit controller component interface extension: Vst::IEditController2
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst310- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.1.0]
    /// - [optional]Extension to allow the host to inform the plug-in about the host Knob Mode,
    /// and to open the plug-in about box or help documentation.
    /// </remarks>
    /// <seealso cref="EditControllerIEditController,"/>
    public unsafe partial struct IEditController2 : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 6;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IEditController2*, int, int>)&setKnobMode_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IEditController2*, byte, int>)&openHelp_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IEditController2*, byte, int>)&openAboutBox_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IEditController2, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IEditController2, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IEditController2, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Host could set the Knob Mode for the plug-in. Return kResultFalse means not supported mode.
        /// </summary>
        /// <seealso cref="KnobModes. "/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setKnobMode(LibVst.KnobMode mode)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEditController2*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEditController2), "setKnobMode");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEditController2*, LibVst.KnobMode, int>)Vtbl[3])(__self__, mode);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEditController2*, LibVst.KnobMode, int>)Vtbl[3])((LibVst.IEditController2*)Unsafe.AsPointer(ref this), mode);
            }
        }
        
        /// <summary>
        /// Host could ask to open the plug-in help (could be: opening a PDF document or link to a web page).
        /// The host could call it with onlyCheck set to true for testing support of open Help. 
        /// Return kResultFalse means not supported function.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult openHelp(byte onlyCheck)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEditController2*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEditController2), "openHelp");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEditController2*, byte, int>)Vtbl[4])(__self__, onlyCheck);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEditController2*, byte, int>)Vtbl[4])((LibVst.IEditController2*)Unsafe.AsPointer(ref this), onlyCheck);
            }
        }
        
        /// <summary>
        /// Host could ask to open the plug-in about box.
        /// The host could call it with onlyCheck set to true for testing support of open AboutBox. 
        /// Return kResultFalse means not supported function.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult openAboutBox(byte onlyCheck)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEditController2*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEditController2), "openAboutBox");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEditController2*, byte, int>)Vtbl[5])(__self__, onlyCheck);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEditController2*, byte, int>)Vtbl[5])((LibVst.IEditController2*)Unsafe.AsPointer(ref this), onlyCheck);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Host could set the Knob Mode for the plug-in. Return kResultFalse means not supported mode.
        /// </summary>
        /// <seealso cref="KnobModes. "/>
        private static partial ComResult setKnobMode_ToManaged(IEditController2* self, LibVst.KnobMode mode);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setKnobMode_Wrapper(IEditController2* self, int mode)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEditController2), "setKnobMode");
                try
                {
                    return setKnobMode_ToManaged(self, mode);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setKnobMode_ToManaged(self, mode);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Host could ask to open the plug-in help (could be: opening a PDF document or link to a web page).
        /// The host could call it with onlyCheck set to true for testing support of open Help. 
        /// Return kResultFalse means not supported function.
        /// </summary>
        private static partial ComResult openHelp_ToManaged(IEditController2* self, byte onlyCheck);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int openHelp_Wrapper(IEditController2* self, byte onlyCheck)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEditController2), "openHelp");
                try
                {
                    return openHelp_ToManaged(self, onlyCheck);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return openHelp_ToManaged(self, onlyCheck);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Host could ask to open the plug-in about box.
        /// The host could call it with onlyCheck set to true for testing support of open AboutBox. 
        /// Return kResultFalse means not supported function.
        /// </summary>
        private static partial ComResult openAboutBox_ToManaged(IEditController2* self, byte onlyCheck);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int openAboutBox_Wrapper(IEditController2* self, byte onlyCheck)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEditController2), "openAboutBox");
                try
                {
                    return openAboutBox_ToManaged(self, onlyCheck);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return openAboutBox_ToManaged(self, onlyCheck);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IEditController2, 0x7F4EFE59, 0xF3204967, 0xAC27A3AE, 0xAFB63038)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x59, 0xfe, 0x4e, 0x7f, 0x20, 0xf3, 0x67, 0x49, 0xac, 0x27, 0xa3, 0xae, 0xaf, 0xb6, 0x30, 0x38 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x7f, 0x4e, 0xfe, 0x59, 0xf3, 0x20, 0x49, 0x67, 0xac, 0x27, 0xa3, 0xae, 0xaf, 0xb6, 0x30, 0x38 })
                    )));
            }
        }
    }
    
    public partial record struct KnobMode(int Value)
    {
        public static implicit operator int(KnobMode value) => value.Value;
        
        public static implicit operator KnobMode(int value) => new(value);
    }
    
    /// <summary>
    /// MIDI Mapping interface: Vst::IMidiMapping
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst301- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.0.1]
    /// - [optional]MIDI controllers are not transmitted directly to a VST component. MIDI as hardware protocol has
    /// restrictions that can be avoided in software. Controller data in particular come along with unclear
    /// and often ignored semantics. On top of this they can interfere with regular parameter automation and
    /// the host is unaware of what happens in the plug-in when passing MIDI controllers directly.So any functionality that is to be controlled by MIDI controllers must be exported as regular parameter.
    /// The host will transform incoming MIDI controller data using this interface and transmit them as regular
    /// parameter change. This allows the host to automate them in the same way as other parameters.
    /// CtrlNumber can be a typical MIDI controller value extended to some others values like pitchbend or
    /// aftertouch (see @ref ControllerNumbers).If the mapping has changed, the plug-in must call IComponentHandler::restartComponent (kMidiCCAssignmentChanged)
    /// to inform the host about this change. IMidiMappingExample Example@code {.cpp}
    /// //--------------------------------------
    /// // in myeditcontroller.h
    /// class MyEditController: public EditControllerEx1, public IMidiMapping
    /// {
    /// 	//...
    /// 	//---IMidiMapping---------------------------
    /// 	tresult PLUGIN_API getMidiControllerAssignment (int32 busIndex, int16 channel, CtrlNumber midiControllerNumber, ParamID&amp; id) SMTG_OVERRIDE;
    /// 	//---Interface---------
    /// 	OBJ_METHODS (MyEditController, EditControllerEx1)
    /// 	DEFINE_INTERFACES
    /// 		DEF_INTERFACE (IMidiMapping)
    /// 	END_DEFINE_INTERFACES (MyEditController)
    /// 	REFCOUNT_METHODS (MyEditController)
    /// };
    /// 
    /// //--------------------------------------
    /// // in myeditcontroller.cpp
    /// tresult PLUGIN_API MyEditController::getMidiControllerAssignment (int32 busIndex, int16 midiChannel, CtrlNumber midiControllerNumber, ParamID&amp; tag)
    /// {
    /// 	// for my first Event bus and for MIDI channel 0 and for MIDI CC Volume only
    /// 	if (busIndex == 0 &amp;&amp; midiChannel == 0 &amp;&amp; midiControllerNumber == kCtrlVolume)
    /// 	{
    /// 		tag = kGainId;
    /// 		return kResultTrue;
    /// 	}
    /// 	return kResultFalse;
    /// }
    /// @endcode
    /// </remarks>
    public unsafe partial struct IMidiMapping : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IMidiMapping*, int, short, short, LibVst.ParamID*, int>)&getMidiControllerAssignment_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IMidiMapping, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IMidiMapping, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IMidiMapping, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Gets an (preferred) associated ParamID for a given Input Event Bus index, channel and MIDI Controller.
        /// </summary>
        /// <param name="busIndex">- index of Input Event Bus</param>
        /// <param name="channel">- channel of the bus</param>
        /// <param name="midiControllerNumber">- see @ref ControllerNumbers for expected values (could be bigger than 127)</param>
        /// <param name="id">- return the associated ParamID to the given midiControllerNumber</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getMidiControllerAssignment(int busIndex, short channel, LibVst.CtrlNumber midiControllerNumber, LibVst.ParamID* id)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IMidiMapping*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IMidiMapping), "getMidiControllerAssignment");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IMidiMapping*, int, short, LibVst.CtrlNumber, LibVst.ParamID*, int>)Vtbl[3])(__self__, busIndex, channel, midiControllerNumber, id);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IMidiMapping*, int, short, LibVst.CtrlNumber, LibVst.ParamID*, int>)Vtbl[3])((LibVst.IMidiMapping*)Unsafe.AsPointer(ref this), busIndex, channel, midiControllerNumber, id);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Gets an (preferred) associated ParamID for a given Input Event Bus index, channel and MIDI Controller.
        /// </summary>
        /// <param name="busIndex">- index of Input Event Bus</param>
        /// <param name="channel">- channel of the bus</param>
        /// <param name="midiControllerNumber">- see @ref ControllerNumbers for expected values (could be bigger than 127)</param>
        /// <param name="id">- return the associated ParamID to the given midiControllerNumber</param>
        private static partial ComResult getMidiControllerAssignment_ToManaged(IMidiMapping* self, int busIndex, short channel, LibVst.CtrlNumber midiControllerNumber, LibVst.ParamID* id);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getMidiControllerAssignment_Wrapper(IMidiMapping* self, int busIndex, short channel, short midiControllerNumber, LibVst.ParamID* id)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IMidiMapping), "getMidiControllerAssignment");
                try
                {
                    return getMidiControllerAssignment_ToManaged(self, busIndex, channel, midiControllerNumber, id);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getMidiControllerAssignment_ToManaged(self, busIndex, channel, midiControllerNumber, id);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IMidiMapping, 0xDF0FF9F7, 0x49B74669, 0xB63AB732, 0x7ADBF5E5)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xf7, 0xf9, 0x0f, 0xdf, 0xb7, 0x49, 0x69, 0x46, 0xb6, 0x3a, 0xb7, 0x32, 0x7a, 0xdb, 0xf5, 0xe5 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xdf, 0x0f, 0xf9, 0xf7, 0x49, 0xb7, 0x46, 0x69, 0xb6, 0x3a, 0xb7, 0x32, 0x7a, 0xdb, 0xf5, 0xe5 })
                    )));
            }
        }
    }
    
    public partial record struct CtrlNumber(short Value)
    {
        public static implicit operator short(CtrlNumber value) => value.Value;
        
        public static implicit operator CtrlNumber(short value) => new(value);
    }
    
    /// <summary>
    /// Parameter Editing from host: Vst::IEditControllerHostEditing
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst350- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.5.0]
    /// - [optional]If this interface is implemented by the edit controller, and when performing edits from outside
    /// the plug-in (host / remote) of a not automatable and not read-only, and not hidden flagged parameter (kind of helper parameter),
    /// the host will start with a beginEditFromHost before calling setParamNormalized and end with an endEditFromHost.
    /// Here the sequence that the host will call: IEditControllerExample Example@code {.cpp}
    /// //------------------------------------------------------------------------
    /// plugEditController-&gt;beginEditFromHost (id);
    /// plugEditController-&gt;setParamNormalized (id, value);
    /// plugEditController-&gt;setParamNormalized (id, value + 0.1);
    /// // ...
    /// plugEditController-&gt;endEditFromHost (id);
    /// @endcode
    /// </remarks>
    /// <seealso cref="IEditController"/>
    public unsafe partial struct IEditControllerHostEditing : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 5;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IEditControllerHostEditing*, uint, int>)&beginEditFromHost_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IEditControllerHostEditing*, uint, int>)&endEditFromHost_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IEditControllerHostEditing, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IEditControllerHostEditing, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IEditControllerHostEditing, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Called before a setParamNormalized sequence, a endEditFromHost will be call at the end of the editing action.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult beginEditFromHost(LibVst.ParamID paramID)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEditControllerHostEditing*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEditControllerHostEditing), "beginEditFromHost");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEditControllerHostEditing*, LibVst.ParamID, int>)Vtbl[3])(__self__, paramID);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEditControllerHostEditing*, LibVst.ParamID, int>)Vtbl[3])((LibVst.IEditControllerHostEditing*)Unsafe.AsPointer(ref this), paramID);
            }
        }
        
        /// <summary>
        /// Called after a beginEditFromHost and a sequence of setParamNormalized.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult endEditFromHost(LibVst.ParamID paramID)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IEditControllerHostEditing*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IEditControllerHostEditing), "endEditFromHost");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IEditControllerHostEditing*, LibVst.ParamID, int>)Vtbl[4])(__self__, paramID);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IEditControllerHostEditing*, LibVst.ParamID, int>)Vtbl[4])((LibVst.IEditControllerHostEditing*)Unsafe.AsPointer(ref this), paramID);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Called before a setParamNormalized sequence, a endEditFromHost will be call at the end of the editing action.
        /// </summary>
        private static partial ComResult beginEditFromHost_ToManaged(IEditControllerHostEditing* self, LibVst.ParamID paramID);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int beginEditFromHost_Wrapper(IEditControllerHostEditing* self, uint paramID)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEditControllerHostEditing), "beginEditFromHost");
                try
                {
                    return beginEditFromHost_ToManaged(self, paramID);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return beginEditFromHost_ToManaged(self, paramID);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Called after a beginEditFromHost and a sequence of setParamNormalized.
        /// </summary>
        private static partial ComResult endEditFromHost_ToManaged(IEditControllerHostEditing* self, LibVst.ParamID paramID);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int endEditFromHost_Wrapper(IEditControllerHostEditing* self, uint paramID)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IEditControllerHostEditing), "endEditFromHost");
                try
                {
                    return endEditFromHost_ToManaged(self, paramID);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return endEditFromHost_ToManaged(self, paramID);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IEditControllerHostEditing, 0xC1271208, 0x70594098, 0xB9DD34B3, 0x6BB0195E)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x08, 0x12, 0x27, 0xc1, 0x59, 0x70, 0x98, 0x40, 0xb9, 0xdd, 0x34, 0xb3, 0x6b, 0xb0, 0x19, 0x5e })
                        : new ReadOnlySpan<byte>(new byte[] { 0xc1, 0x27, 0x12, 0x08, 0x70, 0x59, 0x40, 0x98, 0xb9, 0xdd, 0x34, 0xb3, 0x6b, 0xb0, 0x19, 0x5e })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Extended plug-in interface IEditController for note expression event support: Vst::INoteExpressionController
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst350- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.5.0]
    /// - [optional]With this plug-in interface, the host can retrieve all necessary note expression information supported by the plug-in.
    /// Note expression information (@ref NoteExpressionTypeInfo) are specific for given channel and event bus.Note that there is only one NoteExpressionTypeID per given channel of an event bus.The method getNoteExpressionStringByValue allows conversion from a normalized value to a string representation
    /// and the getNoteExpressionValueByString method from a string to a normalized value.When the note expression state changes (for example when switching presets) the plug-in needs
    /// to inform the host about it via @ref IComponentHandler::restartComponent (kNoteExpressionChanged).
    /// </remarks>
    public unsafe partial struct INoteExpressionController : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 7;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<INoteExpressionController*, int, short, int>)&getNoteExpressionCount_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<INoteExpressionController*, int, short, int, LibVst.NoteExpressionTypeInfo*, int>)&getNoteExpressionInfo_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<INoteExpressionController*, int, short, uint, double, LibVst.String128*, int>)&getNoteExpressionStringByValue_Wrapper;
            vtbl[6] = (delegate*unmanaged[MemberFunction]<INoteExpressionController*, int, short, uint, char*, LibVst.NoteExpressionValue*, int>)&getNoteExpressionValueByString_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<INoteExpressionController, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<INoteExpressionController, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<INoteExpressionController, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Returns number of supported note change types for event bus index and channel.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getNoteExpressionCount(int busIndex, short channel)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.INoteExpressionController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(INoteExpressionController), "getNoteExpressionCount");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.INoteExpressionController*, int, short, int>)Vtbl[3])(__self__, busIndex, channel);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.INoteExpressionController*, int, short, int>)Vtbl[3])((LibVst.INoteExpressionController*)Unsafe.AsPointer(ref this), busIndex, channel);
            }
        }
        
        /// <summary>
        /// Returns note change type info.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getNoteExpressionInfo(int busIndex, short channel, int noteExpressionIndex, LibVst.NoteExpressionTypeInfo* info)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.INoteExpressionController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(INoteExpressionController), "getNoteExpressionInfo");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.INoteExpressionController*, int, short, int, LibVst.NoteExpressionTypeInfo*, int>)Vtbl[4])(__self__, busIndex, channel, noteExpressionIndex, info);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.INoteExpressionController*, int, short, int, LibVst.NoteExpressionTypeInfo*, int>)Vtbl[4])((LibVst.INoteExpressionController*)Unsafe.AsPointer(ref this), busIndex, channel, noteExpressionIndex, info);
            }
        }
        
        /// <summary>
        /// Gets a user readable representation of the normalized note change value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getNoteExpressionStringByValue(int busIndex, short channel, LibVst.NoteExpressionTypeID id, LibVst.NoteExpressionValue valueNormalized, LibVst.String128* @string)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.INoteExpressionController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(INoteExpressionController), "getNoteExpressionStringByValue");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.INoteExpressionController*, int, short, LibVst.NoteExpressionTypeID, LibVst.NoteExpressionValue, LibVst.String128*, int>)Vtbl[5])(__self__, busIndex, channel, id, valueNormalized, @string);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.INoteExpressionController*, int, short, LibVst.NoteExpressionTypeID, LibVst.NoteExpressionValue, LibVst.String128*, int>)Vtbl[5])((LibVst.INoteExpressionController*)Unsafe.AsPointer(ref this), busIndex, channel, id, valueNormalized, @string);
            }
        }
        
        /// <summary>
        /// Converts the user readable representation to the normalized note change value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getNoteExpressionValueByString(int busIndex, short channel, LibVst.NoteExpressionTypeID id, char* @string, LibVst.NoteExpressionValue* valueNormalized)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.INoteExpressionController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(INoteExpressionController), "getNoteExpressionValueByString");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.INoteExpressionController*, int, short, LibVst.NoteExpressionTypeID, char*, LibVst.NoteExpressionValue*, int>)Vtbl[6])(__self__, busIndex, channel, id, @string, valueNormalized);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.INoteExpressionController*, int, short, LibVst.NoteExpressionTypeID, char*, LibVst.NoteExpressionValue*, int>)Vtbl[6])((LibVst.INoteExpressionController*)Unsafe.AsPointer(ref this), busIndex, channel, id, @string, valueNormalized);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns number of supported note change types for event bus index and channel.
        /// </summary>
        private static partial int getNoteExpressionCount_ToManaged(INoteExpressionController* self, int busIndex, short channel);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getNoteExpressionCount_Wrapper(INoteExpressionController* self, int busIndex, short channel)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(INoteExpressionController), "getNoteExpressionCount");
                try
                {
                    return getNoteExpressionCount_ToManaged(self, busIndex, channel);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getNoteExpressionCount_ToManaged(self, busIndex, channel);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Returns note change type info.
        /// </summary>
        private static partial ComResult getNoteExpressionInfo_ToManaged(INoteExpressionController* self, int busIndex, short channel, int noteExpressionIndex, LibVst.NoteExpressionTypeInfo* info);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getNoteExpressionInfo_Wrapper(INoteExpressionController* self, int busIndex, short channel, int noteExpressionIndex, LibVst.NoteExpressionTypeInfo* info)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(INoteExpressionController), "getNoteExpressionInfo");
                try
                {
                    return getNoteExpressionInfo_ToManaged(self, busIndex, channel, noteExpressionIndex, info);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getNoteExpressionInfo_ToManaged(self, busIndex, channel, noteExpressionIndex, info);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets a user readable representation of the normalized note change value.
        /// </summary>
        private static partial ComResult getNoteExpressionStringByValue_ToManaged(INoteExpressionController* self, int busIndex, short channel, LibVst.NoteExpressionTypeID id, LibVst.NoteExpressionValue valueNormalized, LibVst.String128* @string);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getNoteExpressionStringByValue_Wrapper(INoteExpressionController* self, int busIndex, short channel, uint id, double valueNormalized, LibVst.String128* @string)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(INoteExpressionController), "getNoteExpressionStringByValue");
                try
                {
                    return getNoteExpressionStringByValue_ToManaged(self, busIndex, channel, id, valueNormalized, @string);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getNoteExpressionStringByValue_ToManaged(self, busIndex, channel, id, valueNormalized, @string);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Converts the user readable representation to the normalized note change value.
        /// </summary>
        private static partial ComResult getNoteExpressionValueByString_ToManaged(INoteExpressionController* self, int busIndex, short channel, LibVst.NoteExpressionTypeID id, char* @string, LibVst.NoteExpressionValue* valueNormalized);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getNoteExpressionValueByString_Wrapper(INoteExpressionController* self, int busIndex, short channel, uint id, char* @string, LibVst.NoteExpressionValue* valueNormalized)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(INoteExpressionController), "getNoteExpressionValueByString");
                try
                {
                    return getNoteExpressionValueByString_ToManaged(self, busIndex, channel, id, @string, valueNormalized);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getNoteExpressionValueByString_ToManaged(self, busIndex, channel, id, @string, valueNormalized);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (INoteExpressionController, 0xB7F8F859, 0x41234872, 0x91169581, 0x4F3721A3)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x59, 0xf8, 0xf8, 0xb7, 0x23, 0x41, 0x72, 0x48, 0x91, 0x16, 0x95, 0x81, 0x4f, 0x37, 0x21, 0xa3 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xb7, 0xf8, 0xf8, 0x59, 0x41, 0x23, 0x48, 0x72, 0x91, 0x16, 0x95, 0x81, 0x4f, 0x37, 0x21, 0xa3 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// NoteExpressionTypeInfo is the structure describing a note expression supported by the plug-in.
    /// This structure is used by the method @ref INoteExpressionController::getNoteExpressionInfo.
    /// </summary>
    /// <seealso cref="INoteExpressionController"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct NoteExpressionTypeInfo
    {
        /// <summary>
        /// unique identifier of this note Expression type
        /// </summary>
        public LibVst.NoteExpressionTypeID typeId;
        
        /// <summary>
        /// note Expression type title (e.g. "Volume")
        /// </summary>
        public LibVst.String128 title;
        
        /// <summary>
        /// note Expression type short title (e.g. "Vol")
        /// </summary>
        public LibVst.String128 shortTitle;
        
        /// <summary>
        /// note Expression type unit (e.g. "dB")
        /// </summary>
        public LibVst.String128 units;
        
        /// <summary>
        /// id of unit this NoteExpression belongs to (see @ref vst3Units), in order to sort the note expression, it is possible to use unitId like for parameters. -1 means no unit used.
        /// </summary>
        public int unitId;
        
        /// <summary>
        /// value description see @ref NoteExpressionValueDescription
        /// </summary>
        public LibVst.NoteExpressionValueDescription valueDesc;
        
        /// <summary>
        /// optional associated parameter ID (for mapping from note expression to global (using the parameter automation for example) and back). Only used when kAssociatedParameterIDValid is set in flags.
        /// </summary>
        public LibVst.ParamID associatedParameterId;
        
        /// <summary>
        /// NoteExpressionTypeFlags (see below)
        /// </summary>
        public int flags;
        
        public enum NoteExpressionTypeFlags
        {
            /// <summary>
            /// event is bipolar (centered), otherwise unipolar
            /// </summary>
            kIsBipolar = 1 << 0,
            
            /// <summary>
            /// event occurs only one time for its associated note (at begin of the noteOn)
            /// </summary>
            kIsOneShot = 1 << 1,
            
            /// <summary>
            /// This note expression will apply an absolute change to the sound (not relative (offset))
            /// </summary>
            kIsAbsolute = 1 << 2,
            
            /// <summary>
            /// indicates that the associatedParameterID is valid and could be used
            /// </summary>
            kAssociatedParameterIDValid = 1 << 3,
        }
    }
    
    public partial record struct NoteExpressionTypeID(uint Value)
    {
        public static implicit operator uint(NoteExpressionTypeID value) => value.Value;
        
        public static implicit operator NoteExpressionTypeID(uint value) => new(value);
    }
    
    /// <summary>
    /// Description of a Note Expression Type
    /// This structure is part of the NoteExpressionTypeInfo structure, it describes for given NoteExpressionTypeID its default value
    /// (for example 0.5 for a kTuningTypeID (kIsBipolar: centered)), its minimum and maximum (for predefined NoteExpressionTypeID the full range is predefined too)
    /// and a stepCount when the given NoteExpressionTypeID is limited to discrete values (like on/off state).
    /// </summary>
    /// <seealso cref="NoteExpressionTypeInfo"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct NoteExpressionValueDescription
    {
        /// <summary>
        /// default normalized value [0,1]
        /// </summary>
        public LibVst.NoteExpressionValue defaultValue;
        
        /// <summary>
        /// minimum normalized value [0,1]
        /// </summary>
        public LibVst.NoteExpressionValue minimum;
        
        /// <summary>
        /// maximum normalized value [0,1]
        /// </summary>
        public LibVst.NoteExpressionValue maximum;
        
        /// <summary>
        /// number of discrete steps (0: continuous, 1: toggle, discrete value otherwise - see @ref vst3ParameterIntro)
        /// </summary>
        public int stepCount;
    }
    
    public partial record struct NoteExpressionValue(double Value)
    {
        public static implicit operator double(NoteExpressionValue value) => value.Value;
        
        public static implicit operator NoteExpressionValue(double value) => new(value);
    }
    
    /// <summary>
    /// Extended plug-in interface IEditController for key switches support: Vst::IKeyswitchController
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst350- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.5.0]
    /// - [optional]When a (instrument) plug-in supports such interface, the host could get from the plug-in the current set
    /// of used key switches (megatrig/articulation) for a given channel of a event bus and then automatically use them (like in Cubase 6) to
    /// create VST Expression Map (allowing to associated symbol to a given articulation / key switch).
    /// </remarks>
    public unsafe partial struct IKeyswitchController : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 5;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IKeyswitchController*, int, short, int>)&getKeyswitchCount_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IKeyswitchController*, int, short, int, LibVst.KeyswitchInfo*, int>)&getKeyswitchInfo_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IKeyswitchController, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IKeyswitchController, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IKeyswitchController, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Returns number of supported key switches for event bus index and channel.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getKeyswitchCount(int busIndex, short channel)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IKeyswitchController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IKeyswitchController), "getKeyswitchCount");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IKeyswitchController*, int, short, int>)Vtbl[3])(__self__, busIndex, channel);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IKeyswitchController*, int, short, int>)Vtbl[3])((LibVst.IKeyswitchController*)Unsafe.AsPointer(ref this), busIndex, channel);
            }
        }
        
        /// <summary>
        /// Returns key switch info.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getKeyswitchInfo(int busIndex, short channel, int keySwitchIndex, LibVst.KeyswitchInfo* info)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IKeyswitchController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IKeyswitchController), "getKeyswitchInfo");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IKeyswitchController*, int, short, int, LibVst.KeyswitchInfo*, int>)Vtbl[4])(__self__, busIndex, channel, keySwitchIndex, info);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IKeyswitchController*, int, short, int, LibVst.KeyswitchInfo*, int>)Vtbl[4])((LibVst.IKeyswitchController*)Unsafe.AsPointer(ref this), busIndex, channel, keySwitchIndex, info);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns number of supported key switches for event bus index and channel.
        /// </summary>
        private static partial int getKeyswitchCount_ToManaged(IKeyswitchController* self, int busIndex, short channel);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getKeyswitchCount_Wrapper(IKeyswitchController* self, int busIndex, short channel)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IKeyswitchController), "getKeyswitchCount");
                try
                {
                    return getKeyswitchCount_ToManaged(self, busIndex, channel);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getKeyswitchCount_ToManaged(self, busIndex, channel);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Returns key switch info.
        /// </summary>
        private static partial ComResult getKeyswitchInfo_ToManaged(IKeyswitchController* self, int busIndex, short channel, int keySwitchIndex, LibVst.KeyswitchInfo* info);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getKeyswitchInfo_Wrapper(IKeyswitchController* self, int busIndex, short channel, int keySwitchIndex, LibVst.KeyswitchInfo* info)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IKeyswitchController), "getKeyswitchInfo");
                try
                {
                    return getKeyswitchInfo_ToManaged(self, busIndex, channel, keySwitchIndex, info);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getKeyswitchInfo_ToManaged(self, busIndex, channel, keySwitchIndex, info);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IKeyswitchController, 0x1F2F76D3, 0xBFFB4B96, 0xB99527A5, 0x5EBCCEF4)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xd3, 0x76, 0x2f, 0x1f, 0xfb, 0xbf, 0x96, 0x4b, 0xb9, 0x95, 0x27, 0xa5, 0x5e, 0xbc, 0xce, 0xf4 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x1f, 0x2f, 0x76, 0xd3, 0xbf, 0xfb, 0x4b, 0x96, 0xb9, 0x95, 0x27, 0xa5, 0x5e, 0xbc, 0xce, 0xf4 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// KeyswitchInfo is the structure describing a key switch
    /// This structure is used by the method @ref IKeyswitchController::getKeyswitchInfo.
    /// </summary>
    /// <seealso cref="IKeyswitchController"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct KeyswitchInfo
    {
        /// <summary>
        /// see KeyswitchTypeID
        /// </summary>
        public LibVst.KeyswitchTypeID typeId;
        
        /// <summary>
        /// name of key switch (e.g. "Accentuation")
        /// </summary>
        public LibVst.String128 title;
        
        /// <summary>
        /// short title (e.g. "Acc")
        /// </summary>
        public LibVst.String128 shortTitle;
        
        /// <summary>
        /// associated main key switch min (value between [0, 127])
        /// </summary>
        public int keyswitchMin;
        
        /// <summary>
        /// associated main key switch max (value between [0, 127])
        /// </summary>
        public int keyswitchMax;
        
        public int keyRemapped;
        
        /// <summary>
        /// id of unit this key switch belongs to (see @ref vst3Units), -1 means no unit used.
        /// </summary>
        public int unitId;
        
        /// <summary>
        /// not yet used (set to 0)
        /// </summary>
        public int flags;
    }
    
    public partial record struct KeyswitchTypeID(uint Value)
    {
        public static implicit operator uint(KeyswitchTypeID value) => value.Value;
        
        public static implicit operator KeyswitchTypeID(uint value) => new(value);
    }
    
    /// <summary>
    /// Private plug-in message: Vst::IMessage
    /// </summary>
    /// <remarks>
    ///  vstIHost vst300- [host imp]
    /// - [create via IHostApplication::createInstance]
    /// - [released: 3.0.0]
    /// - [mandatory]Messages are sent from a VST controller component to a VST editor component and vice versa.
    /// </remarks>
    /// <seealso cref="vst3CommunicationIAttributeList, IConnectionPoint, "/>
    public unsafe partial struct IMessage : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 6;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IMessage*, byte*>)&getMessageID_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IMessage*, byte*, void>)&setMessageID_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IMessage*, LibVst.IAttributeList*>)&getAttributes_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IMessage, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IMessage, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IMessage, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Returns the message ID (for example "TextMessage").
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public byte* getMessageID()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IMessage*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IMessage), "getMessageID");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IMessage*, byte*>)Vtbl[3])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IMessage*, byte*>)Vtbl[3])((LibVst.IMessage*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Sets a message ID (for example "TextMessage").
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void setMessageID(LibVst.FIDString id)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IMessage*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IMessage), "setMessageID");
                ((delegate*unmanaged[MemberFunction]<LibVst.IMessage*, LibVst.FIDString, void>)Vtbl[4])(__self__, id);
                __evt__.Dispose();
            }
            else
            {
                ((delegate*unmanaged[MemberFunction]<LibVst.IMessage*, LibVst.FIDString, void>)Vtbl[4])((LibVst.IMessage*)Unsafe.AsPointer(ref this), id);
            }
        }
        
        /// <summary>
        /// Returns the attribute list associated to the message.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IAttributeList* getAttributes()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IMessage*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IMessage), "getAttributes");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IMessage*, LibVst.IAttributeList*>)Vtbl[5])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IMessage*, LibVst.IAttributeList*>)Vtbl[5])((LibVst.IMessage*)Unsafe.AsPointer(ref this));
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns the message ID (for example "TextMessage").
        /// </summary>
        private static partial LibVst.FIDString getMessageID_ToManaged(IMessage* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static byte* getMessageID_Wrapper(IMessage* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IMessage), "getMessageID");
                try
                {
                    return getMessageID_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getMessageID_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Sets a message ID (for example "TextMessage").
        /// </summary>
        private static partial void setMessageID_ToManaged(IMessage* self, LibVst.FIDString id);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static void setMessageID_Wrapper(IMessage* self, byte* id)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IMessage), "setMessageID");
                try
                {
                    setMessageID_ToManaged(self, id);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    setMessageID_ToManaged(self, id);
                }
                catch
                {
                }
            }
        }
        
        /// <summary>
        /// Returns the attribute list associated to the message.
        /// </summary>
        private static partial LibVst.IAttributeList* getAttributes_ToManaged(IMessage* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static LibVst.IAttributeList* getAttributes_Wrapper(IMessage* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IMessage), "getAttributes");
                try
                {
                    return getAttributes_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getAttributes_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IMessage, 0x936F033B, 0xC6C047DB, 0xBB0882F8, 0x13C1E613)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x3b, 0x03, 0x6f, 0x93, 0xc0, 0xc6, 0xdb, 0x47, 0xbb, 0x08, 0x82, 0xf8, 0x13, 0xc1, 0xe6, 0x13 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x93, 0x6f, 0x03, 0x3b, 0xc6, 0xc0, 0x47, 0xdb, 0xbb, 0x08, 0x82, 0xf8, 0x13, 0xc1, 0xe6, 0x13 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Connect a component with another one: Vst::IConnectionPoint
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst300- [plug imp]
    /// - [host imp]
    /// - [released: 3.0.0]
    /// - [mandatory]This interface is used for the communication of separate components.
    /// Note that some hosts will place a proxy object between the components so that they are not directly connected.
    /// </remarks>
    /// <seealso cref="vst3Communication"/>
    public unsafe partial struct IConnectionPoint : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 6;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IConnectionPoint*, LibVst.IConnectionPoint*, int>)&connect_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IConnectionPoint*, LibVst.IConnectionPoint*, int>)&disconnect_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IConnectionPoint*, LibVst.IMessage*, int>)&notify_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IConnectionPoint, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IConnectionPoint, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IConnectionPoint, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Connects this instance with another connection point.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult connect(LibVst.IConnectionPoint* other)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IConnectionPoint*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IConnectionPoint), "connect");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IConnectionPoint*, LibVst.IConnectionPoint*, int>)Vtbl[3])(__self__, other);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IConnectionPoint*, LibVst.IConnectionPoint*, int>)Vtbl[3])((LibVst.IConnectionPoint*)Unsafe.AsPointer(ref this), other);
            }
        }
        
        /// <summary>
        /// Disconnects a given connection point from this.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult disconnect(LibVst.IConnectionPoint* other)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IConnectionPoint*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IConnectionPoint), "disconnect");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IConnectionPoint*, LibVst.IConnectionPoint*, int>)Vtbl[4])(__self__, other);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IConnectionPoint*, LibVst.IConnectionPoint*, int>)Vtbl[4])((LibVst.IConnectionPoint*)Unsafe.AsPointer(ref this), other);
            }
        }
        
        /// <summary>
        /// Called when a message has been sent from the connection point to this.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult notify(LibVst.IMessage* message)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IConnectionPoint*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IConnectionPoint), "notify");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IConnectionPoint*, LibVst.IMessage*, int>)Vtbl[5])(__self__, message);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IConnectionPoint*, LibVst.IMessage*, int>)Vtbl[5])((LibVst.IConnectionPoint*)Unsafe.AsPointer(ref this), message);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Connects this instance with another connection point.
        /// </summary>
        private static partial ComResult connect_ToManaged(IConnectionPoint* self, LibVst.IConnectionPoint* other);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int connect_Wrapper(IConnectionPoint* self, LibVst.IConnectionPoint* other)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IConnectionPoint), "connect");
                try
                {
                    return connect_ToManaged(self, other);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return connect_ToManaged(self, other);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Disconnects a given connection point from this.
        /// </summary>
        private static partial ComResult disconnect_ToManaged(IConnectionPoint* self, LibVst.IConnectionPoint* other);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int disconnect_Wrapper(IConnectionPoint* self, LibVst.IConnectionPoint* other)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IConnectionPoint), "disconnect");
                try
                {
                    return disconnect_ToManaged(self, other);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return disconnect_ToManaged(self, other);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Called when a message has been sent from the connection point to this.
        /// </summary>
        private static partial ComResult notify_ToManaged(IConnectionPoint* self, LibVst.IMessage* message);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int notify_Wrapper(IConnectionPoint* self, LibVst.IMessage* message)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IConnectionPoint), "notify");
                try
                {
                    return notify_ToManaged(self, message);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return notify_ToManaged(self, message);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IConnectionPoint, 0x70A4156F, 0x6E6E4026, 0x989148BF, 0xAA60D8D1)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x6f, 0x15, 0xa4, 0x70, 0x6e, 0x6e, 0x26, 0x40, 0x98, 0x91, 0x48, 0xbf, 0xaa, 0x60, 0xd8, 0xd1 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x70, 0xa4, 0x15, 0x6f, 0x6e, 0x6e, 0x40, 0x26, 0x98, 0x91, 0x48, 0xbf, 0xaa, 0x60, 0xd8, 0xd1 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Basic host callback interface: Vst::IHostApplication
    /// </summary>
    /// <remarks>
    ///  vstIHost vst300- [host imp]
    /// - [passed as 'context' in to IPluginBase::initialize () ]
    /// - [released: 3.0.0]
    /// - [mandatory]Basic VST host application interface.
    /// </remarks>
    public unsafe partial struct IHostApplication : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 5;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IHostApplication*, LibVst.String128*, int>)&getName_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IHostApplication*, Guid*, Guid*, void**, int>)&createInstance_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IHostApplication, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IHostApplication, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IHostApplication, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Gets host application name.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getName(LibVst.String128* name)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IHostApplication*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IHostApplication), "getName");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IHostApplication*, LibVst.String128*, int>)Vtbl[3])(__self__, name);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IHostApplication*, LibVst.String128*, int>)Vtbl[3])((LibVst.IHostApplication*)Unsafe.AsPointer(ref this), name);
            }
        }
        
        /// <summary>
        /// Creates host object (e.g. Vst::IMessage).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult createInstance(Guid* cid, Guid* _iid, void** obj)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IHostApplication*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IHostApplication), "createInstance");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IHostApplication*, Guid*, Guid*, void**, int>)Vtbl[4])(__self__, cid, _iid, obj);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IHostApplication*, Guid*, Guid*, void**, int>)Vtbl[4])((LibVst.IHostApplication*)Unsafe.AsPointer(ref this), cid, _iid, obj);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Gets host application name.
        /// </summary>
        private static partial ComResult getName_ToManaged(IHostApplication* self, LibVst.String128* name);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getName_Wrapper(IHostApplication* self, LibVst.String128* name)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IHostApplication), "getName");
                try
                {
                    return getName_ToManaged(self, name);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getName_ToManaged(self, name);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Creates host object (e.g. Vst::IMessage).
        /// </summary>
        private static partial ComResult createInstance_ToManaged(IHostApplication* self, Guid* cid, Guid* _iid, void** obj);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int createInstance_Wrapper(IHostApplication* self, Guid* cid, Guid* _iid, void** obj)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IHostApplication), "createInstance");
                try
                {
                    return createInstance_ToManaged(self, cid, _iid, obj);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return createInstance_ToManaged(self, cid, _iid, obj);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IHostApplication, 0x58E595CC, 0xDB2D4969, 0x8B6AAF8C, 0x36A664E5)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xcc, 0x95, 0xe5, 0x58, 0x2d, 0xdb, 0x69, 0x49, 0x8b, 0x6a, 0xaf, 0x8c, 0x36, 0xa6, 0x64, 0xe5 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x58, 0xe5, 0x95, 0xcc, 0xdb, 0x2d, 0x49, 0x69, 0x8b, 0x6a, 0xaf, 0x8c, 0x36, 0xa6, 0x64, 0xe5 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// VST 3 to VST 2 Wrapper interface: Vst::IVst3ToVst2Wrapper
    /// </summary>
    /// <remarks>
    ///  vstIHost vst310- [host imp]
    /// - [passed as 'context' to IPluginBase::initialize () ]
    /// - [released: 3.1.0]
    /// - [mandatory]Informs the plug-in that a VST 3 to VST 2 wrapper is used between the plug-in and the real host.
    /// Implemented by the VST 2 Wrapper.
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct IVst3ToVst2Wrapper
    {
        /// <summary>
        /// DECLARE_CLASS_IID (IVst3ToVst2Wrapper, 0x29633AEC, 0x1D1C47E2, 0xBB85B97B, 0xD36EAC61)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xec, 0x3a, 0x63, 0x29, 0x1c, 0x1d, 0xe2, 0x47, 0xbb, 0x85, 0xb9, 0x7b, 0xd3, 0x6e, 0xac, 0x61 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x29, 0x63, 0x3a, 0xec, 0x1d, 0x1c, 0x47, 0xe2, 0xbb, 0x85, 0xb9, 0x7b, 0xd3, 0x6e, 0xac, 0x61 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// VST 3 to AU Wrapper interface: Vst::IVst3ToAUWrapper
    /// </summary>
    /// <remarks>
    ///  vstIHost vst310- [host imp]
    /// - [passed as 'context' to IPluginBase::initialize () ]
    /// - [released: 3.1.0]
    /// - [mandatory]Informs the plug-in that a VST 3 to AU wrapper is used between the plug-in and the real host.
    /// Implemented by the AU Wrapper.
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct IVst3ToAUWrapper
    {
        /// <summary>
        /// DECLARE_CLASS_IID (IVst3ToAUWrapper, 0xA3B8C6C5, 0xC0954688, 0xB0916F0B, 0xB697AA44)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xc5, 0xc6, 0xb8, 0xa3, 0x95, 0xc0, 0x88, 0x46, 0xb0, 0x91, 0x6f, 0x0b, 0xb6, 0x97, 0xaa, 0x44 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xa3, 0xb8, 0xc6, 0xc5, 0xc0, 0x95, 0x46, 0x88, 0xb0, 0x91, 0x6f, 0x0b, 0xb6, 0x97, 0xaa, 0x44 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// VST 3 to AAX Wrapper interface: Vst::IVst3ToAAXWrapper
    /// </summary>
    /// <remarks>
    ///  vstIHost vst368- [host imp]
    /// - [passed as 'context' to IPluginBase::initialize () ]
    /// - [released: 3.6.8]
    /// - [mandatory]Informs the plug-in that a VST 3 to AAX wrapper is used between the plug-in and the real host.
    /// Implemented by the AAX Wrapper.
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct IVst3ToAAXWrapper
    {
        /// <summary>
        /// DECLARE_CLASS_IID (IVst3ToAAXWrapper, 0x6D319DC6, 0x60C56242, 0xB32C951B, 0x93BEF4C6)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xc6, 0x9d, 0x31, 0x6d, 0xc5, 0x60, 0x42, 0x62, 0xb3, 0x2c, 0x95, 0x1b, 0x93, 0xbe, 0xf4, 0xc6 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x6d, 0x31, 0x9d, 0xc6, 0x60, 0xc5, 0x62, 0x42, 0xb3, 0x2c, 0x95, 0x1b, 0x93, 0xbe, 0xf4, 0xc6 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Wrapper MPE Support interface: Vst::IVst3WrapperMPESupport
    /// </summary>
    /// <remarks>
    ///  vstIHost vst3612- [host imp]
    /// - [passed as 'context' to IPluginBase::initialize () ]
    /// - [released: 3.6.12]
    /// - [optional]Implemented on wrappers that support MPE to Note Expression translation.By default, MPE input processing is enabled, the masterChannel will be zero, the memberBeginChannel
    /// will be one and the memberEndChannel will be 14.As MPE is a subset of the VST3 Note Expression feature, mapping from the three MPE expressions is
    /// handled via the INoteExpressionPhysicalUIMapping interface.
    /// </remarks>
    public unsafe partial struct IVst3WrapperMPESupport : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 5;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IVst3WrapperMPESupport*, byte, int>)&enableMPEInputProcessing_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IVst3WrapperMPESupport*, int, int, int, int>)&setMPEInputDeviceSettings_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IVst3WrapperMPESupport, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IVst3WrapperMPESupport, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IVst3WrapperMPESupport, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// enable or disable MPE processing
        /// </summary>
        /// <param name="state">true to enable, false to disable MPE processing</param>
        /// <returns>kResultTrue on success</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult enableMPEInputProcessing(byte state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IVst3WrapperMPESupport*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IVst3WrapperMPESupport), "enableMPEInputProcessing");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IVst3WrapperMPESupport*, byte, int>)Vtbl[3])(__self__, state);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IVst3WrapperMPESupport*, byte, int>)Vtbl[3])((LibVst.IVst3WrapperMPESupport*)Unsafe.AsPointer(ref this), state);
            }
        }
        
        /// <summary>
        /// setup the MPE processing
        /// </summary>
        /// <param name="masterChannel">MPE master channel (zero based)</param>
        /// <param name="memberBeginChannel">MPE member begin channel (zero based)</param>
        /// <param name="memberEndChannel">MPE member end channel (zero based)</param>
        /// <returns>kResultTrue on success</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setMPEInputDeviceSettings(int masterChannel, int memberBeginChannel, int memberEndChannel)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IVst3WrapperMPESupport*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IVst3WrapperMPESupport), "setMPEInputDeviceSettings");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IVst3WrapperMPESupport*, int, int, int, int>)Vtbl[4])(__self__, masterChannel, memberBeginChannel, memberEndChannel);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IVst3WrapperMPESupport*, int, int, int, int>)Vtbl[4])((LibVst.IVst3WrapperMPESupport*)Unsafe.AsPointer(ref this), masterChannel, memberBeginChannel, memberEndChannel);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// enable or disable MPE processing
        /// </summary>
        /// <param name="state">true to enable, false to disable MPE processing</param>
        /// <returns>kResultTrue on success</returns>
        private static partial ComResult enableMPEInputProcessing_ToManaged(IVst3WrapperMPESupport* self, byte state);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int enableMPEInputProcessing_Wrapper(IVst3WrapperMPESupport* self, byte state)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IVst3WrapperMPESupport), "enableMPEInputProcessing");
                try
                {
                    return enableMPEInputProcessing_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return enableMPEInputProcessing_ToManaged(self, state);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// setup the MPE processing
        /// </summary>
        /// <param name="masterChannel">MPE master channel (zero based)</param>
        /// <param name="memberBeginChannel">MPE member begin channel (zero based)</param>
        /// <param name="memberEndChannel">MPE member end channel (zero based)</param>
        /// <returns>kResultTrue on success</returns>
        private static partial ComResult setMPEInputDeviceSettings_ToManaged(IVst3WrapperMPESupport* self, int masterChannel, int memberBeginChannel, int memberEndChannel);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setMPEInputDeviceSettings_Wrapper(IVst3WrapperMPESupport* self, int masterChannel, int memberBeginChannel, int memberEndChannel)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IVst3WrapperMPESupport), "setMPEInputDeviceSettings");
                try
                {
                    return setMPEInputDeviceSettings_ToManaged(self, masterChannel, memberBeginChannel, memberEndChannel);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setMPEInputDeviceSettings_ToManaged(self, masterChannel, memberBeginChannel, memberEndChannel);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IVst3WrapperMPESupport, 0x44149067, 0x42CF4BF9, 0x8800B750, 0xF7359FE3)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x67, 0x90, 0x14, 0x44, 0xcf, 0x42, 0xf9, 0x4b, 0x88, 0x00, 0xb7, 0x50, 0xf7, 0x35, 0x9f, 0xe3 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x44, 0x14, 0x90, 0x67, 0x42, 0xcf, 0x4b, 0xf9, 0x88, 0x00, 0xb7, 0x50, 0xf7, 0x35, 0x9f, 0xe3 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Extended plug-in interface IEditController for Inter-App Audio Preset Management
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst360- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.6.0]
    /// </remarks>
    public unsafe partial struct IInterAppAudioPresetManager : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 7;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IInterAppAudioPresetManager*, int>)&runLoadPresetBrowser_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IInterAppAudioPresetManager*, int>)&runSavePresetBrowser_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IInterAppAudioPresetManager*, int>)&loadNextPreset_Wrapper;
            vtbl[6] = (delegate*unmanaged[MemberFunction]<IInterAppAudioPresetManager*, int>)&loadPreviousPreset_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IInterAppAudioPresetManager, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IInterAppAudioPresetManager, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IInterAppAudioPresetManager, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Open the Preset Browser in order to load a preset
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult runLoadPresetBrowser()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IInterAppAudioPresetManager*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IInterAppAudioPresetManager), "runLoadPresetBrowser");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioPresetManager*, int>)Vtbl[3])(__self__);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioPresetManager*, int>)Vtbl[3])((LibVst.IInterAppAudioPresetManager*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Open the Preset Browser in order to save a preset
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult runSavePresetBrowser()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IInterAppAudioPresetManager*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IInterAppAudioPresetManager), "runSavePresetBrowser");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioPresetManager*, int>)Vtbl[4])(__self__);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioPresetManager*, int>)Vtbl[4])((LibVst.IInterAppAudioPresetManager*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Load the next available preset
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult loadNextPreset()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IInterAppAudioPresetManager*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IInterAppAudioPresetManager), "loadNextPreset");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioPresetManager*, int>)Vtbl[5])(__self__);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioPresetManager*, int>)Vtbl[5])((LibVst.IInterAppAudioPresetManager*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Load the previous available preset
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult loadPreviousPreset()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IInterAppAudioPresetManager*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IInterAppAudioPresetManager), "loadPreviousPreset");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioPresetManager*, int>)Vtbl[6])(__self__);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioPresetManager*, int>)Vtbl[6])((LibVst.IInterAppAudioPresetManager*)Unsafe.AsPointer(ref this));
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Open the Preset Browser in order to load a preset
        /// </summary>
        private static partial ComResult runLoadPresetBrowser_ToManaged(IInterAppAudioPresetManager* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int runLoadPresetBrowser_Wrapper(IInterAppAudioPresetManager* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IInterAppAudioPresetManager), "runLoadPresetBrowser");
                try
                {
                    return runLoadPresetBrowser_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return runLoadPresetBrowser_ToManaged(self);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Open the Preset Browser in order to save a preset
        /// </summary>
        private static partial ComResult runSavePresetBrowser_ToManaged(IInterAppAudioPresetManager* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int runSavePresetBrowser_Wrapper(IInterAppAudioPresetManager* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IInterAppAudioPresetManager), "runSavePresetBrowser");
                try
                {
                    return runSavePresetBrowser_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return runSavePresetBrowser_ToManaged(self);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Load the next available preset
        /// </summary>
        private static partial ComResult loadNextPreset_ToManaged(IInterAppAudioPresetManager* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int loadNextPreset_Wrapper(IInterAppAudioPresetManager* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IInterAppAudioPresetManager), "loadNextPreset");
                try
                {
                    return loadNextPreset_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return loadNextPreset_ToManaged(self);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Load the previous available preset
        /// </summary>
        private static partial ComResult loadPreviousPreset_ToManaged(IInterAppAudioPresetManager* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int loadPreviousPreset_Wrapper(IInterAppAudioPresetManager* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IInterAppAudioPresetManager), "loadPreviousPreset");
                try
                {
                    return loadPreviousPreset_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return loadPreviousPreset_ToManaged(self);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IInterAppAudioPresetManager, 0xADE6FCC4, 0x46C94E1D, 0xB3B49A80, 0xC93FEFDD)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xc4, 0xfc, 0xe6, 0xad, 0xc9, 0x46, 0x1d, 0x4e, 0xb3, 0xb4, 0x9a, 0x80, 0xc9, 0x3f, 0xef, 0xdd })
                        : new ReadOnlySpan<byte>(new byte[] { 0xad, 0xe6, 0xfc, 0xc4, 0x46, 0xc9, 0x4e, 0x1d, 0xb3, 0xb4, 0x9a, 0x80, 0xc9, 0x3f, 0xef, 0xdd })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Inter-App Audio host Interface.
    /// </summary>
    /// <remarks>
    ///  vstIHost vst360- [host imp]
    /// - [passed as 'context' to IPluginBase::initialize () ]
    /// - [released: 3.6.0]
    /// - [optional]Implemented by the InterAppAudio Wrapper.
    /// </remarks>
    public unsafe partial struct IInterAppAudioHost : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 11;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IInterAppAudioHost*, LibVst.ViewRect*, float*, int>)&getScreenSize_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IInterAppAudioHost*, int>)&connectedToHost_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IInterAppAudioHost*, int>)&switchToHost_Wrapper;
            vtbl[6] = (delegate*unmanaged[MemberFunction]<IInterAppAudioHost*, uint, int>)&sendRemoteControlEvent_Wrapper;
            vtbl[7] = (delegate*unmanaged[MemberFunction]<IInterAppAudioHost*, void**, int>)&getHostIcon_Wrapper;
            vtbl[8] = (delegate*unmanaged[MemberFunction]<IInterAppAudioHost*, LibVst.Event*, int>)&scheduleEventFromUI_Wrapper;
            vtbl[9] = (delegate*unmanaged[MemberFunction]<IInterAppAudioHost*, Guid*, LibVst.IInterAppAudioPresetManager*>)&createPresetManager_Wrapper;
            vtbl[10] = (delegate*unmanaged[MemberFunction]<IInterAppAudioHost*, int>)&showSettingsView_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IInterAppAudioHost, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IInterAppAudioHost, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IInterAppAudioHost, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// get the size of the screen
        /// </summary>
        /// <param name="size">size of the screen</param>
        /// <param name="scale">scale of the screen</param>
        /// <returns>kResultTrue on success</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getScreenSize(LibVst.ViewRect* size, float* scale)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IInterAppAudioHost), "getScreenSize");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioHost*, LibVst.ViewRect*, float*, int>)Vtbl[3])(__self__, size, scale);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioHost*, LibVst.ViewRect*, float*, int>)Vtbl[3])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this), size, scale);
            }
        }
        
        /// <summary>
        /// get status of connection
        /// </summary>
        /// <returns>kResultTrue if an Inter-App Audio connection is established</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult connectedToHost()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IInterAppAudioHost), "connectedToHost");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioHost*, int>)Vtbl[4])(__self__);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioHost*, int>)Vtbl[4])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// switch to the host.
        /// </summary>
        /// <returns>kResultTrue on success</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult switchToHost()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IInterAppAudioHost), "switchToHost");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioHost*, int>)Vtbl[5])(__self__);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioHost*, int>)Vtbl[5])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// send a remote control event to the host
        /// </summary>
        /// <param name="event">event type, see AudioUnitRemoteControlEvent in the iOS SDK documentation for possible types</param>
        /// <returns>kResultTrue on success</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult sendRemoteControlEvent(uint @event)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IInterAppAudioHost), "sendRemoteControlEvent");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioHost*, uint, int>)Vtbl[6])(__self__, @event);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioHost*, uint, int>)Vtbl[6])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this), @event);
            }
        }
        
        /// <summary>
        /// ask for the host icon.
        /// </summary>
        /// <param name="icon">pointer to a CGImageRef</param>
        /// <returns>kResultTrue on success</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getHostIcon(void** icon)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IInterAppAudioHost), "getHostIcon");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioHost*, void**, int>)Vtbl[7])(__self__, icon);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioHost*, void**, int>)Vtbl[7])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this), icon);
            }
        }
        
        /// <summary>
        /// schedule an event from the user interface thread
        /// </summary>
        /// <param name="event">the event to schedule</param>
        /// <returns>kResultTrue on success</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult scheduleEventFromUI(LibVst.Event* @event)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IInterAppAudioHost), "scheduleEventFromUI");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioHost*, LibVst.Event*, int>)Vtbl[8])(__self__, @event);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioHost*, LibVst.Event*, int>)Vtbl[8])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this), @event);
            }
        }
        
        /// <summary>
        /// get the preset manager
        /// </summary>
        /// <param name="cid">class ID to use by the preset manager</param>
        /// <returns>the preset manager. Needs to be released by called.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IInterAppAudioPresetManager* createPresetManager(Guid* cid)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IInterAppAudioHost), "createPresetManager");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioHost*, Guid*, LibVst.IInterAppAudioPresetManager*>)Vtbl[9])(__self__, cid);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioHost*, Guid*, LibVst.IInterAppAudioPresetManager*>)Vtbl[9])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this), cid);
            }
        }
        
        /// <summary>
        /// show the settings view
        /// currently includes MIDI settings and Tempo setting
        /// </summary>
        /// <returns>kResultTrue on success</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult showSettingsView()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IInterAppAudioHost), "showSettingsView");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioHost*, int>)Vtbl[10])(__self__);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IInterAppAudioHost*, int>)Vtbl[10])((LibVst.IInterAppAudioHost*)Unsafe.AsPointer(ref this));
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// get the size of the screen
        /// </summary>
        /// <param name="size">size of the screen</param>
        /// <param name="scale">scale of the screen</param>
        /// <returns>kResultTrue on success</returns>
        private static partial ComResult getScreenSize_ToManaged(IInterAppAudioHost* self, LibVst.ViewRect* size, float* scale);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getScreenSize_Wrapper(IInterAppAudioHost* self, LibVst.ViewRect* size, float* scale)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IInterAppAudioHost), "getScreenSize");
                try
                {
                    return getScreenSize_ToManaged(self, size, scale);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getScreenSize_ToManaged(self, size, scale);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// get status of connection
        /// </summary>
        /// <returns>kResultTrue if an Inter-App Audio connection is established</returns>
        private static partial ComResult connectedToHost_ToManaged(IInterAppAudioHost* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int connectedToHost_Wrapper(IInterAppAudioHost* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IInterAppAudioHost), "connectedToHost");
                try
                {
                    return connectedToHost_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return connectedToHost_ToManaged(self);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// switch to the host.
        /// </summary>
        /// <returns>kResultTrue on success</returns>
        private static partial ComResult switchToHost_ToManaged(IInterAppAudioHost* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int switchToHost_Wrapper(IInterAppAudioHost* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IInterAppAudioHost), "switchToHost");
                try
                {
                    return switchToHost_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return switchToHost_ToManaged(self);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// send a remote control event to the host
        /// </summary>
        /// <param name="event">event type, see AudioUnitRemoteControlEvent in the iOS SDK documentation for possible types</param>
        /// <returns>kResultTrue on success</returns>
        private static partial ComResult sendRemoteControlEvent_ToManaged(IInterAppAudioHost* self, uint @event);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int sendRemoteControlEvent_Wrapper(IInterAppAudioHost* self, uint @event)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IInterAppAudioHost), "sendRemoteControlEvent");
                try
                {
                    return sendRemoteControlEvent_ToManaged(self, @event);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return sendRemoteControlEvent_ToManaged(self, @event);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// ask for the host icon.
        /// </summary>
        /// <param name="icon">pointer to a CGImageRef</param>
        /// <returns>kResultTrue on success</returns>
        private static partial ComResult getHostIcon_ToManaged(IInterAppAudioHost* self, void** icon);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getHostIcon_Wrapper(IInterAppAudioHost* self, void** icon)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IInterAppAudioHost), "getHostIcon");
                try
                {
                    return getHostIcon_ToManaged(self, icon);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getHostIcon_ToManaged(self, icon);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// schedule an event from the user interface thread
        /// </summary>
        /// <param name="event">the event to schedule</param>
        /// <returns>kResultTrue on success</returns>
        private static partial ComResult scheduleEventFromUI_ToManaged(IInterAppAudioHost* self, LibVst.Event* @event);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int scheduleEventFromUI_Wrapper(IInterAppAudioHost* self, LibVst.Event* @event)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IInterAppAudioHost), "scheduleEventFromUI");
                try
                {
                    return scheduleEventFromUI_ToManaged(self, @event);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return scheduleEventFromUI_ToManaged(self, @event);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// get the preset manager
        /// </summary>
        /// <param name="cid">class ID to use by the preset manager</param>
        /// <returns>the preset manager. Needs to be released by called.</returns>
        private static partial LibVst.IInterAppAudioPresetManager* createPresetManager_ToManaged(IInterAppAudioHost* self, Guid* cid);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static LibVst.IInterAppAudioPresetManager* createPresetManager_Wrapper(IInterAppAudioHost* self, Guid* cid)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IInterAppAudioHost), "createPresetManager");
                try
                {
                    return createPresetManager_ToManaged(self, cid);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return createPresetManager_ToManaged(self, cid);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// show the settings view
        /// currently includes MIDI settings and Tempo setting
        /// </summary>
        /// <returns>kResultTrue on success</returns>
        private static partial ComResult showSettingsView_ToManaged(IInterAppAudioHost* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int showSettingsView_Wrapper(IInterAppAudioHost* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IInterAppAudioHost), "showSettingsView");
                try
                {
                    return showSettingsView_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return showSettingsView_ToManaged(self);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IInterAppAudioHost, 0x0CE5743D, 0x68DF415E, 0xAE285BD4, 0xE2CDC8FD)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x3d, 0x74, 0xe5, 0x0c, 0xdf, 0x68, 0x5e, 0x41, 0xae, 0x28, 0x5b, 0xd4, 0xe2, 0xcd, 0xc8, 0xfd })
                        : new ReadOnlySpan<byte>(new byte[] { 0x0c, 0xe5, 0x74, 0x3d, 0x68, 0xdf, 0x41, 0x5e, 0xae, 0x28, 0x5b, 0xd4, 0xe2, 0xcd, 0xc8, 0xfd })
                    )));
            }
        }
    }
    
    /// <summary>
    /// MIDI Learn interface: Vst::IMidiLearn
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst3612- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.6.12]
    /// - [optional]If this interface is implemented by the edit controller, the host will call this method whenever
    /// there is live MIDI-CC input for the plug-in. This way, the plug-in can change its MIDI-CC parameter
    /// mapping and inform the host via the IComponentHandler::restartComponent with the
    /// kMidiCCAssignmentChanged flag.
    /// Use this if you want to implement custom MIDI-Learn functionality in your plug-in.@code {.cpp}
    /// //------------------------------------------------
    /// // in MyController class declaration
    /// class MyController : public Vst::EditController, public Vst::IMidiLearn
    /// {
    /// 	// ...
    /// 	//--- IMidiLearn ---------------------------------
    /// 	tresult PLUGIN_API onLiveMIDIControllerInput (int32 busIndex, int16 channel,
    /// 												  CtrlNumber midiCC) SMTG_OVERRIDE;
    /// 	// ...
    /// 
    /// 	OBJ_METHODS (MyController, Vst::EditController)
    /// 	DEFINE_INTERFACES
    /// 		// ...
    /// 		DEF_INTERFACE (Vst::IMidiLearn)
    /// 	END_DEFINE_INTERFACES (Vst::EditController)
    /// 	//...
    /// }
    /// 
    /// //------------------------------------------------
    /// // in mycontroller.cpp
    /// #include "pluginterfaces/vst/ivstmidilearn.h
    /// 
    /// namespace Steinberg {
    /// 	namespace Vst {
    /// 		DEF_CLASS_IID (IMidiLearn)
    /// 	}
    /// }
    /// 
    /// //------------------------------------------------------------------------
    /// tresult PLUGIN_API MyController::onLiveMIDIControllerInput (int32 busIndex, 
    /// 							int16 channel, CtrlNumber midiCC)
    /// {
    /// 	// if we are not in doMIDILearn (triggered by a UI button for example) 
    /// 	// or wrong channel then return
    /// 	if (!doMIDILearn || busIndex != 0 || channel != 0 || midiLearnParamID == InvalidParamID)
    /// 		return kResultFalse;
    /// 
    /// 	// adapt our internal MIDICC -&gt; parameterID mapping
    /// 	midiCCMapping[midiCC] = midiLearnParamID;
    /// 
    /// 	// new mapping then inform the host that our MIDI assignment has changed
    /// 	if (auto componentHandler = getComponentHandler ())
    /// 	{
    /// 		componentHandler-&gt;restartComponent (kMidiCCAssignmentChanged);
    /// 	}
    /// 	return kResultTrue;
    /// }
    /// @endcode
    /// </remarks>
    public unsafe partial struct IMidiLearn : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IMidiLearn*, int, short, short, int>)&onLiveMIDIControllerInput_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IMidiLearn, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IMidiLearn, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IMidiLearn, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Called on live input MIDI-CC change associated to a given bus index and MIDI channel
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult onLiveMIDIControllerInput(int busIndex, short channel, LibVst.CtrlNumber midiCC)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IMidiLearn*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IMidiLearn), "onLiveMIDIControllerInput");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IMidiLearn*, int, short, LibVst.CtrlNumber, int>)Vtbl[3])(__self__, busIndex, channel, midiCC);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IMidiLearn*, int, short, LibVst.CtrlNumber, int>)Vtbl[3])((LibVst.IMidiLearn*)Unsafe.AsPointer(ref this), busIndex, channel, midiCC);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Called on live input MIDI-CC change associated to a given bus index and MIDI channel
        /// </summary>
        private static partial ComResult onLiveMIDIControllerInput_ToManaged(IMidiLearn* self, int busIndex, short channel, LibVst.CtrlNumber midiCC);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int onLiveMIDIControllerInput_Wrapper(IMidiLearn* self, int busIndex, short channel, short midiCC)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IMidiLearn), "onLiveMIDIControllerInput");
                try
                {
                    return onLiveMIDIControllerInput_ToManaged(self, busIndex, channel, midiCC);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return onLiveMIDIControllerInput_ToManaged(self, busIndex, channel, midiCC);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IMidiLearn, 0x6B2449CC, 0x419740B5, 0xAB3C79DA, 0xC5FE5C86)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xcc, 0x49, 0x24, 0x6b, 0x97, 0x41, 0xb5, 0x40, 0xab, 0x3c, 0x79, 0xda, 0xc5, 0xfe, 0x5c, 0x86 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x6b, 0x24, 0x49, 0xcc, 0x41, 0x97, 0x40, 0xb5, 0xab, 0x3c, 0x79, 0xda, 0xc5, 0xfe, 0x5c, 0x86 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Edit controller component interface extension: Vst::IParameterFunctionName
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst370- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.7.0]
    /// - [optional]This interface allows the host to get a parameter associated to a specific meaning (a functionName)
    /// for a given unit. The host can use this information, for example, for drawing a Gain Reduction meter
    /// in its own UI. In order to get the plain value of this parameter, the host should use the
    /// IEditController::normalizedParamToPlain. The host can automatically map parameters to dedicated UI
    /// controls, such as the wet-dry mix knob or Randomize button. IParameterFunctionNameExample Example@code {.cpp}
    /// //------------------------------------------------------------------------
    /// // here an example of how a VST3 plug-in could support this IParameterFunctionName interface.
    /// // we need to define somewhere the iids:
    /// 
    /// in MyController class declaration
    /// class MyController : public Vst::EditController, public Vst::IParameterFunctionName
    /// {
    ///     ...
    ///     tresult PLUGIN_API getParameterIDFromFunctionName (UnitID unitID, FIDString functionName,
    ///                                                     Vst::ParamID&amp; paramID) override;
    ///     ...
    /// 
    ///     OBJ_METHODS (MyController, Vst::EditController)
    ///     DEFINE_INTERFACES
    ///         ...
    ///         DEF_INTERFACE (Vst::IParameterFunctionName)
    ///     END_DEFINE_INTERFACES (Vst::EditController)
    ///     DELEGATE_REFCOUNT (Vst::EditController)
    ///     ...
    /// }
    /// 
    /// #include "ivstparameterfunctionname.h"
    /// namespace Steinberg {
    ///     namespace Vst {
    ///         DEF_CLASS_IID (IParameterFunctionName)
    ///     }
    /// }
    /// 
    /// //------------------------------------------------------------------------
    /// tresult PLUGIN_API MyController::getParameterIDFromFunctionName (UnitID unitID, FIDString
    /// functionName, Vst::ParamID&amp; paramID)
    /// {
    ///     using namespace Vst;
    /// 
    ///     paramID = kNoParamId;
    /// 
    ///     if (unitID == kRootUnitId &amp;&amp; FIDStringsEqual (functionName, kCompGainReduction))
    ///         paramID = kMyGainReductionId;
    /// 
    ///     return (paramID != kNoParamId) ? kResultOk : kResultFalse;
    /// }
    /// 
    /// //--- a host implementation example: --------------------
    /// ...
    /// FUnknownPtr&lt;Vst::IParameterFunctionName&gt; functionName (mEditController-&gt;getIEditController ());
    /// if (functionName)
    /// {
    ///     Vst::ParamID paramID;
    ///     if (functionName-&gt;getParameterIDFromFunctionName (kRootUnitId,
    ///                                                       Vst::FunctionNameType::kCompGainReduction, paramID) == kResultTrue)
    ///     {
    ///         // paramID could be cached for performance issue
    ///         ParamValue norm = mEditController-&gt;getIEditController ()-&gt;getParamNormalized (paramID);
    ///         ParamValue plain = mEditController-&gt;getIEditController ()-&gt;normalizedParamToPlain (paramID, norm);
    ///         // plain is something like -6 (-6dB)
    ///     }
    /// }
    /// @endcode
    /// </remarks>
    public unsafe partial struct IParameterFunctionName : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IParameterFunctionName*, int, byte*, LibVst.ParamID*, int>)&getParameterIDFromFunctionName_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IParameterFunctionName, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IParameterFunctionName, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IParameterFunctionName, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Gets for the given unitID the associated paramID to a function Name.
        /// Returns kResultFalse when no found parameter (paramID is set to kNoParamId in this case).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getParameterIDFromFunctionName(LibVst.UnitID unitID, LibVst.FIDString functionName, LibVst.ParamID* paramID)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IParameterFunctionName*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IParameterFunctionName), "getParameterIDFromFunctionName");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IParameterFunctionName*, LibVst.UnitID, LibVst.FIDString, LibVst.ParamID*, int>)Vtbl[3])(__self__, unitID, functionName, paramID);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IParameterFunctionName*, LibVst.UnitID, LibVst.FIDString, LibVst.ParamID*, int>)Vtbl[3])((LibVst.IParameterFunctionName*)Unsafe.AsPointer(ref this), unitID, functionName, paramID);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Gets for the given unitID the associated paramID to a function Name.
        /// Returns kResultFalse when no found parameter (paramID is set to kNoParamId in this case).
        /// </summary>
        private static partial ComResult getParameterIDFromFunctionName_ToManaged(IParameterFunctionName* self, LibVst.UnitID unitID, LibVst.FIDString functionName, LibVst.ParamID* paramID);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getParameterIDFromFunctionName_Wrapper(IParameterFunctionName* self, int unitID, byte* functionName, LibVst.ParamID* paramID)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IParameterFunctionName), "getParameterIDFromFunctionName");
                try
                {
                    return getParameterIDFromFunctionName_ToManaged(self, unitID, functionName, paramID);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getParameterIDFromFunctionName_ToManaged(self, unitID, functionName, paramID);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IParameterFunctionName, 0x6D21E1DC, 0x91199D4B, 0xA2A02FEF, 0x6C1AE55C)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xdc, 0xe1, 0x21, 0x6d, 0x19, 0x91, 0x4b, 0x9d, 0xa2, 0xa0, 0x2f, 0xef, 0x6c, 0x1a, 0xe5, 0x5c })
                        : new ReadOnlySpan<byte>(new byte[] { 0x6d, 0x21, 0xe1, 0xdc, 0x91, 0x19, 0x9d, 0x4b, 0xa2, 0xa0, 0x2f, 0xef, 0x6c, 0x1a, 0xe5, 0x5c })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Extended plug-in interface IEditController for note expression event support: Vst::INoteExpressionPhysicalUIMapping
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst3611- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.6.11]
    /// - [optional]With this plug-in interface, the host can retrieve the preferred physical mapping associated to note
    /// expression supported by the plug-in.
    /// When the mapping changes (for example when switching presets) the plug-in needs
    /// to inform the host about it via @ref IComponentHandler::restartComponent (kNoteExpressionChanged). INoteExpressionPhysicalUIMappingExample Example@code {.cpp}
    /// //------------------------------------------------------------------------
    /// // here an example of how a VST3 plug-in could support this INoteExpressionPhysicalUIMapping interface.
    /// // we need to define somewhere the iids:
    /// 
    /// //in MyController class declaration
    /// class MyController : public Vst::EditController, public Vst::INoteExpressionPhysicalUIMapping
    /// {
    /// 	// ...
    /// 	//--- INoteExpressionPhysicalUIMapping ---------------------------------
    /// 	tresult PLUGIN_API getPhysicalUIMapping (int32 busIndex, int16 channel, PhysicalUIMapList&amp; list) SMTG_OVERRIDE;
    /// 	// ...
    /// 
    /// 	OBJ_METHODS (MyController, Vst::EditController)
    /// 	DEFINE_INTERFACES
    /// 		// ...
    /// 		DEF_INTERFACE (Vst::INoteExpressionPhysicalUIMapping)
    /// 	END_DEFINE_INTERFACES (Vst::EditController)
    /// 	//...
    /// }
    /// 
    /// // In mycontroller.cpp
    /// #include "pluginterfaces/vst/ivstnoteexpression.h"
    /// 
    /// namespace Steinberg {
    /// 	namespace Vst {
    /// 		DEF_CLASS_IID (INoteExpressionPhysicalUIMapping)
    /// 	}
    /// }
    /// //------------------------------------------------------------------------
    /// tresult PLUGIN_API MyController::getPhysicalUIMapping (int32 busIndex, int16 channel, PhysicalUIMapList&amp; list)
    /// {
    /// 	if (busIndex == 0 &amp;&amp; channel == 0)
    /// 	{
    /// 		for (uint32 i = 0; i &lt; list.count; ++i)
    /// 		{
    /// 			NoteExpressionTypeID type = kInvalidTypeID;
    /// 			if (kPUIXMovement == list.map[i].physicalUITypeID)
    /// 				list.map[i].noteExpressionTypeID = kCustomStart + 1;
    /// 			else if (kPUIYMovement == list.map[i].physicalUITypeID)
    /// 				list.map[i].noteExpressionTypeID = kCustomStart + 2;
    /// 		}
    /// 		return kResultTrue;
    /// 	}
    /// 	return kResultFalse;
    /// }
    /// @endcode
    /// </remarks>
    public unsafe partial struct INoteExpressionPhysicalUIMapping : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<INoteExpressionPhysicalUIMapping*, int, short, LibVst.PhysicalUIMapList*, int>)&getPhysicalUIMapping_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<INoteExpressionPhysicalUIMapping, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<INoteExpressionPhysicalUIMapping, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<INoteExpressionPhysicalUIMapping, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Fills the list of mapped [physical UI (in) - note expression (out)] for a given bus index
        /// and channel.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getPhysicalUIMapping(int busIndex, short channel, LibVst.PhysicalUIMapList* list)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.INoteExpressionPhysicalUIMapping*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(INoteExpressionPhysicalUIMapping), "getPhysicalUIMapping");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.INoteExpressionPhysicalUIMapping*, int, short, LibVst.PhysicalUIMapList*, int>)Vtbl[3])(__self__, busIndex, channel, list);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.INoteExpressionPhysicalUIMapping*, int, short, LibVst.PhysicalUIMapList*, int>)Vtbl[3])((LibVst.INoteExpressionPhysicalUIMapping*)Unsafe.AsPointer(ref this), busIndex, channel, list);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Fills the list of mapped [physical UI (in) - note expression (out)] for a given bus index
        /// and channel.
        /// </summary>
        private static partial ComResult getPhysicalUIMapping_ToManaged(INoteExpressionPhysicalUIMapping* self, int busIndex, short channel, LibVst.PhysicalUIMapList* list);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getPhysicalUIMapping_Wrapper(INoteExpressionPhysicalUIMapping* self, int busIndex, short channel, LibVst.PhysicalUIMapList* list)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(INoteExpressionPhysicalUIMapping), "getPhysicalUIMapping");
                try
                {
                    return getPhysicalUIMapping_ToManaged(self, busIndex, channel, list);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getPhysicalUIMapping_ToManaged(self, busIndex, channel, list);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (INoteExpressionPhysicalUIMapping, 0xB03078FF, 0x94D24AC8, 0x90CCD303, 0xD4133324)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xff, 0x78, 0x30, 0xb0, 0xd2, 0x94, 0xc8, 0x4a, 0x90, 0xcc, 0xd3, 0x03, 0xd4, 0x13, 0x33, 0x24 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xb0, 0x30, 0x78, 0xff, 0x94, 0xd2, 0x4a, 0xc8, 0x90, 0xcc, 0xd3, 0x03, 0xd4, 0x13, 0x33, 0x24 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// PhysicalUIMapList describes a list of PhysicalUIMap
    /// </summary>
    /// <seealso cref="INoteExpressionPhysicalUIMapping"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct PhysicalUIMapList
    {
        /// <summary>
        /// Count of entries in the map array, set by the caller of getPhysicalUIMapping.
        /// </summary>
        public uint count;
        
        /// <summary>
        /// Pointer to a list of PhysicalUIMap containing count entries.
        /// </summary>
        public LibVst.PhysicalUIMap* map;
    }
    
    /// <summary>
    /// PhysicalUIMap describes a mapping of a noteExpression Type to a Physical UI Type.
    /// It is used in PhysicalUIMapList.
    /// </summary>
    /// <seealso cref="PhysicalUIMapList "/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct PhysicalUIMap
    {
        /// <summary>
        /// This represents the physical UI. /see PhysicalUITypeIDs, this is set by the caller of
        /// getPhysicalUIMapping
        /// </summary>
        public LibVst.PhysicalUITypeID physicalUITypeID;
        
        /// <summary>
        /// This represents the associated noteExpression TypeID to the given physicalUITypeID. This
        /// will be filled by the plug-in in the call getPhysicalUIMapping, set it to kInvalidTypeID if
        /// no Note Expression is associated to the given PUI.
        /// </summary>
        public LibVst.NoteExpressionTypeID noteExpressionTypeID;
    }
    
    public partial record struct PhysicalUITypeID(uint Value)
    {
        public static implicit operator uint(PhysicalUITypeID value) => value.Value;
        
        public static implicit operator PhysicalUITypeID(uint value) => new(value);
    }
    
    /// <summary>
    /// Host callback interface for an edit controller: Vst::IPlugInterfaceSupport
    /// </summary>
    /// <remarks>
    ///  vstIHost vst3612- [host imp]
    /// - [released: 3.6.12]
    /// - [optional]Allows a plug-in to ask the host if a given plug-in interface is supported/used by the host.
    /// It is implemented by the hostContext given when the component is initialized. IPlugInterfaceSupportExample Example@code {.cpp}
    /// //------------------------------------------------------------------------
    /// tresult PLUGIN_API MyPluginController::initialize (FUnknown* context)
    /// {
    /// 	// ...
    /// 	FUnknownPtr&lt;IPlugInterfaceSupport&gt; plugInterfaceSupport (context);
    /// 	if (plugInterfaceSupport)
    /// 	{
    /// 		if (plugInterfaceSupport-&gt;isPlugInterfaceSupported (IMidiMapping::iid) == kResultTrue)
    /// 			// IMidiMapping is used by the host
    /// 	}
    /// 	// ...
    /// }
    /// @endcode
    /// </remarks>
    /// <seealso cref="IPluginBase"/>
    public unsafe partial struct IPlugInterfaceSupport : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IPlugInterfaceSupport*, Guid*, int>)&isPlugInterfaceSupported_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IPlugInterfaceSupport, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IPlugInterfaceSupport, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IPlugInterfaceSupport, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Returns kResultTrue if the associated interface to the given _iid is supported/used by the host.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult isPlugInterfaceSupported(Guid* _iid)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPlugInterfaceSupport*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPlugInterfaceSupport), "isPlugInterfaceSupported");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPlugInterfaceSupport*, Guid*, int>)Vtbl[3])(__self__, _iid);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPlugInterfaceSupport*, Guid*, int>)Vtbl[3])((LibVst.IPlugInterfaceSupport*)Unsafe.AsPointer(ref this), _iid);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns kResultTrue if the associated interface to the given _iid is supported/used by the host.
        /// </summary>
        private static partial ComResult isPlugInterfaceSupported_ToManaged(IPlugInterfaceSupport* self, Guid* _iid);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int isPlugInterfaceSupported_Wrapper(IPlugInterfaceSupport* self, Guid* _iid)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPlugInterfaceSupport), "isPlugInterfaceSupported");
                try
                {
                    return isPlugInterfaceSupported_ToManaged(self, _iid);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return isPlugInterfaceSupported_ToManaged(self, _iid);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPlugInterfaceSupport, 0x4FB58B9E, 0x9EAA4E0F, 0xAB361C1C, 0xCCB56FEA)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x9e, 0x8b, 0xb5, 0x4f, 0xaa, 0x9e, 0x0f, 0x4e, 0xab, 0x36, 0x1c, 0x1c, 0xcc, 0xb5, 0x6f, 0xea })
                        : new ReadOnlySpan<byte>(new byte[] { 0x4f, 0xb5, 0x8b, 0x9e, 0x9e, 0xaa, 0x4e, 0x0f, 0xab, 0x36, 0x1c, 0x1c, 0xcc, 0xb5, 0x6f, 0xea })
                    )));
            }
        }
    }
    
    /// <summary>
    /// IParameterFinder Interface
    /// Extension for IPlugView to find view parameters (lookup value under mouse support): Vst::IParameterFinder
    /// </summary>
    /// <remarks>
    ///  pluginGUI vst302- [plug imp]
    /// - [extends IPlugView]
    /// - [released: 3.0.2]
    /// - [optional]It is highly recommended to implement this interface.
    /// A host can implement important functionality when a plug-in supports this interface.For example, all Steinberg hosts require this interface in order to support the "AI Knob".
    /// </remarks>
    public unsafe partial struct IParameterFinder : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IParameterFinder*, int, int, LibVst.ParamID*, int>)&findParameter_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IParameterFinder, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IParameterFinder, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IParameterFinder, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Find out which parameter in plug-in view is at given position (relative to plug-in view).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult findParameter(int xPos, int yPos, LibVst.ParamID* resultTag)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IParameterFinder*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IParameterFinder), "findParameter");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IParameterFinder*, int, int, LibVst.ParamID*, int>)Vtbl[3])(__self__, xPos, yPos, resultTag);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IParameterFinder*, int, int, LibVst.ParamID*, int>)Vtbl[3])((LibVst.IParameterFinder*)Unsafe.AsPointer(ref this), xPos, yPos, resultTag);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Find out which parameter in plug-in view is at given position (relative to plug-in view).
        /// </summary>
        private static partial ComResult findParameter_ToManaged(IParameterFinder* self, int xPos, int yPos, LibVst.ParamID* resultTag);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int findParameter_Wrapper(IParameterFinder* self, int xPos, int yPos, LibVst.ParamID* resultTag)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IParameterFinder), "findParameter");
                try
                {
                    return findParameter_ToManaged(self, xPos, yPos, resultTag);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return findParameter_ToManaged(self, xPos, yPos, resultTag);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IParameterFinder, 0x0F618302, 0x215D4587, 0xA512073C, 0x77B9D383)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x02, 0x83, 0x61, 0x0f, 0x5d, 0x21, 0x87, 0x45, 0xa5, 0x12, 0x07, 0x3c, 0x77, 0xb9, 0xd3, 0x83 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x0f, 0x61, 0x83, 0x02, 0x21, 0x5d, 0x45, 0x87, 0xa5, 0x12, 0x07, 0x3c, 0x77, 0xb9, 0xd3, 0x83 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// IPrefetchableSupport Interface
    /// Indicates that the plug-in could or not support Prefetch (dynamically): Vst::IPrefetchableSupport
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst365- [plug imp]
    /// - [extends IComponent]
    /// - [released: 3.6.5]
    /// - [optional]The plug-in should implement this interface if it needs to dynamically change between prefetchable or not.
    /// By default (without implementing this interface) the host decides in which mode the plug-in is processed.
    /// For more info about the prefetch processing mode check the ProcessModes::kPrefetch documentation. IPrefetchableSupportExample Example@code {.cpp}
    /// //------------------------------------------------------------------------
    /// tresult PLUGIN_API myPlug::getPrefetchableSupport (PrefetchableSupport&amp; prefetchable)
    /// {
    /// 	prefetchable = kIsNeverPrefetchable;
    /// 
    /// 	switch (myPrefetchableMode)
    /// 	{
    /// 		case 0: prefetchable = kIsNeverPrefetchable; break;
    /// 		case 1: prefetchable = kIsYetPrefetchable; break;
    /// 		case 2: prefetchable = kIsNotYetPrefetchable; break;
    /// 	}
    /// 	return kResultOk;
    /// }
    /// @endcode
    /// </remarks>
    public unsafe partial struct IPrefetchableSupport : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IPrefetchableSupport*, LibVst.PrefetchableSupport*, int>)&getPrefetchableSupport_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IPrefetchableSupport, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IPrefetchableSupport, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IPrefetchableSupport, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// retrieve the current prefetch support. Use IComponentHandler::restartComponent
        /// (kPrefetchableSupportChanged) to inform the host that this support has changed.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getPrefetchableSupport(LibVst.PrefetchableSupport* prefetchable)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IPrefetchableSupport*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IPrefetchableSupport), "getPrefetchableSupport");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IPrefetchableSupport*, LibVst.PrefetchableSupport*, int>)Vtbl[3])(__self__, prefetchable);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IPrefetchableSupport*, LibVst.PrefetchableSupport*, int>)Vtbl[3])((LibVst.IPrefetchableSupport*)Unsafe.AsPointer(ref this), prefetchable);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// retrieve the current prefetch support. Use IComponentHandler::restartComponent
        /// (kPrefetchableSupportChanged) to inform the host that this support has changed.
        /// </summary>
        private static partial ComResult getPrefetchableSupport_ToManaged(IPrefetchableSupport* self, LibVst.PrefetchableSupport* prefetchable);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getPrefetchableSupport_Wrapper(IPrefetchableSupport* self, LibVst.PrefetchableSupport* prefetchable)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IPrefetchableSupport), "getPrefetchableSupport");
                try
                {
                    return getPrefetchableSupport_ToManaged(self, prefetchable);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getPrefetchableSupport_ToManaged(self, prefetchable);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IPrefetchableSupport, 0x8AE54FDA, 0xE93046B9, 0xA28555BC, 0xDC98E21E)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xda, 0x4f, 0xe5, 0x8a, 0x30, 0xe9, 0xb9, 0x46, 0xa2, 0x85, 0x55, 0xbc, 0xdc, 0x98, 0xe2, 0x1e })
                        : new ReadOnlySpan<byte>(new byte[] { 0x8a, 0xe5, 0x4f, 0xda, 0xe9, 0x30, 0x46, 0xb9, 0xa2, 0x85, 0x55, 0xbc, 0xdc, 0x98, 0xe2, 0x1e })
                    )));
            }
        }
    }
    
    public partial record struct PrefetchableSupport(uint Value)
    {
        public static implicit operator uint(PrefetchableSupport value) => value.Value;
        
        public static implicit operator PrefetchableSupport(uint value) => new(value);
    }
    
    /// <summary>
    /// Extended plug-in interface IEditController for a component: Vst::IXmlRepresentationController
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst350- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.5.0]
    /// - [optional]A representation based on XML is a way to export, structure, and group plug-ins parameters for a specific remote (hardware or software rack (such as quick controls)).@n It allows to describe each parameter more precisely (what is the best matching to a knob, different title lengths matching limited remote display,...).@n See an @ref Example. @n @n - A representation is composed of pages (this means that to see all exported parameters, the user has to navigate through the pages).
    /// - A page is composed of cells (for example 8 cells per page).
    /// - A cell is composed of layers (for example a cell could have a knob, a display, and a button, which means 3 layers).
    /// - A layer is associated to a plug-in parameter using the ParameterID as identifier:
    /// - it could be a knob with a display for title and/or value, this display uses the same parameterId, but it could an another one.
    /// - switch
    /// - link which allows to jump directly to a subpage (another page) 
    /// - more... See Vst::LayerType
    /// .@n This representation is implemented as XML text following the Document Type Definition (DTD): http://dtd.steinberg.net/VST-Remote-1.1.dtd ExampleHere an example of what should be passed in the stream of getXmlRepresentationStream:@code &lt;?xml version="1.0" encoding="utf-8"?&gt;
    /// &lt;!DOCTYPE vstXML PUBLIC "-//Steinberg//DTD VST Remote 1.1//EN" "http://dtd.steinberg.net/VST-Remote-1.1.dtd"&gt;
    /// &lt;vstXML version="1.0"&gt;
    /// 	&lt;plugin classID="341FC5898AAA46A7A506BC0799E882AE" name="Chorus" vendor="Steinberg Media Technologies" /&gt;
    /// 	&lt;originator&gt;My name&lt;/originator&gt;
    /// 	&lt;date&gt;2010-12-31&lt;/date&gt;
    /// 	&lt;comment&gt;This is an example for 4 Cells per Page for the Remote named ProductRemote 
    /// 	         from company HardwareCompany.&lt;/comment&gt;
    /// 
    /// 	&lt;!-- ===================================== --&gt;
    /// 	&lt;representation name="ProductRemote" vendor="HardwareCompany" version="1.0"&gt;
    /// 		&lt;page name="Root"&gt;
    /// 			&lt;cell&gt;
    /// 				&lt;layer type="knob" parameterID="0"&gt;
    /// 					&lt;titleDisplay&gt;
    /// 						&lt;name&gt;Mix dry/wet&lt;/name&gt;
    /// 						&lt;name&gt;Mix&lt;/name&gt;
    /// 					&lt;/titleDisplay&gt;
    /// 				&lt;/layer&gt;
    /// 			&lt;/cell&gt;
    /// 			&lt;cell&gt;
    /// 				&lt;layer type="display"&gt;&lt;/layer&gt;
    /// 			&lt;/cell&gt;
    /// 			&lt;cell&gt;
    /// 				&lt;layer type="knob" parameterID="3"&gt;
    /// 					&lt;titleDisplay&gt;
    /// 						&lt;name&gt;Delay&lt;/name&gt;
    /// 						&lt;name&gt;Dly&lt;/name&gt;
    /// 					&lt;/titleDisplay&gt;
    /// 				&lt;/layer&gt;
    /// 			&lt;/cell&gt;
    /// 			&lt;cell&gt;
    /// 				&lt;layer type="knob" parameterID="15"&gt;
    /// 					&lt;titleDisplay&gt;
    /// 						&lt;name&gt;Spatial&lt;/name&gt;
    /// 						&lt;name&gt;Spat&lt;/name&gt;
    /// 					&lt;/titleDisplay&gt;
    /// 				&lt;/layer&gt;
    /// 			&lt;/cell&gt;
    /// 		&lt;/page&gt;
    /// 		&lt;page name="Page 2"&gt;
    /// 			&lt;cell&gt;
    /// 				&lt;layer type="LED" ledStyle="spread" parameterID="2"&gt;
    /// 					&lt;titleDisplay&gt;
    /// 						&lt;name&gt;Width +&lt;/name&gt;
    /// 						&lt;name&gt;Widt&lt;/name&gt;
    /// 					&lt;/titleDisplay&gt;
    /// 				&lt;/layer&gt;
    /// 				&lt;!--this is the switch for shape A/B--&gt;
    /// 				&lt;layer type="switch" switchStyle="pushIncLooped" parameterID="4"&gt;&lt;/layer&gt;
    /// 			&lt;/cell&gt;
    /// 			&lt;cell&gt;
    /// 				&lt;layer type="display"&gt;&lt;/layer&gt;
    /// 			&lt;/cell&gt;
    /// 			&lt;cell&gt;
    /// 				&lt;layer type="LED" ledStyle="singleDot" parameterID="17"&gt;
    /// 					&lt;titleDisplay&gt;
    /// 						&lt;name&gt;Sync Note +&lt;/name&gt;
    /// 						&lt;name&gt;Note&lt;/name&gt;
    /// 					&lt;/titleDisplay&gt;
    /// 				&lt;/layer&gt;
    /// 				&lt;!--this is the switch for sync to tempo on /off--&gt;
    /// 				&lt;layer type="switch" switchStyle="pushIncLooped" parameterID="16"&gt;&lt;/layer&gt;
    /// 			&lt;/cell&gt;
    /// 			&lt;cell&gt;
    /// 				&lt;layer type="knob" parameterID="1"&gt;
    /// 					&lt;titleDisplay&gt;
    /// 						&lt;name&gt;Rate&lt;/name&gt;
    /// 					&lt;/titleDisplay&gt;
    /// 				&lt;/layer&gt;
    /// 			&lt;/cell&gt;
    /// 		&lt;/page&gt;
    /// 	&lt;/representation&gt;
    /// &lt;/vstXML&gt;
    /// @endcode
    /// </remarks>
    public unsafe partial struct IXmlRepresentationController : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IXmlRepresentationController*, LibVst.RepresentationInfo*, LibVst.IBStream*, int>)&getXmlRepresentationStream_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IXmlRepresentationController, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IXmlRepresentationController, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IXmlRepresentationController, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Retrieves a stream containing a XmlRepresentation for a wanted representation info
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getXmlRepresentationStream(LibVst.RepresentationInfo* info, LibVst.IBStream* stream)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IXmlRepresentationController*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IXmlRepresentationController), "getXmlRepresentationStream");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IXmlRepresentationController*, LibVst.RepresentationInfo*, LibVst.IBStream*, int>)Vtbl[3])(__self__, info, stream);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IXmlRepresentationController*, LibVst.RepresentationInfo*, LibVst.IBStream*, int>)Vtbl[3])((LibVst.IXmlRepresentationController*)Unsafe.AsPointer(ref this), info, stream);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Retrieves a stream containing a XmlRepresentation for a wanted representation info
        /// </summary>
        private static partial ComResult getXmlRepresentationStream_ToManaged(IXmlRepresentationController* self, LibVst.RepresentationInfo* info, LibVst.IBStream* stream);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getXmlRepresentationStream_Wrapper(IXmlRepresentationController* self, LibVst.RepresentationInfo* info, LibVst.IBStream* stream)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IXmlRepresentationController), "getXmlRepresentationStream");
                try
                {
                    return getXmlRepresentationStream_ToManaged(self, info, stream);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getXmlRepresentationStream_ToManaged(self, info, stream);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IXmlRepresentationController, 0xA81A0471, 0x48C34DC4, 0xAC30C9E1, 0x3C8393D5)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x71, 0x04, 0x1a, 0xa8, 0xc3, 0x48, 0xc4, 0x4d, 0xac, 0x30, 0xc9, 0xe1, 0x3c, 0x83, 0x93, 0xd5 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xa8, 0x1a, 0x04, 0x71, 0x48, 0xc3, 0x4d, 0xc4, 0xac, 0x30, 0xc9, 0xe1, 0x3c, 0x83, 0x93, 0xd5 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// RepresentationInfo is the structure describing a representation
    /// This structure is used in the function
    /// </summary>
    /// <seealso cref="IXmlRepresentationController "/>
    /// <seealso cref="IXmlRepresentationController::getXmlRepresentationStream."/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct RepresentationInfo
    {
        /// <summary>
        /// Vendor name of the associated representation (remote) (eg. "Yamaha").
        /// </summary>
        public fixed byte vendor[64];
        
        /// <summary>
        /// Representation (remote) Name (eg. "O2").
        /// </summary>
        public fixed byte name[64];
        
        /// <summary>
        /// Version of this "Remote" (eg. "1.0").
        /// </summary>
        public fixed byte version[64];
        
        /// <summary>
        /// Optional: used if the representation is for a given host only (eg. "Nuendo").
        /// </summary>
        public fixed byte host[64];
        
        public enum ivstrepresentation
        {
            kNameSize = 64,
        }
    }
    
    /// <summary>
    /// Test Helper.
    /// </summary>
    /// <remarks>
    ///  TestClassThis class provides access to the component and the controller of a plug-in when running a unit
    /// test (see ITest).
    /// You get this interface as the context argument in the ITestFactory::createTests method.------------------------------------------------------------------------
    /// </remarks>
    public unsafe partial struct ITestPlugProvider : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 8;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<ITestPlugProvider*, LibVst.IComponent*>)&getComponent_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<ITestPlugProvider*, LibVst.IEditController*>)&getController_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<ITestPlugProvider*, LibVst.IComponent*, LibVst.IEditController*, int>)&releasePlugIn_Wrapper;
            vtbl[6] = (delegate*unmanaged[MemberFunction]<ITestPlugProvider*, LibVst.IStringResult*, int>)&getSubCategories_Wrapper;
            vtbl[7] = (delegate*unmanaged[MemberFunction]<ITestPlugProvider*, LibVst.FUID*, int>)&getComponentUID_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<ITestPlugProvider, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<ITestPlugProvider, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<ITestPlugProvider, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// get the component of the plug-in.
        /// </summary>
        /// <remarks>
        /// The reference count of the component is increased in this function and you need to call
        /// releasePlugIn when done with the component.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IComponent* getComponent()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.ITestPlugProvider*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(ITestPlugProvider), "getComponent");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.ITestPlugProvider*, LibVst.IComponent*>)Vtbl[3])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.ITestPlugProvider*, LibVst.IComponent*>)Vtbl[3])((LibVst.ITestPlugProvider*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// get the controller of the plug-in.
        /// </summary>
        /// <remarks>
        /// The reference count of the controller is increased in this function and you need to call
        /// releasePlugIn when done with the controller.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IEditController* getController()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.ITestPlugProvider*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(ITestPlugProvider), "getController");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.ITestPlugProvider*, LibVst.IEditController*>)Vtbl[4])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.ITestPlugProvider*, LibVst.IEditController*>)Vtbl[4])((LibVst.ITestPlugProvider*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// release the component and/or controller
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult releasePlugIn(LibVst.IComponent* component, LibVst.IEditController* controller)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.ITestPlugProvider*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(ITestPlugProvider), "releasePlugIn");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.ITestPlugProvider*, LibVst.IComponent*, LibVst.IEditController*, int>)Vtbl[5])(__self__, component, controller);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.ITestPlugProvider*, LibVst.IComponent*, LibVst.IEditController*, int>)Vtbl[5])((LibVst.ITestPlugProvider*)Unsafe.AsPointer(ref this), component, controller);
            }
        }
        
        /// <summary>
        /// get the sub categories of the plug-in
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getSubCategories(LibVst.IStringResult* result)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.ITestPlugProvider*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(ITestPlugProvider), "getSubCategories");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.ITestPlugProvider*, LibVst.IStringResult*, int>)Vtbl[6])(__self__, result);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.ITestPlugProvider*, LibVst.IStringResult*, int>)Vtbl[6])((LibVst.ITestPlugProvider*)Unsafe.AsPointer(ref this), result);
            }
        }
        
        /// <summary>
        /// get the component UID of the plug-in
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getComponentUID(LibVst.FUID* uid)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.ITestPlugProvider*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(ITestPlugProvider), "getComponentUID");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.ITestPlugProvider*, LibVst.FUID*, int>)Vtbl[7])(__self__, uid);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.ITestPlugProvider*, LibVst.FUID*, int>)Vtbl[7])((LibVst.ITestPlugProvider*)Unsafe.AsPointer(ref this), uid);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// get the component of the plug-in.
        /// </summary>
        /// <remarks>
        /// The reference count of the component is increased in this function and you need to call
        /// releasePlugIn when done with the component.
        /// </remarks>
        private static partial LibVst.IComponent* getComponent_ToManaged(ITestPlugProvider* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static LibVst.IComponent* getComponent_Wrapper(ITestPlugProvider* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(ITestPlugProvider), "getComponent");
                try
                {
                    return getComponent_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getComponent_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// get the controller of the plug-in.
        /// </summary>
        /// <remarks>
        /// The reference count of the controller is increased in this function and you need to call
        /// releasePlugIn when done with the controller.
        /// </remarks>
        private static partial LibVst.IEditController* getController_ToManaged(ITestPlugProvider* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static LibVst.IEditController* getController_Wrapper(ITestPlugProvider* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(ITestPlugProvider), "getController");
                try
                {
                    return getController_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getController_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// release the component and/or controller
        /// </summary>
        private static partial ComResult releasePlugIn_ToManaged(ITestPlugProvider* self, LibVst.IComponent* component, LibVst.IEditController* controller);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int releasePlugIn_Wrapper(ITestPlugProvider* self, LibVst.IComponent* component, LibVst.IEditController* controller)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(ITestPlugProvider), "releasePlugIn");
                try
                {
                    return releasePlugIn_ToManaged(self, component, controller);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return releasePlugIn_ToManaged(self, component, controller);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// get the sub categories of the plug-in
        /// </summary>
        private static partial ComResult getSubCategories_ToManaged(ITestPlugProvider* self, LibVst.IStringResult* result);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getSubCategories_Wrapper(ITestPlugProvider* self, LibVst.IStringResult* result)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(ITestPlugProvider), "getSubCategories");
                try
                {
                    return getSubCategories_ToManaged(self, result);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getSubCategories_ToManaged(self, result);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// get the component UID of the plug-in
        /// </summary>
        private static partial ComResult getComponentUID_ToManaged(ITestPlugProvider* self, LibVst.FUID* uid);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getComponentUID_Wrapper(ITestPlugProvider* self, LibVst.FUID* uid)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(ITestPlugProvider), "getComponentUID");
                try
                {
                    return getComponentUID_ToManaged(self, uid);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getComponentUID_ToManaged(self, uid);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (ITestPlugProvider, 0x86BE70EE, 0x4E99430F, 0x978F1E6E, 0xD68FB5BA)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xee, 0x70, 0xbe, 0x86, 0x99, 0x4e, 0x0f, 0x43, 0x97, 0x8f, 0x1e, 0x6e, 0xd6, 0x8f, 0xb5, 0xba })
                        : new ReadOnlySpan<byte>(new byte[] { 0x86, 0xbe, 0x70, 0xee, 0x4e, 0x99, 0x43, 0x0f, 0x97, 0x8f, 0x1e, 0x6e, 0xd6, 0x8f, 0xb5, 0xba })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Handling 16 Byte Globally Unique Identifiers.
    /// </summary>
    /// <remarks>
    ///  pluginBaseEach interface declares its identifier as static member inside the interface
    /// namespace (e.g. FUnknown::iid).
    /// </remarks>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct FUID
    {
        /// <summary>
        /// 
        /// </summary>
        public Guid data;
        
        public enum UIDPrintStyle
        {
            /// <summary>
            /// "INLINE_UID (0x00000000, 0x00000000, 0x00000000, 0x00000000)"
            /// </summary>
            kINLINE_UID,
            
            /// <summary>
            /// "DECLARE_UID (0x00000000, 0x00000000, 0x00000000, 0x00000000)"
            /// </summary>
            kDECLARE_UID,
            
            /// <summary>
            /// "FUID (0x00000000, 0x00000000, 0x00000000, 0x00000000)"
            /// </summary>
            kFUID,
            
            /// <summary>
            /// "DECLARE_CLASS_IID (Interface, 0x00000000, 0x00000000, 0x00000000, 0x00000000)"
            /// </summary>
            kCLASS_UID,
        }
    }
    
    /// <summary>
    /// Test Helper extension.
    /// </summary>
    /// <remarks>
    ///  TestClass
    /// </remarks>
    public unsafe partial struct ITestPlugProvider2 : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 9;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            ITestPlugProvider.InitializeVtbl(vtbl);
            vtbl[8] = (delegate*unmanaged[MemberFunction]<ITestPlugProvider2*, LibVst.IPluginFactory*>)&getPluginFactory_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<ITestPlugProvider2, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<ITestPlugProvider2, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<ITestPlugProvider2, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// get the component of the plug-in.
        /// </summary>
        /// <remarks>
        /// The reference count of the component is increased in this function and you need to call
        /// releasePlugIn when done with the component.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IComponent* getComponent()
        {
            return Unsafe.As<ITestPlugProvider2, ITestPlugProvider>(ref this).getComponent();
        }
        
        /// <summary>
        /// get the controller of the plug-in.
        /// </summary>
        /// <remarks>
        /// The reference count of the controller is increased in this function and you need to call
        /// releasePlugIn when done with the controller.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IEditController* getController()
        {
            return Unsafe.As<ITestPlugProvider2, ITestPlugProvider>(ref this).getController();
        }
        
        /// <summary>
        /// release the component and/or controller
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult releasePlugIn(LibVst.IComponent* component, LibVst.IEditController* controller)
        {
            return Unsafe.As<ITestPlugProvider2, ITestPlugProvider>(ref this).releasePlugIn(component, controller);
        }
        
        /// <summary>
        /// get the sub categories of the plug-in
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getSubCategories(LibVst.IStringResult* result)
        {
            return Unsafe.As<ITestPlugProvider2, ITestPlugProvider>(ref this).getSubCategories(result);
        }
        
        /// <summary>
        /// get the component UID of the plug-in
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getComponentUID(LibVst.FUID* uid)
        {
            return Unsafe.As<ITestPlugProvider2, ITestPlugProvider>(ref this).getComponentUID(uid);
        }
        
        /// <summary>
        /// get the plugin factory.
        /// </summary>
        /// <remarks>
        /// The reference count of the returned factory object is not increased when calling this
        /// function.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public LibVst.IPluginFactory* getPluginFactory()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.ITestPlugProvider2*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(ITestPlugProvider2), "getPluginFactory");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.ITestPlugProvider2*, LibVst.IPluginFactory*>)Vtbl[8])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.ITestPlugProvider2*, LibVst.IPluginFactory*>)Vtbl[8])((LibVst.ITestPlugProvider2*)Unsafe.AsPointer(ref this));
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// get the plugin factory.
        /// </summary>
        /// <remarks>
        /// The reference count of the returned factory object is not increased when calling this
        /// function.
        /// </remarks>
        private static partial LibVst.IPluginFactory* getPluginFactory_ToManaged(ITestPlugProvider2* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static LibVst.IPluginFactory* getPluginFactory_Wrapper(ITestPlugProvider2* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(ITestPlugProvider2), "getPluginFactory");
                try
                {
                    return getPluginFactory_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getPluginFactory_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (ITestPlugProvider2, 0xC7C75364, 0x7B8343AC, 0xA4495B0A, 0x3E5A46C7)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x64, 0x53, 0xc7, 0xc7, 0x83, 0x7b, 0xac, 0x43, 0xa4, 0x49, 0x5b, 0x0a, 0x3e, 0x5a, 0x46, 0xc7 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xc7, 0xc7, 0x53, 0x64, 0x7b, 0x83, 0x43, 0xac, 0xa4, 0x49, 0x5b, 0x0a, 0x3e, 0x5a, 0x46, 0xc7 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Host callback for unit support: Vst::IUnitHandler
    /// </summary>
    /// <remarks>
    ///  vstIHost vst300- [host imp]
    /// - [extends IComponentHandler]
    /// - [released: 3.0.0]
    /// - [optional]Host callback interface, used with IUnitInfo.
    /// Retrieve via queryInterface from IComponentHandler.
    /// </remarks>
    /// <seealso cref="IUnitInfovst3Units,"/>
    public unsafe partial struct IUnitHandler : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 5;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IUnitHandler*, int, int>)&notifyUnitSelection_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IUnitHandler*, int, int, int>)&notifyProgramListChange_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IUnitHandler, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IUnitHandler, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IUnitHandler, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Notify host when a module is selected in plug-in GUI.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult notifyUnitSelection(LibVst.UnitID unitId)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IUnitHandler*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IUnitHandler), "notifyUnitSelection");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IUnitHandler*, LibVst.UnitID, int>)Vtbl[3])(__self__, unitId);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IUnitHandler*, LibVst.UnitID, int>)Vtbl[3])((LibVst.IUnitHandler*)Unsafe.AsPointer(ref this), unitId);
            }
        }
        
        /// <summary>
        /// Tell host that the plug-in controller changed a program list (rename, load, PitchName changes).
        /// </summary>
        /// <param name="programIndex">: when kAllProgramInvalid, all program information is invalid, otherwise only the program of given index.</param>
        /// <param name="listId">is the specified program list ID to inform.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult notifyProgramListChange(LibVst.ProgramListID listId, int programIndex)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IUnitHandler*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IUnitHandler), "notifyProgramListChange");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IUnitHandler*, LibVst.ProgramListID, int, int>)Vtbl[4])(__self__, listId, programIndex);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IUnitHandler*, LibVst.ProgramListID, int, int>)Vtbl[4])((LibVst.IUnitHandler*)Unsafe.AsPointer(ref this), listId, programIndex);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Notify host when a module is selected in plug-in GUI.
        /// </summary>
        private static partial ComResult notifyUnitSelection_ToManaged(IUnitHandler* self, LibVst.UnitID unitId);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int notifyUnitSelection_Wrapper(IUnitHandler* self, int unitId)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IUnitHandler), "notifyUnitSelection");
                try
                {
                    return notifyUnitSelection_ToManaged(self, unitId);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return notifyUnitSelection_ToManaged(self, unitId);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Tell host that the plug-in controller changed a program list (rename, load, PitchName changes).
        /// </summary>
        /// <param name="programIndex">: when kAllProgramInvalid, all program information is invalid, otherwise only the program of given index.</param>
        /// <param name="listId">is the specified program list ID to inform.</param>
        private static partial ComResult notifyProgramListChange_ToManaged(IUnitHandler* self, LibVst.ProgramListID listId, int programIndex);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int notifyProgramListChange_Wrapper(IUnitHandler* self, int listId, int programIndex)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IUnitHandler), "notifyProgramListChange");
                try
                {
                    return notifyProgramListChange_ToManaged(self, listId, programIndex);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return notifyProgramListChange_ToManaged(self, listId, programIndex);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IUnitHandler, 0x4B5147F8, 0x4654486B, 0x8DAB30BA, 0x163A3C56)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xf8, 0x47, 0x51, 0x4b, 0x54, 0x46, 0x6b, 0x48, 0x8d, 0xab, 0x30, 0xba, 0x16, 0x3a, 0x3c, 0x56 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x4b, 0x51, 0x47, 0xf8, 0x46, 0x54, 0x48, 0x6b, 0x8d, 0xab, 0x30, 0xba, 0x16, 0x3a, 0x3c, 0x56 })
                    )));
            }
        }
    }
    
    public partial record struct ProgramListID(int Value)
    {
        public static implicit operator int(ProgramListID value) => value.Value;
        
        public static implicit operator ProgramListID(int value) => new(value);
    }
    
    /// <summary>
    /// Host callback for extended unit support: Vst::IUnitHandler2
    /// </summary>
    /// <remarks>
    ///  vstIHost vst365- [host imp]
    /// - [extends IUnitHandler]
    /// - [released: 3.6.5]
    /// - [optional]Host callback interface, used with IUnitInfo.
    /// Retrieve via queryInterface from IComponentHandler.The plug-in has the possibility to inform the host with notifyUnitByBusChange that something has
    /// changed in the bus - unit assignment, the host then has to recall IUnitInfo::getUnitByBus in order
    /// to get the new relations between busses and unit.
    /// </remarks>
    /// <seealso cref="IUnitHandlervst3Units,"/>
    public unsafe partial struct IUnitHandler2 : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IUnitHandler2*, int>)&notifyUnitByBusChange_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IUnitHandler2, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IUnitHandler2, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IUnitHandler2, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Tell host that assignment Unit-Bus defined by IUnitInfo::getUnitByBus has changed.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult notifyUnitByBusChange()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IUnitHandler2*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IUnitHandler2), "notifyUnitByBusChange");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IUnitHandler2*, int>)Vtbl[3])(__self__);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IUnitHandler2*, int>)Vtbl[3])((LibVst.IUnitHandler2*)Unsafe.AsPointer(ref this));
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Tell host that assignment Unit-Bus defined by IUnitInfo::getUnitByBus has changed.
        /// </summary>
        private static partial ComResult notifyUnitByBusChange_ToManaged(IUnitHandler2* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int notifyUnitByBusChange_Wrapper(IUnitHandler2* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IUnitHandler2), "notifyUnitByBusChange");
                try
                {
                    return notifyUnitByBusChange_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return notifyUnitByBusChange_ToManaged(self);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IUnitHandler2, 0xF89F8CDF, 0x699E4BA5, 0x96AAC9A4, 0x81452B01)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xdf, 0x8c, 0x9f, 0xf8, 0x9e, 0x69, 0xa5, 0x4b, 0x96, 0xaa, 0xc9, 0xa4, 0x81, 0x45, 0x2b, 0x01 })
                        : new ReadOnlySpan<byte>(new byte[] { 0xf8, 0x9f, 0x8c, 0xdf, 0x69, 0x9e, 0x4b, 0xa5, 0x96, 0xaa, 0xc9, 0xa4, 0x81, 0x45, 0x2b, 0x01 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Edit controller extension to describe the plug-in structure: Vst::IUnitInfo
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst300- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.0.0]
    /// - [optional]IUnitInfo describes the internal structure of the plug-in.
    /// - The root unit is the component itself, so getUnitCount must return 1 at least.
    /// - The root unit id has to be 0 (kRootUnitId).
    /// - Each unit can reference one program list - this reference must not change.
    /// - Each unit, using a program list, references one program of the list.
    /// </remarks>
    /// <seealso cref="IUnitHandlervst3Units,"/>
    public unsafe partial struct IUnitInfo : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 15;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IUnitInfo*, int>)&getUnitCount_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IUnitInfo*, int, LibVst.UnitInfo*, int>)&getUnitInfo_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IUnitInfo*, int>)&getProgramListCount_Wrapper;
            vtbl[6] = (delegate*unmanaged[MemberFunction]<IUnitInfo*, int, LibVst.ProgramListInfo*, int>)&getProgramListInfo_Wrapper;
            vtbl[7] = (delegate*unmanaged[MemberFunction]<IUnitInfo*, int, int, LibVst.String128*, int>)&getProgramName_Wrapper;
            vtbl[8] = (delegate*unmanaged[MemberFunction]<IUnitInfo*, int, int, byte*, LibVst.String128*, int>)&getProgramInfo_Wrapper;
            vtbl[9] = (delegate*unmanaged[MemberFunction]<IUnitInfo*, int, int, int>)&hasProgramPitchNames_Wrapper;
            vtbl[10] = (delegate*unmanaged[MemberFunction]<IUnitInfo*, int, int, short, LibVst.String128*, int>)&getProgramPitchName_Wrapper;
            vtbl[11] = (delegate*unmanaged[MemberFunction]<IUnitInfo*, int>)&getSelectedUnit_Wrapper;
            vtbl[12] = (delegate*unmanaged[MemberFunction]<IUnitInfo*, int, int>)&selectUnit_Wrapper;
            vtbl[13] = (delegate*unmanaged[MemberFunction]<IUnitInfo*, int, int, int, int, LibVst.UnitID*, int>)&getUnitByBus_Wrapper;
            vtbl[14] = (delegate*unmanaged[MemberFunction]<IUnitInfo*, int, int, LibVst.IBStream*, int>)&setUnitProgramData_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IUnitInfo, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IUnitInfo, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IUnitInfo, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Returns the flat count of units.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getUnitCount()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IUnitInfo*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IUnitInfo), "getUnitCount");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, int>)Vtbl[3])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, int>)Vtbl[3])((LibVst.IUnitInfo*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Gets UnitInfo for a given index in the flat list of unit.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getUnitInfo(int unitIndex, LibVst.UnitInfo* info)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IUnitInfo*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IUnitInfo), "getUnitInfo");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, int, LibVst.UnitInfo*, int>)Vtbl[4])(__self__, unitIndex, info);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, int, LibVst.UnitInfo*, int>)Vtbl[4])((LibVst.IUnitInfo*)Unsafe.AsPointer(ref this), unitIndex, info);
            }
        }
        
        /// <summary>
        /// Component intern program structure.
        /// </summary>
        /// <remarks>
        /// Gets the count of Program List.
        /// </remarks>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getProgramListCount()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IUnitInfo*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IUnitInfo), "getProgramListCount");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, int>)Vtbl[5])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, int>)Vtbl[5])((LibVst.IUnitInfo*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Gets for a given index the Program List Info.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getProgramListInfo(int listIndex, LibVst.ProgramListInfo* info)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IUnitInfo*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IUnitInfo), "getProgramListInfo");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, int, LibVst.ProgramListInfo*, int>)Vtbl[6])(__self__, listIndex, info);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, int, LibVst.ProgramListInfo*, int>)Vtbl[6])((LibVst.IUnitInfo*)Unsafe.AsPointer(ref this), listIndex, info);
            }
        }
        
        /// <summary>
        /// Gets for a given program list ID and program index its program name.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getProgramName(LibVst.ProgramListID listId, int programIndex, LibVst.String128* name)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IUnitInfo*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IUnitInfo), "getProgramName");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, LibVst.ProgramListID, int, LibVst.String128*, int>)Vtbl[7])(__self__, listId, programIndex, name);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, LibVst.ProgramListID, int, LibVst.String128*, int>)Vtbl[7])((LibVst.IUnitInfo*)Unsafe.AsPointer(ref this), listId, programIndex, name);
            }
        }
        
        /// <summary>
        /// Gets for a given program list ID, program index and attributeId the associated attribute value.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getProgramInfo(LibVst.ProgramListID listId, int programIndex, LibVst.CString attributeId, LibVst.String128* attributeValue)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IUnitInfo*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IUnitInfo), "getProgramInfo");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, LibVst.ProgramListID, int, LibVst.CString, LibVst.String128*, int>)Vtbl[8])(__self__, listId, programIndex, attributeId, attributeValue);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, LibVst.ProgramListID, int, LibVst.CString, LibVst.String128*, int>)Vtbl[8])((LibVst.IUnitInfo*)Unsafe.AsPointer(ref this), listId, programIndex, attributeId, attributeValue);
            }
        }
        
        /// <summary>
        /// Returns kResultTrue if the given program index of a given program list ID supports PitchNames.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult hasProgramPitchNames(LibVst.ProgramListID listId, int programIndex)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IUnitInfo*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IUnitInfo), "hasProgramPitchNames");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, LibVst.ProgramListID, int, int>)Vtbl[9])(__self__, listId, programIndex);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, LibVst.ProgramListID, int, int>)Vtbl[9])((LibVst.IUnitInfo*)Unsafe.AsPointer(ref this), listId, programIndex);
            }
        }
        
        /// <summary>
        /// Gets the PitchName for a given program list ID, program index and pitch.
        /// If PitchNames are changed the plug-in should inform the host with IUnitHandler::notifyProgramListChange.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getProgramPitchName(LibVst.ProgramListID listId, int programIndex, short midiPitch, LibVst.String128* name)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IUnitInfo*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IUnitInfo), "getProgramPitchName");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, LibVst.ProgramListID, int, short, LibVst.String128*, int>)Vtbl[10])(__self__, listId, programIndex, midiPitch, name);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, LibVst.ProgramListID, int, short, LibVst.String128*, int>)Vtbl[10])((LibVst.IUnitInfo*)Unsafe.AsPointer(ref this), listId, programIndex, midiPitch, name);
            }
        }
        
        /// <summary>
        /// units selection --------------------
        /// Gets the current selected unit.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int getSelectedUnit()
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IUnitInfo*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IUnitInfo), "getSelectedUnit");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, int>)Vtbl[11])(__self__);
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, int>)Vtbl[11])((LibVst.IUnitInfo*)Unsafe.AsPointer(ref this));
            }
        }
        
        /// <summary>
        /// Sets a new selected unit.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult selectUnit(LibVst.UnitID unitId)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IUnitInfo*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IUnitInfo), "selectUnit");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, LibVst.UnitID, int>)Vtbl[12])(__self__, unitId);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, LibVst.UnitID, int>)Vtbl[12])((LibVst.IUnitInfo*)Unsafe.AsPointer(ref this), unitId);
            }
        }
        
        /// <summary>
        /// Gets the according unit if there is an unambiguous relation between a channel or a bus and a unit.
        /// This method mainly is intended to find out which unit is related to a given MIDI input channel.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getUnitByBus(LibVst.MediaType type, LibVst.BusDirection dir, int busIndex, int channel, LibVst.UnitID* unitId)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IUnitInfo*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IUnitInfo), "getUnitByBus");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, LibVst.MediaType, LibVst.BusDirection, int, int, LibVst.UnitID*, int>)Vtbl[13])(__self__, type, dir, busIndex, channel, unitId);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, LibVst.MediaType, LibVst.BusDirection, int, int, LibVst.UnitID*, int>)Vtbl[13])((LibVst.IUnitInfo*)Unsafe.AsPointer(ref this), type, dir, busIndex, channel, unitId);
            }
        }
        
        /// <summary>
        /// Receives a preset data stream.
        /// - If the component supports program list data (IProgramListData), the destination of the data
        /// stream is the program specified by list-Id and program index (first and second parameter)
        /// - If the component supports unit data (IUnitData), the destination is the unit specified by the first
        /// parameter - in this case parameter programIndex is 
        /// &lt;
        /// 0).
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setUnitProgramData(int listOrUnitId, int programIndex, LibVst.IBStream* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IUnitInfo*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IUnitInfo), "setUnitProgramData");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, int, int, LibVst.IBStream*, int>)Vtbl[14])(__self__, listOrUnitId, programIndex, data);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IUnitInfo*, int, int, LibVst.IBStream*, int>)Vtbl[14])((LibVst.IUnitInfo*)Unsafe.AsPointer(ref this), listOrUnitId, programIndex, data);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns the flat count of units.
        /// </summary>
        private static partial int getUnitCount_ToManaged(IUnitInfo* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getUnitCount_Wrapper(IUnitInfo* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IUnitInfo), "getUnitCount");
                try
                {
                    return getUnitCount_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getUnitCount_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Gets UnitInfo for a given index in the flat list of unit.
        /// </summary>
        private static partial ComResult getUnitInfo_ToManaged(IUnitInfo* self, int unitIndex, LibVst.UnitInfo* info);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getUnitInfo_Wrapper(IUnitInfo* self, int unitIndex, LibVst.UnitInfo* info)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IUnitInfo), "getUnitInfo");
                try
                {
                    return getUnitInfo_ToManaged(self, unitIndex, info);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getUnitInfo_ToManaged(self, unitIndex, info);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Component intern program structure.
        /// </summary>
        /// <remarks>
        /// Gets the count of Program List.
        /// </remarks>
        private static partial int getProgramListCount_ToManaged(IUnitInfo* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getProgramListCount_Wrapper(IUnitInfo* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IUnitInfo), "getProgramListCount");
                try
                {
                    return getProgramListCount_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getProgramListCount_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Gets for a given index the Program List Info.
        /// </summary>
        private static partial ComResult getProgramListInfo_ToManaged(IUnitInfo* self, int listIndex, LibVst.ProgramListInfo* info);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getProgramListInfo_Wrapper(IUnitInfo* self, int listIndex, LibVst.ProgramListInfo* info)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IUnitInfo), "getProgramListInfo");
                try
                {
                    return getProgramListInfo_ToManaged(self, listIndex, info);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getProgramListInfo_ToManaged(self, listIndex, info);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets for a given program list ID and program index its program name.
        /// </summary>
        private static partial ComResult getProgramName_ToManaged(IUnitInfo* self, LibVst.ProgramListID listId, int programIndex, LibVst.String128* name);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getProgramName_Wrapper(IUnitInfo* self, int listId, int programIndex, LibVst.String128* name)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IUnitInfo), "getProgramName");
                try
                {
                    return getProgramName_ToManaged(self, listId, programIndex, name);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getProgramName_ToManaged(self, listId, programIndex, name);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets for a given program list ID, program index and attributeId the associated attribute value.
        /// </summary>
        private static partial ComResult getProgramInfo_ToManaged(IUnitInfo* self, LibVst.ProgramListID listId, int programIndex, LibVst.CString attributeId, LibVst.String128* attributeValue);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getProgramInfo_Wrapper(IUnitInfo* self, int listId, int programIndex, byte* attributeId, LibVst.String128* attributeValue)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IUnitInfo), "getProgramInfo");
                try
                {
                    return getProgramInfo_ToManaged(self, listId, programIndex, attributeId, attributeValue);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getProgramInfo_ToManaged(self, listId, programIndex, attributeId, attributeValue);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Returns kResultTrue if the given program index of a given program list ID supports PitchNames.
        /// </summary>
        private static partial ComResult hasProgramPitchNames_ToManaged(IUnitInfo* self, LibVst.ProgramListID listId, int programIndex);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int hasProgramPitchNames_Wrapper(IUnitInfo* self, int listId, int programIndex)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IUnitInfo), "hasProgramPitchNames");
                try
                {
                    return hasProgramPitchNames_ToManaged(self, listId, programIndex);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return hasProgramPitchNames_ToManaged(self, listId, programIndex);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets the PitchName for a given program list ID, program index and pitch.
        /// If PitchNames are changed the plug-in should inform the host with IUnitHandler::notifyProgramListChange.
        /// </summary>
        private static partial ComResult getProgramPitchName_ToManaged(IUnitInfo* self, LibVst.ProgramListID listId, int programIndex, short midiPitch, LibVst.String128* name);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getProgramPitchName_Wrapper(IUnitInfo* self, int listId, int programIndex, short midiPitch, LibVst.String128* name)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IUnitInfo), "getProgramPitchName");
                try
                {
                    return getProgramPitchName_ToManaged(self, listId, programIndex, midiPitch, name);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getProgramPitchName_ToManaged(self, listId, programIndex, midiPitch, name);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// units selection --------------------
        /// Gets the current selected unit.
        /// </summary>
        private static partial LibVst.UnitID getSelectedUnit_ToManaged(IUnitInfo* self);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getSelectedUnit_Wrapper(IUnitInfo* self)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IUnitInfo), "getSelectedUnit");
                try
                {
                    return getSelectedUnit_ToManaged(self);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return default;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getSelectedUnit_ToManaged(self);
                }
                catch
                {
                    return default;
                }
            }
        }
        
        /// <summary>
        /// Sets a new selected unit.
        /// </summary>
        private static partial ComResult selectUnit_ToManaged(IUnitInfo* self, LibVst.UnitID unitId);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int selectUnit_Wrapper(IUnitInfo* self, int unitId)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IUnitInfo), "selectUnit");
                try
                {
                    return selectUnit_ToManaged(self, unitId);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return selectUnit_ToManaged(self, unitId);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets the according unit if there is an unambiguous relation between a channel or a bus and a unit.
        /// This method mainly is intended to find out which unit is related to a given MIDI input channel.
        /// </summary>
        private static partial ComResult getUnitByBus_ToManaged(IUnitInfo* self, LibVst.MediaType type, LibVst.BusDirection dir, int busIndex, int channel, LibVst.UnitID* unitId);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getUnitByBus_Wrapper(IUnitInfo* self, int type, int dir, int busIndex, int channel, LibVst.UnitID* unitId)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IUnitInfo), "getUnitByBus");
                try
                {
                    return getUnitByBus_ToManaged(self, type, dir, busIndex, channel, unitId);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getUnitByBus_ToManaged(self, type, dir, busIndex, channel, unitId);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Receives a preset data stream.
        /// - If the component supports program list data (IProgramListData), the destination of the data
        /// stream is the program specified by list-Id and program index (first and second parameter)
        /// - If the component supports unit data (IUnitData), the destination is the unit specified by the first
        /// parameter - in this case parameter programIndex is 
        /// &lt;
        /// 0).
        /// </summary>
        private static partial ComResult setUnitProgramData_ToManaged(IUnitInfo* self, int listOrUnitId, int programIndex, LibVst.IBStream* data);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setUnitProgramData_Wrapper(IUnitInfo* self, int listOrUnitId, int programIndex, LibVst.IBStream* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IUnitInfo), "setUnitProgramData");
                try
                {
                    return setUnitProgramData_ToManaged(self, listOrUnitId, programIndex, data);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setUnitProgramData_ToManaged(self, listOrUnitId, programIndex, data);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IUnitInfo, 0x3D4BD6B5, 0x913A4FD2, 0xA886E768, 0xA5EB92C1)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0xb5, 0xd6, 0x4b, 0x3d, 0x3a, 0x91, 0xd2, 0x4f, 0xa8, 0x86, 0xe7, 0x68, 0xa5, 0xeb, 0x92, 0xc1 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x3d, 0x4b, 0xd6, 0xb5, 0x91, 0x3a, 0x4f, 0xd2, 0xa8, 0x86, 0xe7, 0x68, 0xa5, 0xeb, 0x92, 0xc1 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Basic Unit Description.
    /// </summary>
    /// <seealso cref="IUnitInfo"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct UnitInfo
    {
        /// <summary>
        /// unit identifier
        /// </summary>
        public LibVst.UnitID id;
        
        /// <summary>
        /// identifier of parent unit (kNoParentUnitId: does not apply, this unit is the root)
        /// </summary>
        public LibVst.UnitID parentUnitId;
        
        /// <summary>
        /// name, optional for the root component, required otherwise
        /// </summary>
        public LibVst.String128 name;
        
        /// <summary>
        /// id of program list used in unit (kNoProgramListId = no programs used in this unit)
        /// </summary>
        public LibVst.ProgramListID programListId;
    }
    
    /// <summary>
    /// Basic Program List Description.
    /// </summary>
    /// <seealso cref="IUnitInfo"/>
    [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode, Pack = 16)]
    public unsafe partial struct ProgramListInfo
    {
        /// <summary>
        /// program list identifier
        /// </summary>
        public LibVst.ProgramListID id;
        
        /// <summary>
        /// name of program list
        /// </summary>
        public LibVst.String128 name;
        
        /// <summary>
        /// number of programs in this list
        /// </summary>
        public int programCount;
    }
    
    public unsafe partial struct CString
    {
        public byte* Value;
        
        public static implicit operator byte*(CString value) => value.Value;
        
        public static implicit operator CString(byte* value) => new CString() { Value = value };
    }
    
    /// <summary>
    /// Component extension to access program list data: Vst::IProgramListData
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst300- [plug imp]
    /// - [extends IComponent]
    /// - [released: 3.0.0]
    /// - [optional]A component can support program list data via this interface or/and
    /// unit preset data (IUnitData).
    /// </remarks>
    /// <seealso cref="vst3MultitimbralProgramsIUnitData, "/>
    public unsafe partial struct IProgramListData : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 6;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IProgramListData*, int, int>)&programDataSupported_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IProgramListData*, int, int, LibVst.IBStream*, int>)&getProgramData_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IProgramListData*, int, int, LibVst.IBStream*, int>)&setProgramData_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IProgramListData, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IProgramListData, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IProgramListData, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Returns kResultTrue if the given Program List ID supports Program Data.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult programDataSupported(LibVst.ProgramListID listId)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IProgramListData*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IProgramListData), "programDataSupported");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IProgramListData*, LibVst.ProgramListID, int>)Vtbl[3])(__self__, listId);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IProgramListData*, LibVst.ProgramListID, int>)Vtbl[3])((LibVst.IProgramListData*)Unsafe.AsPointer(ref this), listId);
            }
        }
        
        /// <summary>
        /// Gets for a given program list ID and program index the program Data.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getProgramData(LibVst.ProgramListID listId, int programIndex, LibVst.IBStream* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IProgramListData*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IProgramListData), "getProgramData");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IProgramListData*, LibVst.ProgramListID, int, LibVst.IBStream*, int>)Vtbl[4])(__self__, listId, programIndex, data);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IProgramListData*, LibVst.ProgramListID, int, LibVst.IBStream*, int>)Vtbl[4])((LibVst.IProgramListData*)Unsafe.AsPointer(ref this), listId, programIndex, data);
            }
        }
        
        /// <summary>
        /// Sets for a given program list ID and program index a program Data.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setProgramData(LibVst.ProgramListID listId, int programIndex, LibVst.IBStream* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IProgramListData*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IProgramListData), "setProgramData");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IProgramListData*, LibVst.ProgramListID, int, LibVst.IBStream*, int>)Vtbl[5])(__self__, listId, programIndex, data);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IProgramListData*, LibVst.ProgramListID, int, LibVst.IBStream*, int>)Vtbl[5])((LibVst.IProgramListData*)Unsafe.AsPointer(ref this), listId, programIndex, data);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns kResultTrue if the given Program List ID supports Program Data.
        /// </summary>
        private static partial ComResult programDataSupported_ToManaged(IProgramListData* self, LibVst.ProgramListID listId);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int programDataSupported_Wrapper(IProgramListData* self, int listId)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IProgramListData), "programDataSupported");
                try
                {
                    return programDataSupported_ToManaged(self, listId);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return programDataSupported_ToManaged(self, listId);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets for a given program list ID and program index the program Data.
        /// </summary>
        private static partial ComResult getProgramData_ToManaged(IProgramListData* self, LibVst.ProgramListID listId, int programIndex, LibVst.IBStream* data);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getProgramData_Wrapper(IProgramListData* self, int listId, int programIndex, LibVst.IBStream* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IProgramListData), "getProgramData");
                try
                {
                    return getProgramData_ToManaged(self, listId, programIndex, data);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getProgramData_ToManaged(self, listId, programIndex, data);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Sets for a given program list ID and program index a program Data.
        /// </summary>
        private static partial ComResult setProgramData_ToManaged(IProgramListData* self, LibVst.ProgramListID listId, int programIndex, LibVst.IBStream* data);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setProgramData_Wrapper(IProgramListData* self, int listId, int programIndex, LibVst.IBStream* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IProgramListData), "setProgramData");
                try
                {
                    return setProgramData_ToManaged(self, listId, programIndex, data);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setProgramData_ToManaged(self, listId, programIndex, data);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IProgramListData, 0x8683B01F, 0x7B354F70, 0xA2651DEC, 0x353AF4FF)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x1f, 0xb0, 0x83, 0x86, 0x35, 0x7b, 0x70, 0x4f, 0xa2, 0x65, 0x1d, 0xec, 0x35, 0x3a, 0xf4, 0xff })
                        : new ReadOnlySpan<byte>(new byte[] { 0x86, 0x83, 0xb0, 0x1f, 0x7b, 0x35, 0x4f, 0x70, 0xa2, 0x65, 0x1d, 0xec, 0x35, 0x3a, 0xf4, 0xff })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Component extension to access unit data: Vst::IUnitData
    /// </summary>
    /// <remarks>
    ///  vstIPlug vst300- [plug imp]
    /// - [extends IComponent]
    /// - [released: 3.0.0]
    /// - [optional]A component can support unit preset data via this interface or
    /// program list data (IProgramListData).
    /// </remarks>
    /// <seealso cref="vst3ProgramLists"/>
    public unsafe partial struct IUnitData : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 6;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IUnitData*, int, int>)&unitDataSupported_Wrapper;
            vtbl[4] = (delegate*unmanaged[MemberFunction]<IUnitData*, int, LibVst.IBStream*, int>)&getUnitData_Wrapper;
            vtbl[5] = (delegate*unmanaged[MemberFunction]<IUnitData*, int, LibVst.IBStream*, int>)&setUnitData_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IUnitData, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IUnitData, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IUnitData, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Returns kResultTrue if the specified unit supports export and import of preset data.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult unitDataSupported(LibVst.UnitID unitID)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IUnitData*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IUnitData), "unitDataSupported");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IUnitData*, LibVst.UnitID, int>)Vtbl[3])(__self__, unitID);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IUnitData*, LibVst.UnitID, int>)Vtbl[3])((LibVst.IUnitData*)Unsafe.AsPointer(ref this), unitID);
            }
        }
        
        /// <summary>
        /// Gets the preset data for the specified unit.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult getUnitData(LibVst.UnitID unitId, LibVst.IBStream* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IUnitData*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IUnitData), "getUnitData");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IUnitData*, LibVst.UnitID, LibVst.IBStream*, int>)Vtbl[4])(__self__, unitId, data);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IUnitData*, LibVst.UnitID, LibVst.IBStream*, int>)Vtbl[4])((LibVst.IUnitData*)Unsafe.AsPointer(ref this), unitId, data);
            }
        }
        
        /// <summary>
        /// Sets the preset data for the specified unit.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setUnitData(LibVst.UnitID unitId, LibVst.IBStream* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IUnitData*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IUnitData), "setUnitData");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IUnitData*, LibVst.UnitID, LibVst.IBStream*, int>)Vtbl[5])(__self__, unitId, data);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IUnitData*, LibVst.UnitID, LibVst.IBStream*, int>)Vtbl[5])((LibVst.IUnitData*)Unsafe.AsPointer(ref this), unitId, data);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Returns kResultTrue if the specified unit supports export and import of preset data.
        /// </summary>
        private static partial ComResult unitDataSupported_ToManaged(IUnitData* self, LibVst.UnitID unitID);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int unitDataSupported_Wrapper(IUnitData* self, int unitID)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IUnitData), "unitDataSupported");
                try
                {
                    return unitDataSupported_ToManaged(self, unitID);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return unitDataSupported_ToManaged(self, unitID);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Gets the preset data for the specified unit.
        /// </summary>
        private static partial ComResult getUnitData_ToManaged(IUnitData* self, LibVst.UnitID unitId, LibVst.IBStream* data);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int getUnitData_Wrapper(IUnitData* self, int unitId, LibVst.IBStream* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IUnitData), "getUnitData");
                try
                {
                    return getUnitData_ToManaged(self, unitId, data);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return getUnitData_ToManaged(self, unitId, data);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// Sets the preset data for the specified unit.
        /// </summary>
        private static partial ComResult setUnitData_ToManaged(IUnitData* self, LibVst.UnitID unitId, LibVst.IBStream* data);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setUnitData_Wrapper(IUnitData* self, int unitId, LibVst.IBStream* data)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IUnitData), "setUnitData");
                try
                {
                    return setUnitData_ToManaged(self, unitId, data);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setUnitData_ToManaged(self, unitId, data);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IUnitData, 0x6C389611, 0xD391455D, 0xB870B833, 0x94A0EFDD)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x11, 0x96, 0x38, 0x6c, 0x91, 0xd3, 0x5d, 0x45, 0xb8, 0x70, 0xb8, 0x33, 0x94, 0xa0, 0xef, 0xdd })
                        : new ReadOnlySpan<byte>(new byte[] { 0x6c, 0x38, 0x96, 0x11, 0xd3, 0x91, 0x45, 0x5d, 0xb8, 0x70, 0xb8, 0x33, 0x94, 0xa0, 0xef, 0xdd })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Bus media types
    /// </summary>
    public enum MediaTypes
    {
        /// <summary>
        /// audio
        /// </summary>
        kAudio = 0,
        
        /// <summary>
        /// events
        /// </summary>
        kEvent,
        
        kNumMediaTypes,
    }
    
    /// <summary>
    /// Bus directions
    /// </summary>
    public enum BusDirections
    {
        /// <summary>
        /// input bus
        /// </summary>
        kInput = 0,
        
        /// <summary>
        /// output bus
        /// </summary>
        kOutput,
    }
    
    /// <summary>
    /// Bus types
    /// </summary>
    public enum BusTypes
    {
        /// <summary>
        /// main bus
        /// </summary>
        kMain = 0,
        
        /// <summary>
        /// auxiliary bus (sidechain)
        /// </summary>
        kAux,
    }
    
    /// <summary>
    /// I/O modes
    /// </summary>
    public enum IoModes
    {
        /// <summary>
        /// 1:1 Input / Output. Only used for Instruments. See @ref vst3IoMode
        /// </summary>
        kSimple = 0,
        
        /// <summary>
        /// n:m Input / Output. Only used for Instruments.
        /// </summary>
        kAdvanced,
        
        /// <summary>
        /// plug-in used in an offline processing context
        /// </summary>
        kOfflineProcessing,
    }
    
    /// <summary>
    /// Component Flags used as classFlags in PClassInfo2
    /// </summary>
    public enum ComponentFlags
    {
        /// <summary>
        /// Component can be run on remote computer
        /// </summary>
        kDistributable = 1 << 0,
        
        /// <summary>
        /// Component supports simple IO mode (or works in simple mode anyway) see @ref vst3IoMode
        /// </summary>
        kSimpleModeSupported = 1 << 1,
    }
    
    /// <summary>
    /// Symbolic sample size.
    /// </summary>
    /// <seealso cref="ProcessSetup, ProcessData"/>
    public enum SymbolicSampleSizes
    {
        /// <summary>
        /// 32-bit precision
        /// </summary>
        kSample32,
        
        /// <summary>
        /// 64-bit precision
        /// </summary>
        kSample64,
    }
    
    /// <summary>
    /// Processing mode informs the plug-in about the context and at which frequency the process call is called.
    /// VST3 defines 3 modes:
    /// - kRealtime: each process call is called at a realtime frequency (defined by [numSamples of ProcessData] / samplerate).
    /// The plug-in should always try to process as fast as possible in order to let enough time slice to other plug-ins.
    /// - kPrefetch: each process call could be called at a variable frequency (jitter, slower / faster than realtime),
    /// the plug-in should process at the same quality level than realtime, plug-in must not slow down to realtime
    /// (e.g. disk streaming)!
    /// The host should avoid to process in kPrefetch mode such sampler based plug-in.
    /// - kOffline:  each process call could be faster than realtime or slower, higher quality than realtime could be used.
    /// plug-ins using disk streaming should be sure that they have enough time in the process call for streaming,
    /// if needed by slowing down to realtime or slower.
    /// .
    /// Note about Process Modes switching:
    /// - Switching between kRealtime and kPrefetch process modes are done in realtime thread without need of calling
    /// IAudioProcessor::setupProcessing, the plug-in should check in process call the member processMode of ProcessData
    /// in order to know in which mode it is processed.
    /// - Switching between kRealtime (or kPrefetch) and kOffline requires that the host calls IAudioProcessor::setupProcessing
    /// in order to inform the plug-in about this mode change.
    /// .
    /// </summary>
    /// <seealso cref="ProcessSetup, ProcessData"/>
    public enum ProcessModes
    {
        /// <summary>
        /// realtime processing
        /// </summary>
        kRealtime,
        
        /// <summary>
        /// prefetch processing
        /// </summary>
        kPrefetch,
        
        /// <summary>
        /// offline processing
        /// </summary>
        kOffline,
    }
    
    /// <summary>
    /// Flags used for IComponentHandler::restartComponent
    /// </summary>
    public enum RestartFlags
    {
        /// <summary>
        /// The Component should be reloaded
        /// The host has to unload completely the plug-in (controller/processor) and reload it. 
        /// [SDK 3.0.0]
        /// </summary>
        kReloadComponent = 1 << 0,
        
        /// <summary>
        /// Input / Output Bus configuration has changed
        /// The plug-in informs the host that either the bus configuration or the bus count has changed.
        /// The host has to deactivate the plug-in, asks the plug-in for its wanted new bus configurations,
        /// adapts its processing graph and reactivate the plug-in.
        /// [SDK 3.0.0]
        /// </summary>
        kIoChanged = 1 << 1,
        
        /// <summary>
        /// Multiple parameter values have changed  (as result of a program change for example)
        /// The host invalidates all caches of parameter values and asks the edit controller for the current values.
        /// [SDK 3.0.0]
        /// </summary>
        kParamValuesChanged = 1 << 2,
        
        /// <summary>
        /// Latency has changed
        /// The plug informs the host that its latency has changed, getLatencySamples should return the new latency after setActive (true) was called
        /// The host has to deactivate and reactivate the plug-in, then afterwards the host could ask for the current latency (getLatencySamples)
        /// see IAudioProcessor::getLatencySamples
        /// [SDK 3.0.0]
        /// </summary>
        kLatencyChanged = 1 << 3,
        
        /// <summary>
        /// Parameter titles, default values or flags (ParameterFlags) have changed
        /// The host invalidates all caches of parameter infos and asks the edit controller for the current infos.
        /// [SDK 3.0.0]
        /// </summary>
        kParamTitlesChanged = 1 << 4,
        
        /// <summary>
        /// MIDI Controllers and/or Program Changes Assignments have changed
        /// The plug-in informs the host that its MIDI-CC mapping has changed (for example after a MIDI learn or new loaded preset) 
        /// or if the stepCount or UnitID of a ProgramChange parameter has changed.
        /// The host has to rebuild the MIDI-CC =&gt; parameter mapping (getMidiControllerAssignment)
        /// and reread program changes parameters (stepCount and associated unitID)
        /// [SDK 3.0.1]
        /// </summary>
        kMidiCCAssignmentChanged = 1 << 5,
        
        /// <summary>
        /// Note Expression has changed (info, count, PhysicalUIMapping, ...)
        /// Either the note expression type info, the count of note expressions or the physical UI mapping has changed.
        /// The host invalidates all caches of note expression infos and asks the edit controller for the current ones.
        /// See INoteExpressionController, NoteExpressionTypeInfo and INoteExpressionPhysicalUIMapping
        /// [SDK 3.5.0]
        /// </summary>
        kNoteExpressionChanged = 1 << 6,
        
        /// <summary>
        /// Input / Output bus titles have changed
        /// The host invalidates all caches of bus titles and asks the edit controller for the current titles.
        /// [SDK 3.5.0]
        /// </summary>
        kIoTitlesChanged = 1 << 7,
        
        /// <summary>
        /// Prefetch support has changed
        /// The plug-in informs the host that its PrefetchSupport has changed
        /// The host has to deactivate the plug-in, calls IPrefetchableSupport::getPrefetchableSupport and reactivate the plug-in
        /// see IPrefetchableSupport
        /// [SDK 3.6.1]
        /// </summary>
        kPrefetchableSupportChanged = 1 << 8,
        
        /// <summary>
        /// RoutingInfo has changed
        /// The plug-in informs the host that its internal routing (relation of an event-input-channel to an audio-output-bus) has changed
        /// The host ask the plug-in for the new routing with IComponent::getRoutingInfo, @ref vst3Routing see IComponent
        /// [SDK 3.6.6]
        /// </summary>
        kRoutingInfoChanged = 1 << 9,
        
        /// <summary>
        /// Key switches has changed (info, count)
        /// Either the Key switches info, the count of Key switches has changed.
        /// The host invalidates all caches of Key switches infos and asks the edit controller (IKeyswitchController) for the current ones.
        /// See IKeyswitchController
        /// [SDK 3.7.3]
        /// </summary>
        kKeyswitchChanged = 1 << 10,
    }
    
    /// <summary>
    /// Knob Mode
    /// </summary>
    public enum KnobModes
    {
        /// <summary>
        /// Circular with jump to clicked position
        /// </summary>
        kCircularMode = 0,
        
        /// <summary>
        /// Circular without jump to clicked position
        /// </summary>
        kRelativCircularMode,
        
        /// <summary>
        /// Linear: depending on vertical movement
        /// </summary>
        kLinearMode,
    }
    
    /// <summary>
    /// NoteExpressionTypeIDs describes the type of the note expression.
    /// VST predefines some types like volume, pan, tuning by defining their ranges and curves.
    /// Used by NoteExpressionEvent::typeId and NoteExpressionTypeID::typeId
    /// </summary>
    /// <seealso cref="NoteExpressionTypeInfo"/>
    public enum NoteExpressionTypeIDs : uint
    {
        /// <summary>
        /// Volume, plain range [0 = -oo , 0.25 = 0dB, 0.5 = +6dB, 1 = +12dB]: plain = 20 * log (4 * norm)
        /// </summary>
        kVolumeTypeID = 0,
        
        /// <summary>
        /// Panning (L-R), plain range [0 = left, 0.5 = center, 1 = right]
        /// </summary>
        kPanTypeID,
        
        /// <summary>
        /// Tuning, plain range [0 = -120.0 (ten octaves down), 0.5 none, 1 = +120.0 (ten octaves up)]
        /// plain = 240 * (norm - 0.5) and norm = plain / 240 + 0.5
        /// oneOctave is 12.0 / 240.0; oneHalfTune = 1.0 / 240.0;
        /// </summary>
        kTuningTypeID,
        
        /// <summary>
        /// Vibrato
        /// </summary>
        kVibratoTypeID,
        
        /// <summary>
        /// Expression
        /// </summary>
        kExpressionTypeID,
        
        /// <summary>
        /// Brightness
        /// </summary>
        kBrightnessTypeID,
        
        /// <summary>
        /// See NoteExpressionTextEvent
        /// </summary>
        kTextTypeID,
        
        /// <summary>
        /// TODO:
        /// </summary>
        kPhonemeTypeID,
        
        /// <summary>
        /// start of custom note expression type ids
        /// </summary>
        kCustomStart = 100000,
        
        /// <summary>
        /// end of custom note expression type ids
        /// </summary>
        kCustomEnd = 200000,
        
        /// <summary>
        /// indicates an invalid note expression type
        /// </summary>
        kInvalidTypeID = 0xFFFFFFFF,
    }
    
    /// <summary>
    /// KeyswitchTypeIDs describes the type of a key switch
    /// </summary>
    /// <seealso cref="KeyswitchInfo"/>
    public enum KeyswitchTypeIDs : uint
    {
        /// <summary>
        /// press before noteOn is played
        /// </summary>
        kNoteOnKeyswitchTypeID = 0,
        
        /// <summary>
        /// press while noteOn is played
        /// </summary>
        kOnTheFlyKeyswitchTypeID,
        
        /// <summary>
        /// press before entering release
        /// </summary>
        kOnReleaseKeyswitchTypeID,
        
        /// <summary>
        /// key should be maintained pressed for playing
        /// </summary>
        kKeyRangeTypeID,
    }
    
    /// <summary>
    /// Reserved note identifier (noteId) range for a plug-in. Guaranteed not used by the host.
    /// </summary>
    public enum NoteIDUserRange
    {
        kNoteIDUserRangeLowerBound = -10000,
        
        kNoteIDUserRangeUpperBound = -1000,
    }
    
    /// <summary>
    /// Controller Numbers (MIDI)
    /// </summary>
    public enum ControllerNumbers
    {
        /// <summary>
        /// Bank Select MSB
        /// </summary>
        kCtrlBankSelectMSB = 0,
        
        /// <summary>
        /// Modulation Wheel
        /// </summary>
        kCtrlModWheel = 1,
        
        /// <summary>
        /// Breath controller
        /// </summary>
        kCtrlBreath = 2,
        
        /// <summary>
        /// Foot Controller
        /// </summary>
        kCtrlFoot = 4,
        
        /// <summary>
        /// Portamento Time
        /// </summary>
        kCtrlPortaTime = 5,
        
        /// <summary>
        /// Data Entry MSB
        /// </summary>
        kCtrlDataEntryMSB = 6,
        
        /// <summary>
        /// Channel Volume (formerly Main Volume)
        /// </summary>
        kCtrlVolume = 7,
        
        /// <summary>
        /// Balance
        /// </summary>
        kCtrlBalance = 8,
        
        /// <summary>
        /// Pan
        /// </summary>
        kCtrlPan = 10,
        
        /// <summary>
        /// Expression
        /// </summary>
        kCtrlExpression = 11,
        
        /// <summary>
        /// Effect Control 1
        /// </summary>
        kCtrlEffect1 = 12,
        
        /// <summary>
        /// Effect Control 2
        /// </summary>
        kCtrlEffect2 = 13,
        
        /// <summary>
        /// General Purpose Controller #1
        /// </summary>
        kCtrlGPC1 = 16,
        
        /// <summary>
        /// General Purpose Controller #2
        /// </summary>
        kCtrlGPC2 = 17,
        
        /// <summary>
        /// General Purpose Controller #3
        /// </summary>
        kCtrlGPC3 = 18,
        
        /// <summary>
        /// General Purpose Controller #4
        /// </summary>
        kCtrlGPC4 = 19,
        
        /// <summary>
        /// Bank Select LSB
        /// </summary>
        kCtrlBankSelectLSB = 32,
        
        /// <summary>
        /// Data Entry LSB
        /// </summary>
        kCtrlDataEntryLSB = 38,
        
        /// <summary>
        /// Damper Pedal On/Off (Sustain)
        /// </summary>
        kCtrlSustainOnOff = 64,
        
        /// <summary>
        /// Portamento On/Off
        /// </summary>
        kCtrlPortaOnOff = 65,
        
        /// <summary>
        /// Sustenuto On/Off
        /// </summary>
        kCtrlSustenutoOnOff = 66,
        
        /// <summary>
        /// Soft Pedal On/Off
        /// </summary>
        kCtrlSoftPedalOnOff = 67,
        
        /// <summary>
        /// Legato Footswitch On/Off
        /// </summary>
        kCtrlLegatoFootSwOnOff = 68,
        
        /// <summary>
        /// Hold 2 On/Off
        /// </summary>
        kCtrlHold2OnOff = 69,
        
        /// <summary>
        /// Sound Variation
        /// </summary>
        kCtrlSoundVariation = 70,
        
        /// <summary>
        /// Filter Cutoff (Timbre/Harmonic Intensity)
        /// </summary>
        kCtrlFilterCutoff = 71,
        
        /// <summary>
        /// Release Time
        /// </summary>
        kCtrlReleaseTime = 72,
        
        /// <summary>
        /// Attack Time
        /// </summary>
        kCtrlAttackTime = 73,
        
        /// <summary>
        /// Filter Resonance (Brightness)
        /// </summary>
        kCtrlFilterResonance = 74,
        
        /// <summary>
        /// Decay Time
        /// </summary>
        kCtrlDecayTime = 75,
        
        /// <summary>
        /// Vibrato Rate
        /// </summary>
        kCtrlVibratoRate = 76,
        
        /// <summary>
        /// Vibrato Depth
        /// </summary>
        kCtrlVibratoDepth = 77,
        
        /// <summary>
        /// Vibrato Delay
        /// </summary>
        kCtrlVibratoDelay = 78,
        
        /// <summary>
        /// undefined
        /// </summary>
        kCtrlSoundCtrler10 = 79,
        
        /// <summary>
        /// General Purpose Controller #5
        /// </summary>
        kCtrlGPC5 = 80,
        
        /// <summary>
        /// General Purpose Controller #6
        /// </summary>
        kCtrlGPC6 = 81,
        
        /// <summary>
        /// General Purpose Controller #7
        /// </summary>
        kCtrlGPC7 = 82,
        
        /// <summary>
        /// General Purpose Controller #8
        /// </summary>
        kCtrlGPC8 = 83,
        
        /// <summary>
        /// Portamento Control
        /// </summary>
        kCtrlPortaControl = 84,
        
        /// <summary>
        /// Effect 1 Depth (Reverb Send Level)
        /// </summary>
        kCtrlEff1Depth = 91,
        
        /// <summary>
        /// Effect 2 Depth (Tremolo Level)
        /// </summary>
        kCtrlEff2Depth = 92,
        
        /// <summary>
        /// Effect 3 Depth (Chorus Send Level)
        /// </summary>
        kCtrlEff3Depth = 93,
        
        /// <summary>
        /// Effect 4 Depth (Delay/Variation/Detune Level)
        /// </summary>
        kCtrlEff4Depth = 94,
        
        /// <summary>
        /// Effect 5 Depth (Phaser Level)
        /// </summary>
        kCtrlEff5Depth = 95,
        
        /// <summary>
        /// Data Increment (+1)
        /// </summary>
        kCtrlDataIncrement = 96,
        
        /// <summary>
        /// Data Decrement (-1)
        /// </summary>
        kCtrlDataDecrement = 97,
        
        /// <summary>
        /// NRPN Select LSB
        /// </summary>
        kCtrlNRPNSelectLSB = 98,
        
        /// <summary>
        /// NRPN Select MSB
        /// </summary>
        kCtrlNRPNSelectMSB = 99,
        
        /// <summary>
        /// RPN Select LSB
        /// </summary>
        kCtrlRPNSelectLSB = 100,
        
        /// <summary>
        /// RPN Select MSB
        /// </summary>
        kCtrlRPNSelectMSB = 101,
        
        /// <summary>
        /// All Sounds Off
        /// </summary>
        kCtrlAllSoundsOff = 120,
        
        /// <summary>
        /// Reset All Controllers
        /// </summary>
        kCtrlResetAllCtrlers = 121,
        
        /// <summary>
        /// Local Control On/Off
        /// </summary>
        kCtrlLocalCtrlOnOff = 122,
        
        /// <summary>
        /// All Notes Off
        /// </summary>
        kCtrlAllNotesOff = 123,
        
        /// <summary>
        /// Omni Mode Off + All Notes Off
        /// </summary>
        kCtrlOmniModeOff = 124,
        
        /// <summary>
        /// Omni Mode On  + All Notes Off
        /// </summary>
        kCtrlOmniModeOn = 125,
        
        /// <summary>
        /// Poly Mode On/Off + All Sounds Off
        /// </summary>
        kCtrlPolyModeOnOff = 126,
        
        /// <summary>
        /// Poly Mode On
        /// </summary>
        kCtrlPolyModeOn = 127,
        
        /// <summary>
        /// After Touch (associated to Channel Pressure)
        /// </summary>
        kAfterTouch = 128,
        
        /// <summary>
        /// Pitch Bend Change
        /// </summary>
        kPitchBend = 129,
        
        /// <summary>
        /// Count of Controller Number
        /// </summary>
        kCountCtrlNumber,
        
        /// <summary>
        /// Program Change (use LegacyMIDICCOutEvent.value only)
        /// </summary>
        kCtrlProgramChange = 130,
        
        /// <summary>
        /// Polyphonic Key Pressure (use LegacyMIDICCOutEvent.value for pitch and
        /// </summary>
        kCtrlPolyPressure = 131,
        
        /// <summary>
        /// Quarter Frame ((use LegacyMIDICCOutEvent.value only)
        /// </summary>
        kCtrlQuarterFrame = 132,
    }
    
    /// <summary>
    /// PhysicalUITypeIDs describes the type of Physical UI (PUI) which could be associated to a note
    /// expression.
    /// </summary>
    /// <seealso cref="PhysicalUIMap"/>
    public enum PhysicalUITypeIDs
    {
        /// <summary>
        /// absolute X position when touching keys of PUIs. Range [0=left, 0.5=middle, 1=right]
        /// </summary>
        kPUIXMovement = 0,
        
        /// <summary>
        /// absolute Y position when touching keys of PUIs. Range [0=bottom/near, 0.5=center, 1=top/far]
        /// </summary>
        kPUIYMovement,
        
        /// <summary>
        /// pressing a key down on keys of PUIs. Range [0=No Pressure, 1=Full Pressure]
        /// </summary>
        kPUIPressure,
        
        /// <summary>
        /// count of current defined PUIs
        /// </summary>
        kPUITypeCount,
        
        /// <summary>
        /// indicates an invalid or not initialized PUI type
        /// </summary>
        kInvalidPUITypeID = -1,
    }
    
    /// <summary>
    /// Prefetchable Support Enum
    /// </summary>
    public enum ePrefetchableSupport
    {
        /// <summary>
        /// every instance of the plug does not support prefetch processing
        /// </summary>
        kIsNeverPrefetchable = 0,
        
        /// <summary>
        /// in the current state the plug support prefetch processing
        /// </summary>
        kIsYetPrefetchable,
        
        /// <summary>
        /// in the current state the plug does not support prefetch processing
        /// </summary>
        kIsNotYetPrefetchable,
        
        kNumPrefetchableSupport,
    }
    
    /// <summary>
    /// Channel context interface: Vst::IInfoListener
    /// </summary>
    /// <remarks>
    ///  vstIHost vst365- [plug imp]
    /// - [extends IEditController]
    /// - [released: 3.6.5]
    /// - [optional]Allows the host to inform the plug-in about the context in which the plug-in is instantiated,
    /// mainly channel based info (color, name, index,...). Index can be defined inside a namespace 
    /// (for example, index start from 1 to N for Type Input/Output Channel (Index namespace) and index 
    /// start from 1 to M for Type Audio Channel).@n As soon as the plug-in provides this IInfoListener interface, the host will call setChannelContextInfos 
    /// for each change occurring to this channel (new name, new color, new indexation,...) IChannelContextExample Example@code {.cpp}
    /// //------------------------------------------------------------------------
    /// tresult PLUGIN_API MyPlugin::setChannelContextInfos (IAttributeList* list)
    /// {
    /// 	if (list)
    /// 	{
    /// 		// optional we can ask for the Channel Name Length
    /// 		int64 length;
    /// 		if (list-&gt;getInt (ChannelContext::kChannelNameLengthKey, length) == kResultTrue)
    /// 		{
    /// 			...
    /// 		}
    /// 		
    /// 		// get the Channel Name where we, as plug-in, are instantiated
    /// 		String128 name;
    /// 		if (list-&gt;getString (ChannelContext::kChannelNameKey, name, sizeof (name)) == kResultTrue)
    /// 		{
    /// 			...
    /// 		}
    /// 
    /// 		// get the Channel UID
    /// 		if (list-&gt;getString (ChannelContext::kChannelUIDKey, name, sizeof (name)) == kResultTrue)
    /// 		{
    /// 			...
    /// 		}
    /// 		
    /// 		// get Channel Index
    /// 		int64 index;
    /// 		if (list-&gt;getInt (ChannelContext::kChannelIndexKey, index) == kResultTrue)
    /// 		{
    /// 			...
    /// 		}
    /// 		
    /// 		// get the Channel Color
    /// 		int64 color;
    /// 		if (list-&gt;getInt (ChannelContext::kChannelColorKey, color) == kResultTrue)
    /// 		{
    /// 			uint32 channelColor = (uint32)color;
    /// 			String str;
    /// 			str.printf ("%x%x%x%x", ChannelContext::GetAlpha (channelColor),
    /// 			ChannelContext::GetRed (channelColor),
    /// 			ChannelContext::GetGreen (channelColor),
    /// 			ChannelContext::GetBlue (channelColor));
    /// 			String128 string128;
    /// 			Steinberg::UString (string128, 128).fromAscii (str);
    /// 			...
    /// 		}
    /// 
    /// 		// get Channel Index Namespace Order of the current used index namespace
    /// 		if (list-&gt;getInt (ChannelContext::kChannelIndexNamespaceOrderKey, index) == kResultTrue)
    /// 		{
    /// 			...
    /// 		}
    /// 	
    /// 		// get the channel Index Namespace Length
    /// 		if (list-&gt;getInt (ChannelContext::kChannelIndexNamespaceLengthKey, length) == kResultTrue)
    /// 		{
    /// 			...
    /// 		}
    /// 		
    /// 		// get the channel Index Namespace
    /// 		String128 namespaceName;
    /// 		if (list-&gt;getString (ChannelContext::kChannelIndexNamespaceKey, namespaceName, sizeof (namespaceName)) == kResultTrue)
    /// 		{
    /// 			...
    /// 		}
    /// 
    /// 		// get plug-in Channel Location
    /// 		int64 location;
    /// 		if (list-&gt;getInt (ChannelContext::kChannelPluginLocationKey, location) == kResultTrue)
    /// 		{
    /// 			String128 string128;
    /// 			switch (location)
    /// 			{
    /// 				case ChannelContext::kPreVolumeFader:
    /// 					Steinberg::UString (string128, 128).fromAscii ("PreVolFader");
    /// 				break;
    /// 				case ChannelContext::kPostVolumeFader:
    /// 					Steinberg::UString (string128, 128).fromAscii ("PostVolFader");
    /// 				break;
    /// 				case ChannelContext::kUsedAsPanner:
    /// 					Steinberg::UString (string128, 128).fromAscii ("UsedAsPanner");
    /// 				break;
    /// 				default: Steinberg::UString (string128, 128).fromAscii ("unknown!");
    /// 				break;
    /// 			}
    /// 		}
    /// 		
    /// 		// do not forget to call addRef () if you want to keep this list
    /// 	}
    /// }
    /// @endcode
    /// </remarks>
    public unsafe partial struct IInfoListener : INativeGuid, INativeUnknown, INativeVtbl
    {
        public static Guid* NativeGuid => (Guid*)Unsafe.AsPointer(ref Unsafe.AsRef(in IId));
        
        public void** Vtbl;
        
        public static int VtblCount => 4;
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void InitializeVtbl(void** vtbl)
        {
            FUnknown.InitializeVtbl(vtbl);
            vtbl[3] = (delegate*unmanaged[MemberFunction]<IInfoListener*, LibVst.IAttributeList*, int>)&setChannelContextInfos_Wrapper;
        }
        
        // --------------------------------------------------------------
        // RCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Query for a pointer to the specified interface.
        /// Returns kResultOk on success or kNoInterface if the object does not implement the interface.
        /// The object has to call addRef when returning an interface.
        /// </summary>
        /// <param name="obj">: (out) On return, *obj points to the requested interface</param>
        /// <param name="_iid">: (in) 16 Byte interface identifier (-&gt; FUID)</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult queryInterface(Guid* _iid, void** obj)
        {
            return Unsafe.As<IInfoListener, FUnknown>(ref this).queryInterface(_iid, obj);
        }
        
        /// <summary>
        /// Adds a reference and returns the new reference count.
        /// </summary>
        /// <par>
        /// Remarks:
        /// The initial reference count after creating an object is 1.
        /// </par>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint addRef()
        {
            return Unsafe.As<IInfoListener, FUnknown>(ref this).addRef();
        }
        
        /// <summary>
        /// Releases a reference and returns the new reference count.
        /// If the reference count reaches zero, the object will be destroyed in memory.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public uint release()
        {
            return Unsafe.As<IInfoListener, FUnknown>(ref this).release();
        }
        
        /// <summary>
        /// Receive the channel context infos from host.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ComResult setChannelContextInfos(LibVst.IAttributeList* list)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __self__ = (LibVst.IInfoListener*)Unsafe.AsPointer(ref this);
                var __evt__ = new ManagedToNativeEvent((IntPtr)__self__, nameof(IInfoListener), "setChannelContextInfos");
                var __result__ = ((delegate*unmanaged[MemberFunction]<LibVst.IInfoListener*, LibVst.IAttributeList*, int>)Vtbl[3])(__self__, list);
                __evt__.Result = __result__;
                __evt__.Dispose();
                return __result__;
            }
            else
            {
                return ((delegate*unmanaged[MemberFunction]<LibVst.IInfoListener*, LibVst.IAttributeList*, int>)Vtbl[3])((LibVst.IInfoListener*)Unsafe.AsPointer(ref this), list);
            }
        }
        
        // --------------------------------------------------------------
        // CCW methods
        // --------------------------------------------------------------
        /// <summary>
        /// Receive the channel context infos from host.
        /// </summary>
        private static partial ComResult setChannelContextInfos_ToManaged(IInfoListener* self, LibVst.IAttributeList* list);
        
        [UnmanagedCallersOnly(CallConvs = new Type[] { typeof(CallConvMemberFunction)})]
        private static int setChannelContextInfos_Wrapper(IInfoListener* self, LibVst.IAttributeList* list)
        {
            if (InteropHelper.IsTracerEnabled)
            {
                var __evt__ = new NativeToManagedEvent((IntPtr)self, nameof(IInfoListener), "setChannelContextInfos");
                try
                {
                    return setChannelContextInfos_ToManaged(self, list);
                }
                catch (Exception ex)
                {
                    __evt__.Exception = ex;
                    return (ComResult)ex;
                }
                finally
                {
                    __evt__.Dispose();
                }
            }
            else
            {
                try
                {
                    return setChannelContextInfos_ToManaged(self, list);
                }
                catch (Exception ex)
                {
                    return (ComResult)ex;
                }
            }
        }
        
        /// <summary>
        /// DECLARE_CLASS_IID (IInfoListener, 0x0F194781, 0x8D984ADA, 0xBBA0C1EF, 0xC011D8D0)
        /// </summary>
        public static ref readonly Guid IId
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                return ref Unsafe.As<byte, Guid>(ref MemoryMarshal.GetReference((OperatingSystem.IsWindows()
                        ? new ReadOnlySpan<byte>(new byte[] { 0x81, 0x47, 0x19, 0x0f, 0x98, 0x8d, 0xda, 0x4a, 0xbb, 0xa0, 0xc1, 0xef, 0xc0, 0x11, 0xd8, 0xd0 })
                        : new ReadOnlySpan<byte>(new byte[] { 0x0f, 0x19, 0x47, 0x81, 0x8d, 0x98, 0x4a, 0xda, 0xbb, 0xa0, 0xc1, 0xef, 0xc0, 0x11, 0xd8, 0xd0 })
                    )));
            }
        }
    }
    
    /// <summary>
    /// Values used for kChannelPluginLocationKey
    /// </summary>
    public enum ChannelPluginLocation
    {
        kPreVolumeFader = 0,
        
        kPostVolumeFader,
        
        kUsedAsPanner,
    }
    
    public enum ivstrepresentation
    {
        /// <summary>
        /// a knob (encoder or not)
        /// </summary>
        kKnob = 0,
        
        /// <summary>
        /// a knob which is used by pressing and turning
        /// </summary>
        kPressedKnob,
        
        /// <summary>
        /// knob could be pressed to simulate a switch
        /// </summary>
        kSwitchKnob,
        
        /// <summary>
        /// a "on/off" button
        /// </summary>
        kSwitch,
        
        /// <summary>
        /// LED like VU-meter or display around a knob
        /// </summary>
        kLED,
        
        /// <summary>
        /// indicates that this layer is a folder linked to an another INode (page)
        /// </summary>
        kLink,
        
        /// <summary>
        /// only for text display (not really a control)
        /// </summary>
        kDisplay,
        
        /// <summary>
        /// a fader
        /// </summary>
        kFader,
        
        kEndOfLayerType,
    }
    
    public const string kPlatformStringWin = "WIN";
    
    public static ReadOnlySpan<byte> kPlatformStringWin_u8 => "WIN\0"u8;
    
    public const string kPlatformStringMac = "MAC";
    
    public static ReadOnlySpan<byte> kPlatformStringMac_u8 => "MAC\0"u8;
    
    public const string kPlatformStringIOS = "IOS";
    
    public static ReadOnlySpan<byte> kPlatformStringIOS_u8 => "IOS\0"u8;
    
    public const string kPlatformStringLinux = "Linux";
    
    public static ReadOnlySpan<byte> kPlatformStringLinux_u8 => "Linux\0"u8;
    
    /// <summary>
    /// HWND handle. (Microsoft Windows)
    /// </summary>
    public const string kPlatformTypeHWND = "HWND";
    
    /// <summary>
    /// HWND handle. (Microsoft Windows)
    /// </summary>
    public static ReadOnlySpan<byte> kPlatformTypeHWND_u8 => "HWND\0"u8;
    
    /// <summary>
    /// HIViewRef. (Mac OS X)
    /// </summary>
    public const string kPlatformTypeHIView = "HIView";
    
    /// <summary>
    /// HIViewRef. (Mac OS X)
    /// </summary>
    public static ReadOnlySpan<byte> kPlatformTypeHIView_u8 => "HIView\0"u8;
    
    /// <summary>
    /// NSView pointer. (Mac OS X)
    /// </summary>
    public const string kPlatformTypeNSView = "NSView";
    
    /// <summary>
    /// NSView pointer. (Mac OS X)
    /// </summary>
    public static ReadOnlySpan<byte> kPlatformTypeNSView_u8 => "NSView\0"u8;
    
    /// <summary>
    /// UIView pointer. (iOS)
    /// </summary>
    public const string kPlatformTypeUIView = "UIView";
    
    /// <summary>
    /// UIView pointer. (iOS)
    /// </summary>
    public static ReadOnlySpan<byte> kPlatformTypeUIView_u8 => "UIView\0"u8;
    
    /// <summary>
    /// X11 Window ID. (X11)
    /// </summary>
    public const string kPlatformTypeX11EmbedWindowID = "X11EmbedWindowID";
    
    /// <summary>
    /// X11 Window ID. (X11)
    /// </summary>
    public static ReadOnlySpan<byte> kPlatformTypeX11EmbedWindowID_u8 => "X11EmbedWindowID\0"u8;
    
    /// <summary>
    /// @
    /// }
    /// </summary>
    public const string SDKVersionString = "VST 3.7.7";
    
    /// <summary>
    /// @
    /// }
    /// </summary>
    public static ReadOnlySpan<byte> SDKVersionString_u8 => "VST 3.7.7\0"u8;
    
    public static partial class SpeakerArr
    {
        /// <summary>
        /// Speaker Arrangement String Representation.
        /// </summary>
        /// <remarks>
        ///  speakerArrangements@
        /// {
        /// </remarks>
        public const string kStringEmpty = "";
        
        /// <summary>
        /// Speaker Arrangement String Representation.
        /// </summary>
        /// <remarks>
        ///  speakerArrangements@
        /// {
        /// </remarks>
        public static ReadOnlySpan<byte> kStringEmpty_u8 => "\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringMono = "Mono";
        
        public static ReadOnlySpan<byte> kStringMono_u8 => "Mono\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereo = "Stereo";
        
        public static ReadOnlySpan<byte> kStringStereo_u8 => "Stereo\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoR = "Stereo (Ls Rs)";
        
        public static ReadOnlySpan<byte> kStringStereoR_u8 => "Stereo (Ls Rs)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoC = "Stereo (Lc Rc)";
        
        public static ReadOnlySpan<byte> kStringStereoC_u8 => "Stereo (Lc Rc)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoSide = "Stereo (Sl Sr)";
        
        public static ReadOnlySpan<byte> kStringStereoSide_u8 => "Stereo (Sl Sr)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoCLfe = "Stereo (C LFE)";
        
        public static ReadOnlySpan<byte> kStringStereoCLfe_u8 => "Stereo (C LFE)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoTF = "Stereo (Tfl Tfr)";
        
        public static ReadOnlySpan<byte> kStringStereoTF_u8 => "Stereo (Tfl Tfr)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoTS = "Stereo (Tsl Tsr)";
        
        public static ReadOnlySpan<byte> kStringStereoTS_u8 => "Stereo (Tsl Tsr)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoTR = "Stereo (Trl Trr)";
        
        public static ReadOnlySpan<byte> kStringStereoTR_u8 => "Stereo (Trl Trr)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoBF = "Stereo (Bfl Bfr)";
        
        public static ReadOnlySpan<byte> kStringStereoBF_u8 => "Stereo (Bfl Bfr)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringCineFront = "Cine Front";
        
        public static ReadOnlySpan<byte> kStringCineFront_u8 => "Cine Front\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString30Cine = "LRC";
        
        public static ReadOnlySpan<byte> kString30Cine_u8 => "LRC\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString30Music = "LRS";
        
        public static ReadOnlySpan<byte> kString30Music_u8 => "LRS\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString31Cine = "LRC+LFE";
        
        public static ReadOnlySpan<byte> kString31Cine_u8 => "LRC+LFE\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString31Music = "LRS+LFE";
        
        public static ReadOnlySpan<byte> kString31Music_u8 => "LRS+LFE\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString40Cine = "LRCS";
        
        public static ReadOnlySpan<byte> kString40Cine_u8 => "LRCS\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString40Music = "Quadro";
        
        public static ReadOnlySpan<byte> kString40Music_u8 => "Quadro\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString41Cine = "LRCS+LFE";
        
        public static ReadOnlySpan<byte> kString41Cine_u8 => "LRCS+LFE\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString41Music = "Quadro+LFE";
        
        public static ReadOnlySpan<byte> kString41Music_u8 => "Quadro+LFE\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString50 = "5.0";
        
        public static ReadOnlySpan<byte> kString50_u8 => "5.0\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString51 = "5.1";
        
        public static ReadOnlySpan<byte> kString51_u8 => "5.1\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString60Cine = "6.0 Cine";
        
        public static ReadOnlySpan<byte> kString60Cine_u8 => "6.0 Cine\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString60Music = "6.0 Music";
        
        public static ReadOnlySpan<byte> kString60Music_u8 => "6.0 Music\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString61Cine = "6.1 Cine";
        
        public static ReadOnlySpan<byte> kString61Cine_u8 => "6.1 Cine\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString61Music = "6.1 Music";
        
        public static ReadOnlySpan<byte> kString61Music_u8 => "6.1 Music\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70Cine = "7.0 SDDS";
        
        public static ReadOnlySpan<byte> kString70Cine_u8 => "7.0 SDDS\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70CineOld = "7.0 Cine (SDDS)";
        
        public static ReadOnlySpan<byte> kString70CineOld_u8 => "7.0 Cine (SDDS)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70Music = "7.0";
        
        public static ReadOnlySpan<byte> kString70Music_u8 => "7.0\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70MusicOld = "7.0 Music (Dolby)";
        
        public static ReadOnlySpan<byte> kString70MusicOld_u8 => "7.0 Music (Dolby)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71Cine = "7.1 SDDS";
        
        public static ReadOnlySpan<byte> kString71Cine_u8 => "7.1 SDDS\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineOld = "7.1 Cine (SDDS)";
        
        public static ReadOnlySpan<byte> kString71CineOld_u8 => "7.1 Cine (SDDS)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71Music = "7.1";
        
        public static ReadOnlySpan<byte> kString71Music_u8 => "7.1\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71MusicOld = "7.1 Music (Dolby)";
        
        public static ReadOnlySpan<byte> kString71MusicOld_u8 => "7.1 Music (Dolby)\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineTopCenter = "7.1 Cine Top Center";
        
        public static ReadOnlySpan<byte> kString71CineTopCenter_u8 => "7.1 Cine Top Center\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineCenterHigh = "7.1 Cine Center High";
        
        public static ReadOnlySpan<byte> kString71CineCenterHigh_u8 => "7.1 Cine Center High\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineFrontHigh = "7.1 Cine Front High";
        
        public static ReadOnlySpan<byte> kString71CineFrontHigh_u8 => "7.1 Cine Front High\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70CineFrontHigh = "7.0 Cine Front High";
        
        public static ReadOnlySpan<byte> kString70CineFrontHigh_u8 => "7.0 Cine Front High\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineSideHigh = "7.1 Cine Side High";
        
        public static ReadOnlySpan<byte> kString71CineSideHigh_u8 => "7.1 Cine Side High\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineFullRear = "7.1 Cine Full Rear";
        
        public static ReadOnlySpan<byte> kString71CineFullRear_u8 => "7.1 Cine Full Rear\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71Proximity = "7.1 Proximity";
        
        public static ReadOnlySpan<byte> kString71Proximity_u8 => "7.1 Proximity\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString80Cine = "8.0 Cine";
        
        public static ReadOnlySpan<byte> kString80Cine_u8 => "8.0 Cine\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString80Music = "8.0 Music";
        
        public static ReadOnlySpan<byte> kString80Music_u8 => "8.0 Music\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString80Cube = "8.0 Cube";
        
        public static ReadOnlySpan<byte> kString80Cube_u8 => "8.0 Cube\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString81Cine = "8.1 Cine";
        
        public static ReadOnlySpan<byte> kString81Cine_u8 => "8.1 Cine\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString81Music = "8.1 Music";
        
        public static ReadOnlySpan<byte> kString81Music_u8 => "8.1 Music\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString90Cine = "9.0 Cine";
        
        public static ReadOnlySpan<byte> kString90Cine_u8 => "9.0 Cine\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString91Cine = "9.1 Cine";
        
        public static ReadOnlySpan<byte> kString91Cine_u8 => "9.1 Cine\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString100Cine = "10.0 Cine";
        
        public static ReadOnlySpan<byte> kString100Cine_u8 => "10.0 Cine\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString101Cine = "10.1 Cine";
        
        public static ReadOnlySpan<byte> kString101Cine_u8 => "10.1 Cine\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString102 = "10.2 Experimental";
        
        public static ReadOnlySpan<byte> kString102_u8 => "10.2 Experimental\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString122 = "12.2";
        
        public static ReadOnlySpan<byte> kString122_u8 => "12.2\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString50_4 = "5.0.4";
        
        public static ReadOnlySpan<byte> kString50_4_u8 => "5.0.4\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString51_4 = "5.1.4";
        
        public static ReadOnlySpan<byte> kString51_4_u8 => "5.1.4\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString50_4_1 = "5.0.4.1";
        
        public static ReadOnlySpan<byte> kString50_4_1_u8 => "5.0.4.1\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString51_4_1 = "5.1.4.1";
        
        public static ReadOnlySpan<byte> kString51_4_1_u8 => "5.1.4.1\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70_2 = "7.0.2";
        
        public static ReadOnlySpan<byte> kString70_2_u8 => "7.0.2\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71_2 = "7.1.2";
        
        public static ReadOnlySpan<byte> kString71_2_u8 => "7.1.2\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70_3 = "7.0.3";
        
        public static ReadOnlySpan<byte> kString70_3_u8 => "7.0.3\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString72_3 = "7.2.3";
        
        public static ReadOnlySpan<byte> kString72_3_u8 => "7.2.3\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70_4 = "7.0.4";
        
        public static ReadOnlySpan<byte> kString70_4_u8 => "7.0.4\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71_4 = "7.1.4";
        
        public static ReadOnlySpan<byte> kString71_4_u8 => "7.1.4\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70_6 = "7.0.6";
        
        public static ReadOnlySpan<byte> kString70_6_u8 => "7.0.6\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71_6 = "7.1.6";
        
        public static ReadOnlySpan<byte> kString71_6_u8 => "7.1.6\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString90_4 = "9.0.4";
        
        public static ReadOnlySpan<byte> kString90_4_u8 => "9.0.4\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString91_4 = "9.1.4";
        
        public static ReadOnlySpan<byte> kString91_4_u8 => "9.1.4\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString90_6 = "9.0.6";
        
        public static ReadOnlySpan<byte> kString90_6_u8 => "9.0.6\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString91_6 = "9.1.6";
        
        public static ReadOnlySpan<byte> kString91_6_u8 => "9.1.6\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString100 = "10.0 Auro-3D";
        
        public static ReadOnlySpan<byte> kString100_u8 => "10.0 Auro-3D\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString101 = "10.1 Auro-3D";
        
        public static ReadOnlySpan<byte> kString101_u8 => "10.1 Auro-3D\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString110 = "11.0 Auro-3D";
        
        public static ReadOnlySpan<byte> kString110_u8 => "11.0 Auro-3D\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString111 = "11.1 Auro-3D";
        
        public static ReadOnlySpan<byte> kString111_u8 => "11.1 Auro-3D\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString130 = "13.0 Auro-3D";
        
        public static ReadOnlySpan<byte> kString130_u8 => "13.0 Auro-3D\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString131 = "13.1 Auro-3D";
        
        public static ReadOnlySpan<byte> kString131_u8 => "13.1 Auro-3D\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString81MPEG = "8.1 MPEG";
        
        public static ReadOnlySpan<byte> kString81MPEG_u8 => "8.1 MPEG\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString140 = "14.0";
        
        public static ReadOnlySpan<byte> kString140_u8 => "14.0\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString222 = "22.2";
        
        public static ReadOnlySpan<byte> kString222_u8 => "22.2\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString220 = "22.0";
        
        public static ReadOnlySpan<byte> kString220_u8 => "22.0\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString50_5_3 = "5.0.5.3";
        
        public static ReadOnlySpan<byte> kString50_5_3_u8 => "5.0.5.3\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString51_5_3 = "5.1.5.3";
        
        public static ReadOnlySpan<byte> kString51_5_3_u8 => "5.1.5.3\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringAmbi1stOrder = "1st Order Ambisonics";
        
        public static ReadOnlySpan<byte> kStringAmbi1stOrder_u8 => "1st Order Ambisonics\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringAmbi2cdOrder = "2nd Order Ambisonics";
        
        public static ReadOnlySpan<byte> kStringAmbi2cdOrder_u8 => "2nd Order Ambisonics\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringAmbi3rdOrder = "3rd Order Ambisonics";
        
        public static ReadOnlySpan<byte> kStringAmbi3rdOrder_u8 => "3rd Order Ambisonics\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        /// <summary>
        /// Speaker Arrangement String Representation with Speakers Name.
        /// </summary>
        /// <remarks>
        ///  speakerArrangements@
        /// {
        /// </remarks>
        public const string kStringMonoS = "M";
        
        /// <summary>
        /// Speaker Arrangement String Representation with Speakers Name.
        /// </summary>
        /// <remarks>
        ///  speakerArrangements@
        /// {
        /// </remarks>
        public static ReadOnlySpan<byte> kStringMonoS_u8 => "M\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoS = "L R";
        
        public static ReadOnlySpan<byte> kStringStereoS_u8 => "L R\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoRS = "Ls Rs";
        
        public static ReadOnlySpan<byte> kStringStereoRS_u8 => "Ls Rs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoCS = "Lc Rc";
        
        public static ReadOnlySpan<byte> kStringStereoCS_u8 => "Lc Rc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoSS = "Sl Sr";
        
        public static ReadOnlySpan<byte> kStringStereoSS_u8 => "Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoCLfeS = "C LFE";
        
        public static ReadOnlySpan<byte> kStringStereoCLfeS_u8 => "C LFE\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoTFS = "Tfl Tfr";
        
        public static ReadOnlySpan<byte> kStringStereoTFS_u8 => "Tfl Tfr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoTSS = "Tsl Tsr";
        
        public static ReadOnlySpan<byte> kStringStereoTSS_u8 => "Tsl Tsr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoTRS = "Trl Trr";
        
        public static ReadOnlySpan<byte> kStringStereoTRS_u8 => "Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringStereoBFS = "Bfl Bfr";
        
        public static ReadOnlySpan<byte> kStringStereoBFS_u8 => "Bfl Bfr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringCineFrontS = "L R C Lc Rc";
        
        public static ReadOnlySpan<byte> kStringCineFrontS_u8 => "L R C Lc Rc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString30CineS = "L R C";
        
        public static ReadOnlySpan<byte> kString30CineS_u8 => "L R C\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString30MusicS = "L R S";
        
        public static ReadOnlySpan<byte> kString30MusicS_u8 => "L R S\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString31CineS = "L R C LFE";
        
        public static ReadOnlySpan<byte> kString31CineS_u8 => "L R C LFE\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString31MusicS = "L R LFE S";
        
        public static ReadOnlySpan<byte> kString31MusicS_u8 => "L R LFE S\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString40CineS = "L R C S";
        
        public static ReadOnlySpan<byte> kString40CineS_u8 => "L R C S\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString40MusicS = "L R Ls Rs";
        
        public static ReadOnlySpan<byte> kString40MusicS_u8 => "L R Ls Rs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString41CineS = "L R C LFE S";
        
        public static ReadOnlySpan<byte> kString41CineS_u8 => "L R C LFE S\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString41MusicS = "L R LFE Ls Rs";
        
        public static ReadOnlySpan<byte> kString41MusicS_u8 => "L R LFE Ls Rs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString50S = "L R C Ls Rs";
        
        public static ReadOnlySpan<byte> kString50S_u8 => "L R C Ls Rs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString51S = "L R C LFE Ls Rs";
        
        public static ReadOnlySpan<byte> kString51S_u8 => "L R C LFE Ls Rs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString60CineS = "L R C Ls Rs Cs";
        
        public static ReadOnlySpan<byte> kString60CineS_u8 => "L R C Ls Rs Cs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString60MusicS = "L R Ls Rs Sl Sr";
        
        public static ReadOnlySpan<byte> kString60MusicS_u8 => "L R Ls Rs Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString61CineS = "L R C LFE Ls Rs Cs";
        
        public static ReadOnlySpan<byte> kString61CineS_u8 => "L R C LFE Ls Rs Cs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString61MusicS = "L R LFE Ls Rs Sl Sr";
        
        public static ReadOnlySpan<byte> kString61MusicS_u8 => "L R LFE Ls Rs Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70CineS = "L R C Ls Rs Lc Rc";
        
        public static ReadOnlySpan<byte> kString70CineS_u8 => "L R C Ls Rs Lc Rc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70MusicS = "L R C Ls Rs Sl Sr";
        
        public static ReadOnlySpan<byte> kString70MusicS_u8 => "L R C Ls Rs Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineS = "L R C LFE Ls Rs Lc Rc";
        
        public static ReadOnlySpan<byte> kString71CineS_u8 => "L R C LFE Ls Rs Lc Rc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71MusicS = "L R C LFE Ls Rs Sl Sr";
        
        public static ReadOnlySpan<byte> kString71MusicS_u8 => "L R C LFE Ls Rs Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString80CineS = "L R C Ls Rs Lc Rc Cs";
        
        public static ReadOnlySpan<byte> kString80CineS_u8 => "L R C Ls Rs Lc Rc Cs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString80MusicS = "L R C Ls Rs Cs Sl Sr";
        
        public static ReadOnlySpan<byte> kString80MusicS_u8 => "L R C Ls Rs Cs Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString81CineS = "L R C LFE Ls Rs Lc Rc Cs";
        
        public static ReadOnlySpan<byte> kString81CineS_u8 => "L R C LFE Ls Rs Lc Rc Cs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString81MusicS = "L R C LFE Ls Rs Cs Sl Sr";
        
        public static ReadOnlySpan<byte> kString81MusicS_u8 => "L R C LFE Ls Rs Cs Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString80CubeS = "L R Ls Rs Tfl Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString80CubeS_u8 => "L R Ls Rs Tfl Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineTopCenterS = "L R C LFE Ls Rs Cs Tc";
        
        public static ReadOnlySpan<byte> kString71CineTopCenterS_u8 => "L R C LFE Ls Rs Cs Tc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineCenterHighS = "L R C LFE Ls Rs Cs Tfc";
        
        public static ReadOnlySpan<byte> kString71CineCenterHighS_u8 => "L R C LFE Ls Rs Cs Tfc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineFrontHighS = "L R C LFE Ls Rs Tfl Tfr";
        
        public static ReadOnlySpan<byte> kString71CineFrontHighS_u8 => "L R C LFE Ls Rs Tfl Tfr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70CineFrontHighS = "L R C Ls Rs Tfl Tfr";
        
        public static ReadOnlySpan<byte> kString70CineFrontHighS_u8 => "L R C Ls Rs Tfl Tfr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineSideHighS = "L R C LFE Ls Rs Tsl Tsr";
        
        public static ReadOnlySpan<byte> kString71CineSideHighS_u8 => "L R C LFE Ls Rs Tsl Tsr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71CineFullRearS = "L R C LFE Ls Rs Lcs Rcs";
        
        public static ReadOnlySpan<byte> kString71CineFullRearS_u8 => "L R C LFE Ls Rs Lcs Rcs\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71ProximityS = "L R C LFE Ls Rs Pl Pr";
        
        public static ReadOnlySpan<byte> kString71ProximityS_u8 => "L R C LFE Ls Rs Pl Pr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString90CineS = "L R C Ls Rs Lc Rc Sl Sr";
        
        public static ReadOnlySpan<byte> kString90CineS_u8 => "L R C Ls Rs Lc Rc Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString91CineS = "L R C LFE Ls Rs Lc Rc Sl Sr";
        
        public static ReadOnlySpan<byte> kString91CineS_u8 => "L R C LFE Ls Rs Lc Rc Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString100CineS = "L R C Ls Rs Lc Rc Cs Sl Sr";
        
        public static ReadOnlySpan<byte> kString100CineS_u8 => "L R C Ls Rs Lc Rc Cs Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString101CineS = "L R C LFE Ls Rs Lc Rc Cs Sl Sr";
        
        public static ReadOnlySpan<byte> kString101CineS_u8 => "L R C LFE Ls Rs Lc Rc Cs Sl Sr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString50_4S = "L R C Ls Rs Tfl Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString50_4S_u8 => "L R C Ls Rs Tfl Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString51_4S = "L R C LFE Ls Rs Tfl Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString51_4S_u8 => "L R C LFE Ls Rs Tfl Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString50_4_1S = "L R C Ls Rs Tfl Tfr Trl Trr Bfc";
        
        public static ReadOnlySpan<byte> kString50_4_1S_u8 => "L R C Ls Rs Tfl Tfr Trl Trr Bfc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString51_4_1S = "L R C LFE Ls Rs Tfl Tfr Trl Trr Bfc";
        
        public static ReadOnlySpan<byte> kString51_4_1S_u8 => "L R C LFE Ls Rs Tfl Tfr Trl Trr Bfc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70_2S = "L R C Ls Rs Sl Sr Tsl Tsr";
        
        public static ReadOnlySpan<byte> kString70_2S_u8 => "L R C Ls Rs Sl Sr Tsl Tsr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71_2S = "L R C LFE Ls Rs Sl Sr Tsl Tsr";
        
        public static ReadOnlySpan<byte> kString71_2S_u8 => "L R C LFE Ls Rs Sl Sr Tsl Tsr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70_3S = "L R C Ls Rs Sl Sr Tfl Tfr Trc";
        
        public static ReadOnlySpan<byte> kString70_3S_u8 => "L R C Ls Rs Sl Sr Tfl Tfr Trc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString72_3S = "L R C LFE Ls Rs Sl Sr Tfl Tfr Trc LFE2";
        
        public static ReadOnlySpan<byte> kString72_3S_u8 => "L R C LFE Ls Rs Sl Sr Tfl Tfr Trc LFE2\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70_4S = "L R C Ls Rs Sl Sr Tfl Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString70_4S_u8 => "L R C Ls Rs Sl Sr Tfl Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71_4S = "L R C LFE Ls Rs Sl Sr Tfl Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString71_4S_u8 => "L R C LFE Ls Rs Sl Sr Tfl Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString70_6S = "L R C Ls Rs Sl Sr Tfl Tfr Trl Trr Tsl Tsr";
        
        public static ReadOnlySpan<byte> kString70_6S_u8 => "L R C Ls Rs Sl Sr Tfl Tfr Trl Trr Tsl Tsr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString71_6S = "L R C LFE Ls Rs Sl Sr Tfl Tfr Trl Trr Tsl Tsr";
        
        public static ReadOnlySpan<byte> kString71_6S_u8 => "L R C LFE Ls Rs Sl Sr Tfl Tfr Trl Trr Tsl Tsr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString90_4S = "L R C Ls Rs Lc Rc Sl Sr Tfl Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString90_4S_u8 => "L R C Ls Rs Lc Rc Sl Sr Tfl Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString91_4S = "L R C LFE Ls Rs Lc Rc Sl Sr Tfl Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString91_4S_u8 => "L R C LFE Ls Rs Lc Rc Sl Sr Tfl Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString90_6S = "L R C Ls Rs Lc Rc Sl Sr Tfl Tfr Trl Trr Tsl Tsr";
        
        public static ReadOnlySpan<byte> kString90_6S_u8 => "L R C Ls Rs Lc Rc Sl Sr Tfl Tfr Trl Trr Tsl Tsr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString91_6S = "L R C LFE Ls Rs Lc Rc Sl Sr Tfl Tfr Trl Trr Tsl Tsr";
        
        public static ReadOnlySpan<byte> kString91_6S_u8 => "L R C LFE Ls Rs Lc Rc Sl Sr Tfl Tfr Trl Trr Tsl Tsr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString100S = "L R C Ls Rs Tc Tfl Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString100S_u8 => "L R C Ls Rs Tc Tfl Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString101S = "L R C LFE Ls Rs Tc Tfl Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString101S_u8 => "L R C LFE Ls Rs Tc Tfl Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString110S = "L R C Ls Rs Tc Tfl Tfc Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString110S_u8 => "L R C Ls Rs Tc Tfl Tfc Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString111S = "L R C LFE Ls Rs Tc Tfl Tfc Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString111S_u8 => "L R C LFE Ls Rs Tc Tfl Tfc Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString130S = "L R C Ls Rs Sl Sr Tc Tfl Tfc Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString130S_u8 => "L R C Ls Rs Sl Sr Tc Tfl Tfc Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString131S = "L R C LFE Ls Rs Sl Sr Tc Tfl Tfc Tfr Trl Trr";
        
        public static ReadOnlySpan<byte> kString131S_u8 => "L R C LFE Ls Rs Sl Sr Tc Tfl Tfc Tfr Trl Trr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString102S = "L R C LFE Ls Rs Tfl Tfc Tfr Trl Trr LFE2";
        
        public static ReadOnlySpan<byte> kString102S_u8 => "L R C LFE Ls Rs Tfl Tfc Tfr Trl Trr LFE2\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString122S = "L R C LFE Ls Rs Lc Rc Tfl Tfc Tfr Trl Trr LFE2";
        
        public static ReadOnlySpan<byte> kString122S_u8 => "L R C LFE Ls Rs Lc Rc Tfl Tfc Tfr Trl Trr LFE2\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString81MPEGS = "L R LFE Ls Rs Tfl Tfc Tfr Bfc";
        
        public static ReadOnlySpan<byte> kString81MPEGS_u8 => "L R LFE Ls Rs Tfl Tfc Tfr Bfc\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString140S = "L R Ls Rs Sl Sr Tfl Tfr Trl Trr Bfl Bfr Brl Brr";
        
        public static ReadOnlySpan<byte> kString140S_u8 => "L R Ls Rs Sl Sr Tfl Tfr Trl Trr Bfl Bfr Brl Brr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString222S = "L R C LFE Ls Rs Lc Rc Cs Sl Sr Tc Tfl Tfc Tfr Trl Trc Trr LFE2 Tsl Tsr Bfl Bfc Bfr";
        
        public static ReadOnlySpan<byte> kString222S_u8 => "L R C LFE Ls Rs Lc Rc Cs Sl Sr Tc Tfl Tfc Tfr Trl Trc Trr LFE2 Tsl Tsr Bfl Bfc Bfr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString220S = "L R C Ls Rs Lc Rc Cs Sl Sr Tc Tfl Tfc Tfr Trl Trc Trr Tsl Tsr Bfl Bfc Bfr";
        
        public static ReadOnlySpan<byte> kString220S_u8 => "L R C Ls Rs Lc Rc Cs Sl Sr Tc Tfl Tfc Tfr Trl Trc Trr Tsl Tsr Bfl Bfc Bfr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString50_5_3S = "L R C Ls Rs Tfl Tfc Tfr Trl Trr Bfl Bfc Bfr";
        
        public static ReadOnlySpan<byte> kString50_5_3S_u8 => "L R C Ls Rs Tfl Tfc Tfr Trl Trr Bfl Bfc Bfr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kString51_5_3S = "L R C LFE Ls Rs Tfl Tfc Tfr Trl Trr Bfl Bfc Bfr";
        
        public static ReadOnlySpan<byte> kString51_5_3S_u8 => "L R C LFE Ls Rs Tfl Tfc Tfr Trl Trr Bfl Bfc Bfr\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringAmbi1stOrderS = "0 1 2 3";
        
        public static ReadOnlySpan<byte> kStringAmbi1stOrderS_u8 => "0 1 2 3\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringAmbi2cdOrderS = "0 1 2 3 4 5 6 7 8";
        
        public static ReadOnlySpan<byte> kStringAmbi2cdOrderS_u8 => "0 1 2 3 4 5 6 7 8\0"u8;
    }
    
    public static partial class SpeakerArr
    {
        public const string kStringAmbi3rdOrderS = "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15";
        
        public static ReadOnlySpan<byte> kStringAmbi3rdOrderS_u8 => "0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Scope, FFT-Display, Loudness Processing...
        /// </summary>
        public const string kFxAnalyzer = "Fx|Analyzer";
        
        /// <summary>
        /// Scope, FFT-Display, Loudness Processing...
        /// </summary>
        public static ReadOnlySpan<byte> kFxAnalyzer_u8 => "Fx|Analyzer\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Delay, Multi-tap Delay, Ping-Pong Delay...
        /// </summary>
        public const string kFxDelay = "Fx|Delay";
        
        /// <summary>
        /// Delay, Multi-tap Delay, Ping-Pong Delay...
        /// </summary>
        public static ReadOnlySpan<byte> kFxDelay_u8 => "Fx|Delay\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Amp Simulator, Sub-Harmonic, SoftClipper...
        /// </summary>
        public const string kFxDistortion = "Fx|Distortion";
        
        /// <summary>
        /// Amp Simulator, Sub-Harmonic, SoftClipper...
        /// </summary>
        public static ReadOnlySpan<byte> kFxDistortion_u8 => "Fx|Distortion\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Compressor, Expander, Gate, Limiter, Maximizer, Tape Simulator, EnvelopeShaper...
        /// </summary>
        public const string kFxDynamics = "Fx|Dynamics";
        
        /// <summary>
        /// Compressor, Expander, Gate, Limiter, Maximizer, Tape Simulator, EnvelopeShaper...
        /// </summary>
        public static ReadOnlySpan<byte> kFxDynamics_u8 => "Fx|Dynamics\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Equalization, Graphical EQ...
        /// </summary>
        public const string kFxEQ = "Fx|EQ";
        
        /// <summary>
        /// Equalization, Graphical EQ...
        /// </summary>
        public static ReadOnlySpan<byte> kFxEQ_u8 => "Fx|EQ\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// WahWah, ToneBooster, Specific Filter,...
        /// </summary>
        public const string kFxFilter = "Fx|Filter";
        
        /// <summary>
        /// WahWah, ToneBooster, Specific Filter,...
        /// </summary>
        public static ReadOnlySpan<byte> kFxFilter_u8 => "Fx|Filter\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// others type (not categorized)
        /// </summary>
        public const string kFx = "Fx";
        
        /// <summary>
        /// others type (not categorized)
        /// </summary>
        public static ReadOnlySpan<byte> kFx_u8 => "Fx\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Fx which could be loaded as Instrument too
        /// </summary>
        public const string kFxInstrument = "Fx|Instrument";
        
        /// <summary>
        /// Fx which could be loaded as Instrument too
        /// </summary>
        public static ReadOnlySpan<byte> kFxInstrument_u8 => "Fx|Instrument\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Fx which could be loaded as Instrument too and is external (wrapped Hardware)
        /// </summary>
        public const string kFxInstrumentExternal = "Fx|Instrument|External";
        
        /// <summary>
        /// Fx which could be loaded as Instrument too and is external (wrapped Hardware)
        /// </summary>
        public static ReadOnlySpan<byte> kFxInstrumentExternal_u8 => "Fx|Instrument|External\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// MonoToStereo, StereoEnhancer,...
        /// </summary>
        public const string kFxSpatial = "Fx|Spatial";
        
        /// <summary>
        /// MonoToStereo, StereoEnhancer,...
        /// </summary>
        public static ReadOnlySpan<byte> kFxSpatial_u8 => "Fx|Spatial\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Tone Generator, Noise Generator...
        /// </summary>
        public const string kFxGenerator = "Fx|Generator";
        
        /// <summary>
        /// Tone Generator, Noise Generator...
        /// </summary>
        public static ReadOnlySpan<byte> kFxGenerator_u8 => "Fx|Generator\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Dither, Noise Shaping,...
        /// </summary>
        public const string kFxMastering = "Fx|Mastering";
        
        /// <summary>
        /// Dither, Noise Shaping,...
        /// </summary>
        public static ReadOnlySpan<byte> kFxMastering_u8 => "Fx|Mastering\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Phaser, Flanger, Chorus, Tremolo, Vibrato, AutoPan, Rotary, Cloner...
        /// </summary>
        public const string kFxModulation = "Fx|Modulation";
        
        /// <summary>
        /// Phaser, Flanger, Chorus, Tremolo, Vibrato, AutoPan, Rotary, Cloner...
        /// </summary>
        public static ReadOnlySpan<byte> kFxModulation_u8 => "Fx|Modulation\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Pitch Processing, Pitch Correction, Vocal Tuning...
        /// </summary>
        public const string kFxPitchShift = "Fx|Pitch Shift";
        
        /// <summary>
        /// Pitch Processing, Pitch Correction, Vocal Tuning...
        /// </summary>
        public static ReadOnlySpan<byte> kFxPitchShift_u8 => "Fx|Pitch Shift\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Denoiser, Declicker,...
        /// </summary>
        public const string kFxRestoration = "Fx|Restoration";
        
        /// <summary>
        /// Denoiser, Declicker,...
        /// </summary>
        public static ReadOnlySpan<byte> kFxRestoration_u8 => "Fx|Restoration\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Reverberation, Room Simulation, Convolution Reverb...
        /// </summary>
        public const string kFxReverb = "Fx|Reverb";
        
        /// <summary>
        /// Reverberation, Room Simulation, Convolution Reverb...
        /// </summary>
        public static ReadOnlySpan<byte> kFxReverb_u8 => "Fx|Reverb\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// dedicated to surround processing: LFE Splitter, Bass Manager...
        /// </summary>
        public const string kFxSurround = "Fx|Surround";
        
        /// <summary>
        /// dedicated to surround processing: LFE Splitter, Bass Manager...
        /// </summary>
        public static ReadOnlySpan<byte> kFxSurround_u8 => "Fx|Surround\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Volume, Mixer, Tuner...
        /// </summary>
        public const string kFxTools = "Fx|Tools";
        
        /// <summary>
        /// Volume, Mixer, Tuner...
        /// </summary>
        public static ReadOnlySpan<byte> kFxTools_u8 => "Fx|Tools\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// using Network
        /// </summary>
        public const string kFxNetwork = "Fx|Network";
        
        /// <summary>
        /// using Network
        /// </summary>
        public static ReadOnlySpan<byte> kFxNetwork_u8 => "Fx|Network\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Effect used as instrument (sound generator), not as insert
        /// </summary>
        public const string kInstrument = "Instrument";
        
        /// <summary>
        /// Effect used as instrument (sound generator), not as insert
        /// </summary>
        public static ReadOnlySpan<byte> kInstrument_u8 => "Instrument\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Instrument for Drum sounds
        /// </summary>
        public const string kInstrumentDrum = "Instrument|Drum";
        
        /// <summary>
        /// Instrument for Drum sounds
        /// </summary>
        public static ReadOnlySpan<byte> kInstrumentDrum_u8 => "Instrument|Drum\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// External Instrument (wrapped Hardware)
        /// </summary>
        public const string kInstrumentExternal = "Instrument|External";
        
        /// <summary>
        /// External Instrument (wrapped Hardware)
        /// </summary>
        public static ReadOnlySpan<byte> kInstrumentExternal_u8 => "Instrument|External\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Instrument for Piano sounds
        /// </summary>
        public const string kInstrumentPiano = "Instrument|Piano";
        
        /// <summary>
        /// Instrument for Piano sounds
        /// </summary>
        public static ReadOnlySpan<byte> kInstrumentPiano_u8 => "Instrument|Piano\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Instrument based on Samples
        /// </summary>
        public const string kInstrumentSampler = "Instrument|Sampler";
        
        /// <summary>
        /// Instrument based on Samples
        /// </summary>
        public static ReadOnlySpan<byte> kInstrumentSampler_u8 => "Instrument|Sampler\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Instrument based on Synthesis
        /// </summary>
        public const string kInstrumentSynth = "Instrument|Synth";
        
        /// <summary>
        /// Instrument based on Synthesis
        /// </summary>
        public static ReadOnlySpan<byte> kInstrumentSynth_u8 => "Instrument|Synth\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Instrument based on Synthesis and Samples
        /// </summary>
        public const string kInstrumentSynthSampler = "Instrument|Synth|Sampler";
        
        /// <summary>
        /// Instrument based on Synthesis and Samples
        /// </summary>
        public static ReadOnlySpan<byte> kInstrumentSynthSampler_u8 => "Instrument|Synth|Sampler\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// used for SurroundPanner
        /// </summary>
        public const string kSpatial = "Spatial";
        
        /// <summary>
        /// used for SurroundPanner
        /// </summary>
        public static ReadOnlySpan<byte> kSpatial_u8 => "Spatial\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// used for SurroundPanner and as insert effect
        /// </summary>
        public const string kSpatialFx = "Spatial|Fx";
        
        /// <summary>
        /// used for SurroundPanner and as insert effect
        /// </summary>
        public static ReadOnlySpan<byte> kSpatialFx_u8 => "Spatial|Fx\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// indicates that it supports only realtime process call, no processing faster than realtime
        /// </summary>
        public const string kOnlyRealTime = "OnlyRT";
        
        /// <summary>
        /// indicates that it supports only realtime process call, no processing faster than realtime
        /// </summary>
        public static ReadOnlySpan<byte> kOnlyRealTime_u8 => "OnlyRT\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// used for plug-in offline processing  (will not work as normal insert plug-in)
        /// </summary>
        public const string kOnlyOfflineProcess = "OnlyOfflineProcess";
        
        /// <summary>
        /// used for plug-in offline processing  (will not work as normal insert plug-in)
        /// </summary>
        public static ReadOnlySpan<byte> kOnlyOfflineProcess_u8 => "OnlyOfflineProcess\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// used for plug-ins that require ARA to operate (will not work as normal insert plug-in)
        /// </summary>
        public const string kOnlyARA = "OnlyARA";
        
        /// <summary>
        /// used for plug-ins that require ARA to operate (will not work as normal insert plug-in)
        /// </summary>
        public static ReadOnlySpan<byte> kOnlyARA_u8 => "OnlyARA\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// will be NOT used for plug-in offline processing (will work as normal insert plug-in)
        /// </summary>
        public const string kNoOfflineProcess = "NoOfflineProcess";
        
        /// <summary>
        /// will be NOT used for plug-in offline processing (will work as normal insert plug-in)
        /// </summary>
        public static ReadOnlySpan<byte> kNoOfflineProcess_u8 => "NoOfflineProcess\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// used for Mixconverter/Up-Mixer/Down-Mixer
        /// </summary>
        public const string kUpDownMix = "Up-Downmix";
        
        /// <summary>
        /// used for Mixconverter/Up-Mixer/Down-Mixer
        /// </summary>
        public static ReadOnlySpan<byte> kUpDownMix_u8 => "Up-Downmix\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// Meter, Scope, FFT-Display, not selectable as insert plug-in
        /// </summary>
        public const string kAnalyzer = "Analyzer";
        
        /// <summary>
        /// Meter, Scope, FFT-Display, not selectable as insert plug-in
        /// </summary>
        public static ReadOnlySpan<byte> kAnalyzer_u8 => "Analyzer\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// used for Ambisonics channel (FX or Panner/Mixconverter/Up-Mixer/Down-Mixer when combined with other category)
        /// </summary>
        public const string kAmbisonics = "Ambisonics";
        
        /// <summary>
        /// used for Ambisonics channel (FX or Panner/Mixconverter/Up-Mixer/Down-Mixer when combined with other category)
        /// </summary>
        public static ReadOnlySpan<byte> kAmbisonics_u8 => "Ambisonics\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// used for Mono only plug-in [optional]
        /// </summary>
        public const string kMono = "Mono";
        
        /// <summary>
        /// used for Mono only plug-in [optional]
        /// </summary>
        public static ReadOnlySpan<byte> kMono_u8 => "Mono\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// used for Stereo only plug-in [optional]
        /// </summary>
        public const string kStereo = "Stereo";
        
        /// <summary>
        /// used for Stereo only plug-in [optional]
        /// </summary>
        public static ReadOnlySpan<byte> kStereo_u8 => "Stereo\0"u8;
    }
    
    public static partial class PlugType
    {
        /// <summary>
        /// used for Surround only plug-in [optional]
        /// </summary>
        public const string kSurround = "Surround";
        
        /// <summary>
        /// used for Surround only plug-in [optional]
        /// </summary>
        public static ReadOnlySpan<byte> kSurround_u8 => "Surround\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// Keys used as AttrID (Attribute ID) in the return IAttributeList of
        /// IInfoListener::setChannelContextInfos
        /// </summary>
        /// <remarks>
        /// ------------------------------------------------------------------------
        /// string (TChar) [optional]: unique id string used to identify a channel
        /// </remarks>
        public const string kChannelUIDKey = "channel uid";
        
        /// <summary>
        /// Keys used as AttrID (Attribute ID) in the return IAttributeList of
        /// IInfoListener::setChannelContextInfos
        /// </summary>
        /// <remarks>
        /// ------------------------------------------------------------------------
        /// string (TChar) [optional]: unique id string used to identify a channel
        /// </remarks>
        public static ReadOnlySpan<byte> kChannelUIDKey_u8 => "channel uid\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// integer (int64) [optional]: number of characters in kChannelUIDKey
        /// </summary>
        public const string kChannelUIDLengthKey = "channel uid length";
        
        /// <summary>
        /// integer (int64) [optional]: number of characters in kChannelUIDKey
        /// </summary>
        public static ReadOnlySpan<byte> kChannelUIDLengthKey_u8 => "channel uid length\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// string (TChar) [optional]: name of the channel like displayed in the mixer
        /// </summary>
        public const string kChannelNameKey = "channel name";
        
        /// <summary>
        /// string (TChar) [optional]: name of the channel like displayed in the mixer
        /// </summary>
        public static ReadOnlySpan<byte> kChannelNameKey_u8 => "channel name\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// integer (int64) [optional]: number of characters in kChannelNameKey
        /// </summary>
        public const string kChannelNameLengthKey = "channel name length";
        
        /// <summary>
        /// integer (int64) [optional]: number of characters in kChannelNameKey
        /// </summary>
        public static ReadOnlySpan<byte> kChannelNameLengthKey_u8 => "channel name length\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// color (ColorSpec) [optional]: used color for the channel in mixer or track
        /// </summary>
        public const string kChannelColorKey = "channel color";
        
        /// <summary>
        /// color (ColorSpec) [optional]: used color for the channel in mixer or track
        /// </summary>
        public static ReadOnlySpan<byte> kChannelColorKey_u8 => "channel color\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// integer (int64) [optional]: index of the channel in a channel index namespace, start with 1 not * 0!
        /// </summary>
        public const string kChannelIndexKey = "channel index";
        
        /// <summary>
        /// integer (int64) [optional]: index of the channel in a channel index namespace, start with 1 not * 0!
        /// </summary>
        public static ReadOnlySpan<byte> kChannelIndexKey_u8 => "channel index\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// integer (int64) [optional]: define the order of the current used index namespace, start with 1 not 0!
        /// For example:
        /// index namespace is "Input"   -&gt; order 1,
        /// index namespace is "Channel" -&gt; order 2,
        /// index namespace is "Output"  -&gt; order 3
        /// </summary>
        public const string kChannelIndexNamespaceOrderKey = "channel index namespace order";
        
        /// <summary>
        /// integer (int64) [optional]: define the order of the current used index namespace, start with 1 not 0!
        /// For example:
        /// index namespace is "Input"   -&gt; order 1,
        /// index namespace is "Channel" -&gt; order 2,
        /// index namespace is "Output"  -&gt; order 3
        /// </summary>
        public static ReadOnlySpan<byte> kChannelIndexNamespaceOrderKey_u8 => "channel index namespace order\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// string (TChar) [optional]: name of the channel index namespace for example "Input", "Output", "Channel", ...
        /// </summary>
        public const string kChannelIndexNamespaceKey = "channel index namespace";
        
        /// <summary>
        /// string (TChar) [optional]: name of the channel index namespace for example "Input", "Output", "Channel", ...
        /// </summary>
        public static ReadOnlySpan<byte> kChannelIndexNamespaceKey_u8 => "channel index namespace\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// integer (int64) [optional]: number of characters in kChannelIndexNamespaceKey
        /// </summary>
        public const string kChannelIndexNamespaceLengthKey = "channel index namespace length";
        
        /// <summary>
        /// integer (int64) [optional]: number of characters in kChannelIndexNamespaceKey
        /// </summary>
        public static ReadOnlySpan<byte> kChannelIndexNamespaceLengthKey_u8 => "channel index namespace length\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// PNG image representation as binary [optional]
        /// </summary>
        public const string kChannelImageKey = "channel image";
        
        /// <summary>
        /// PNG image representation as binary [optional]
        /// </summary>
        public static ReadOnlySpan<byte> kChannelImageKey_u8 => "channel image\0"u8;
    }
    
    public static partial class ChannelContext
    {
        /// <summary>
        /// integer (int64) [optional]: routing position of the plug-in in the channel (see ChannelPluginLocation)
        /// </summary>
        public const string kChannelPluginLocationKey = "channel plugin location";
        
        /// <summary>
        /// integer (int64) [optional]: routing position of the plug-in in the channel (see ChannelPluginLocation)
        /// </summary>
        public static ReadOnlySpan<byte> kChannelPluginLocationKey_u8 => "channel plugin location\0"u8;
    }
    
    public static partial class ViewType
    {
        public const string kEditor = "editor";
        
        public static ReadOnlySpan<byte> kEditor_u8 => "editor\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        /// <summary>
        /// 
        /// </summary>
        public const string kCompGainReduction = "Comp:GainReduction";
        
        /// <summary>
        /// 
        /// </summary>
        public static ReadOnlySpan<byte> kCompGainReduction_u8 => "Comp:GainReduction\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        public const string kCompGainReductionMax = "Comp:GainReductionMax";
        
        public static ReadOnlySpan<byte> kCompGainReductionMax_u8 => "Comp:GainReductionMax\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        public const string kCompGainReductionPeakHold = "Comp:GainReductionPeakHold";
        
        public static ReadOnlySpan<byte> kCompGainReductionPeakHold_u8 => "Comp:GainReductionPeakHold\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        public const string kCompResetGainReductionMax = "Comp:ResetGainReductionMax";
        
        public static ReadOnlySpan<byte> kCompResetGainReductionMax_u8 => "Comp:ResetGainReductionMax\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        public const string kLowLatencyMode = "LowLatencyMode";
        
        public static ReadOnlySpan<byte> kLowLatencyMode_u8 => "LowLatencyMode\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        /// <summary>
        /// Useful for live situation where low
        /// latency is required:
        /// 0 means LowLatency disable,
        /// 1 means LowLatency enable
        /// </summary>
        public const string kDryWetMix = "DryWetMix";
        
        /// <summary>
        /// Useful for live situation where low
        /// latency is required:
        /// 0 means LowLatency disable,
        /// 1 means LowLatency enable
        /// </summary>
        public static ReadOnlySpan<byte> kDryWetMix_u8 => "DryWetMix\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        /// <summary>
        /// Allowing to mix the original (Dry) Signal with the processed one (Wet):
        /// 0.0 means Dry Signal only,
        /// 0.5 means 50% Dry Signal + 50% Wet Signal,
        /// 1.0 means Wet Signal only
        /// </summary>
        public const string kRandomize = "Randomize";
        
        /// <summary>
        /// Allowing to mix the original (Dry) Signal with the processed one (Wet):
        /// 0.0 means Dry Signal only,
        /// 0.5 means 50% Dry Signal + 50% Wet Signal,
        /// 1.0 means Wet Signal only
        /// </summary>
        public static ReadOnlySpan<byte> kRandomize_u8 => "Randomize\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        /// <summary>
        /// Gravity point X-axis [0, 1]=&gt;[L-R] (for stereo: middle between left and right)
        /// </summary>
        public const string kPanPosCenterX = "PanPosCenterX";
        
        /// <summary>
        /// Gravity point X-axis [0, 1]=&gt;[L-R] (for stereo: middle between left and right)
        /// </summary>
        public static ReadOnlySpan<byte> kPanPosCenterX_u8 => "PanPosCenterX\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        /// <summary>
        /// Gravity point Y-axis [0, 1]=&gt;[Front-Rear]
        /// </summary>
        public const string kPanPosCenterY = "PanPosCenterY";
        
        /// <summary>
        /// Gravity point Y-axis [0, 1]=&gt;[Front-Rear]
        /// </summary>
        public static ReadOnlySpan<byte> kPanPosCenterY_u8 => "PanPosCenterY\0"u8;
    }
    
    public static partial class FunctionNameType
    {
        /// <summary>
        /// Gravity point Z-axis [0, 1]=&gt;[Bottom-Top]
        /// </summary>
        public const string kPanPosCenterZ = "PanPosCenterZ";
        
        /// <summary>
        /// Gravity point Z-axis [0, 1]=&gt;[Bottom-Top]
        /// </summary>
        public static ReadOnlySpan<byte> kPanPosCenterZ_u8 => "PanPosCenterZ\0"u8;
    }
    
    public static partial class CurveType
    {
        public const string kSegment = "segment";
        
        public static ReadOnlySpan<byte> kSegment_u8 => "segment\0"u8;
    }
    
    public static partial class CurveType
    {
        public const string kValueList = "valueList";
        
        public static ReadOnlySpan<byte> kValueList_u8 => "valueList\0"u8;
    }
    
    public static partial class Attributes
    {
        /// <summary>
        /// string attribute : See AttributesStyle for available string value
        /// </summary>
        public const string kStyle = "style";
        
        /// <summary>
        /// string attribute : See AttributesStyle for available string value
        /// </summary>
        public static ReadOnlySpan<byte> kStyle_u8 => "style\0"u8;
    }
    
    public static partial class Attributes
    {
        /// <summary>
        /// string attribute : See AttributesStyle for available string value
        /// </summary>
        public const string kLEDStyle = "ledStyle";
        
        /// <summary>
        /// string attribute : See AttributesStyle for available string value
        /// </summary>
        public static ReadOnlySpan<byte> kLEDStyle_u8 => "ledStyle\0"u8;
    }
    
    public static partial class Attributes
    {
        /// <summary>
        /// string attribute : See AttributesStyle for available string value
        /// </summary>
        public const string kSwitchStyle = "switchStyle";
        
        /// <summary>
        /// string attribute : See AttributesStyle for available string value
        /// </summary>
        public static ReadOnlySpan<byte> kSwitchStyle_u8 => "switchStyle\0"u8;
    }
    
    public static partial class Attributes
    {
        /// <summary>
        /// float attribute
        /// </summary>
        public const string kKnobTurnsPerFullRange = "turnsPerFullRange";
        
        /// <summary>
        /// float attribute
        /// </summary>
        public static ReadOnlySpan<byte> kKnobTurnsPerFullRange_u8 => "turnsPerFullRange\0"u8;
    }
    
    public static partial class Attributes
    {
        /// <summary>
        /// string attribute : See AttributesFunction for available string value
        /// </summary>
        public const string kFunction = "function";
        
        /// <summary>
        /// string attribute : See AttributesFunction for available string value
        /// </summary>
        public static ReadOnlySpan<byte> kFunction_u8 => "function\0"u8;
    }
    
    public static partial class Attributes
    {
        /// <summary>
        /// string attribute : See AttributesFlags for available string value
        /// </summary>
        public const string kFlags = "flags";
        
        /// <summary>
        /// string attribute : See AttributesFlags for available string value
        /// </summary>
        public static ReadOnlySpan<byte> kFlags_u8 => "flags\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Gravity point X-axis (L-R) (for stereo: middle between left and right)
        /// </summary>
        public const string kPanPosCenterXFunc = "PanPosCenterX";
        
        /// <summary>
        /// Gravity point X-axis (L-R) (for stereo: middle between left and right)
        /// </summary>
        public static ReadOnlySpan<byte> kPanPosCenterXFunc_u8 => "PanPosCenterX\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Gravity point Y-axis (Front-Rear)
        /// </summary>
        public const string kPanPosCenterYFunc = "PanPosCenterY";
        
        /// <summary>
        /// Gravity point Y-axis (Front-Rear)
        /// </summary>
        public static ReadOnlySpan<byte> kPanPosCenterYFunc_u8 => "PanPosCenterY\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Left channel Position in X-axis
        /// </summary>
        public const string kPanPosFrontLeftXFunc = "PanPosFrontLeftX";
        
        /// <summary>
        /// Left channel Position in X-axis
        /// </summary>
        public static ReadOnlySpan<byte> kPanPosFrontLeftXFunc_u8 => "PanPosFrontLeftX\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Left channel Position in Y-axis
        /// </summary>
        public const string kPanPosFrontLeftYFunc = "PanPosFrontLeftY";
        
        /// <summary>
        /// Left channel Position in Y-axis
        /// </summary>
        public static ReadOnlySpan<byte> kPanPosFrontLeftYFunc_u8 => "PanPosFrontLeftY\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Right channel Position in X-axis
        /// </summary>
        public const string kPanPosFrontRightXFunc = "PanPosFrontRightX";
        
        /// <summary>
        /// Right channel Position in X-axis
        /// </summary>
        public static ReadOnlySpan<byte> kPanPosFrontRightXFunc_u8 => "PanPosFrontRightX\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Right channel Position in Y-axis
        /// </summary>
        public const string kPanPosFrontRightYFunc = "PanPosFrontRightY";
        
        /// <summary>
        /// Right channel Position in Y-axis
        /// </summary>
        public static ReadOnlySpan<byte> kPanPosFrontRightYFunc_u8 => "PanPosFrontRightY\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Rotation around the Center (gravity point)
        /// </summary>
        public const string kPanRotationFunc = "PanRotation";
        
        /// <summary>
        /// Rotation around the Center (gravity point)
        /// </summary>
        public static ReadOnlySpan<byte> kPanRotationFunc_u8 => "PanRotation\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Panning Law
        /// </summary>
        public const string kPanLawFunc = "PanLaw";
        
        /// <summary>
        /// Panning Law
        /// </summary>
        public static ReadOnlySpan<byte> kPanLawFunc_u8 => "PanLaw\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Panning Mirror Mode
        /// </summary>
        public const string kPanMirrorModeFunc = "PanMirrorMode";
        
        /// <summary>
        /// Panning Mirror Mode
        /// </summary>
        public static ReadOnlySpan<byte> kPanMirrorModeFunc_u8 => "PanMirrorMode\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Panning LFE Gain
        /// </summary>
        public const string kPanLfeGainFunc = "PanLfeGain";
        
        /// <summary>
        /// Panning LFE Gain
        /// </summary>
        public static ReadOnlySpan<byte> kPanLfeGainFunc_u8 => "PanLfeGain\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Gain Reduction for compressor
        /// </summary>
        public const string kGainReductionFunc = "GainReduction";
        
        /// <summary>
        /// Gain Reduction for compressor
        /// </summary>
        public static ReadOnlySpan<byte> kGainReductionFunc_u8 => "GainReduction\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Solo
        /// </summary>
        public const string kSoloFunc = "Solo";
        
        /// <summary>
        /// Solo
        /// </summary>
        public static ReadOnlySpan<byte> kSoloFunc_u8 => "Solo\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Mute
        /// </summary>
        public const string kMuteFunc = "Mute";
        
        /// <summary>
        /// Mute
        /// </summary>
        public static ReadOnlySpan<byte> kMuteFunc_u8 => "Mute\0"u8;
    }
    
    public static partial class AttributesFunction
    {
        /// <summary>
        /// Volume
        /// </summary>
        public const string kVolumeFunc = "Volume";
        
        /// <summary>
        /// Volume
        /// </summary>
        public static ReadOnlySpan<byte> kVolumeFunc_u8 => "Volume\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// the associated layer should use the inverse value of parameter (1 - x).
        /// </summary>
        public const string kInverseStyle = "inverse";
        
        /// <summary>
        /// the associated layer should use the inverse value of parameter (1 - x).
        /// </summary>
        public static ReadOnlySpan<byte> kInverseStyle_u8 => "inverse\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// |======&gt;----- (the default one if not specified)
        /// </summary>
        public const string kLEDWrapLeftStyle = "wrapLeft";
        
        /// <summary>
        /// |======&gt;----- (the default one if not specified)
        /// </summary>
        public static ReadOnlySpan<byte> kLEDWrapLeftStyle_u8 => "wrapLeft\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// &lt;
        /// ====|
        /// </summary>
        public const string kLEDWrapRightStyle = "wrapRight";
        
        /// <summary>
        /// &lt;
        /// ====|
        /// </summary>
        public static ReadOnlySpan<byte> kLEDWrapRightStyle_u8 => "wrapRight\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// &lt;
        /// ==|==&gt;---
        /// </summary>
        public const string kLEDSpreadStyle = "spread";
        
        /// <summary>
        /// &lt;
        /// ==|==&gt;---
        /// </summary>
        public static ReadOnlySpan<byte> kLEDSpreadStyle_u8 => "spread\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// ------|===&gt;--
        /// </summary>
        public const string kLEDBoostCutStyle = "boostCut";
        
        /// <summary>
        /// ------|===&gt;--
        /// </summary>
        public static ReadOnlySpan<byte> kLEDBoostCutStyle_u8 => "boostCut\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// --------|----
        /// </summary>
        public const string kLEDSingleDotStyle = "singleDot";
        
        /// <summary>
        /// --------|----
        /// </summary>
        public static ReadOnlySpan<byte> kLEDSingleDotStyle_u8 => "singleDot\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// Apply only when pressed, unpressed will reset the value to min.
        /// </summary>
        public const string kSwitchPushStyle = "push";
        
        /// <summary>
        /// Apply only when pressed, unpressed will reset the value to min.
        /// </summary>
        public static ReadOnlySpan<byte> kSwitchPushStyle_u8 => "push\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// Push will increment the value. When the max is reached it will restart with min.
        /// The default one if not specified (with 2 states values it is a OnOff switch).
        /// </summary>
        public const string kSwitchPushIncLoopedStyle = "pushIncLooped";
        
        /// <summary>
        /// Push will increment the value. When the max is reached it will restart with min.
        /// The default one if not specified (with 2 states values it is a OnOff switch).
        /// </summary>
        public static ReadOnlySpan<byte> kSwitchPushIncLoopedStyle_u8 => "pushIncLooped\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// Push will decrement the value. When the min is reached it will restart with max.
        /// </summary>
        public const string kSwitchPushDecLoopedStyle = "pushDecLooped";
        
        /// <summary>
        /// Push will decrement the value. When the min is reached it will restart with max.
        /// </summary>
        public static ReadOnlySpan<byte> kSwitchPushDecLoopedStyle_u8 => "pushDecLooped\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// Increment after each press (delta depends of the curve).
        /// </summary>
        public const string kSwitchPushIncStyle = "pushInc";
        
        /// <summary>
        /// Increment after each press (delta depends of the curve).
        /// </summary>
        public static ReadOnlySpan<byte> kSwitchPushIncStyle_u8 => "pushInc\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// Decrement after each press (delta depends of the curve).
        /// </summary>
        public const string kSwitchPushDecStyle = "pushDec";
        
        /// <summary>
        /// Decrement after each press (delta depends of the curve).
        /// </summary>
        public static ReadOnlySpan<byte> kSwitchPushDecStyle_u8 => "pushDec\0"u8;
    }
    
    public static partial class AttributesStyle
    {
        /// <summary>
        /// Each push-release will change the value between min and max. 
        /// A timeout between push and release could be used to simulate a push style (if timeout is reached).
        /// </summary>
        public const string kSwitchLatchStyle = "latch";
        
        /// <summary>
        /// Each push-release will change the value between min and max. 
        /// A timeout between push and release could be used to simulate a push style (if timeout is reached).
        /// </summary>
        public static ReadOnlySpan<byte> kSwitchLatchStyle_u8 => "latch\0"u8;
    }
    
    public static partial class AttributesFlags
    {
        /// <summary>
        /// the associated layer marked as hideable allows a remote to hide or make it not usable a parameter when the associated value is inactive
        /// </summary>
        public const string kHideableFlag = "hideable";
        
        /// <summary>
        /// the associated layer marked as hideable allows a remote to hide or make it not usable a parameter when the associated value is inactive
        /// </summary>
        public static ReadOnlySpan<byte> kHideableFlag_u8 => "hideable\0"u8;
    }
    
    public static partial class PresetAttributes
    {
        /// <summary>
        /// plug-in name
        /// </summary>
        public const string kPlugInName = "PlugInName";
        
        /// <summary>
        /// plug-in name
        /// </summary>
        public static ReadOnlySpan<byte> kPlugInName_u8 => "PlugInName\0"u8;
    }
    
    public static partial class PresetAttributes
    {
        /// <summary>
        /// eg. "Fx|Dynamics", "Instrument", "Instrument|Synth"
        /// </summary>
        public const string kPlugInCategory = "PlugInCategory";
        
        /// <summary>
        /// eg. "Fx|Dynamics", "Instrument", "Instrument|Synth"
        /// </summary>
        public static ReadOnlySpan<byte> kPlugInCategory_u8 => "PlugInCategory\0"u8;
    }
    
    public static partial class PresetAttributes
    {
        /// <summary>
        /// eg. instrument group (like 'Piano' or 'Piano|A. Piano')
        /// </summary>
        public const string kInstrument = "MusicalInstrument";
        
        /// <summary>
        /// eg. instrument group (like 'Piano' or 'Piano|A. Piano')
        /// </summary>
        public static ReadOnlySpan<byte> kInstrument_u8 => "MusicalInstrument\0"u8;
    }
    
    public static partial class PresetAttributes
    {
        /// <summary>
        /// eg. 'Pop', 'Jazz', 'Classic'
        /// </summary>
        public const string kStyle = "MusicalStyle";
        
        /// <summary>
        /// eg. 'Pop', 'Jazz', 'Classic'
        /// </summary>
        public static ReadOnlySpan<byte> kStyle_u8 => "MusicalStyle\0"u8;
    }
    
    public static partial class PresetAttributes
    {
        /// <summary>
        /// eg. instrument nature (like 'Soft' 'Dry' 'Acoustic')
        /// </summary>
        public const string kCharacter = "MusicalCharacter";
        
        /// <summary>
        /// eg. instrument nature (like 'Soft' 'Dry' 'Acoustic')
        /// </summary>
        public static ReadOnlySpan<byte> kCharacter_u8 => "MusicalCharacter\0"u8;
    }
    
    public static partial class PresetAttributes
    {
        /// <summary>
        /// Type of the given state see @ref StateType : Project / Default Preset or Normal Preset
        /// </summary>
        public const string kStateType = "StateType";
        
        /// <summary>
        /// Type of the given state see @ref StateType : Project / Default Preset or Normal Preset
        /// </summary>
        public static ReadOnlySpan<byte> kStateType_u8 => "StateType\0"u8;
    }
    
    public static partial class PresetAttributes
    {
        /// <summary>
        /// Full file path string (if available) where the preset comes from (be sure to use a bigger string when asking for it (with 1024 characters))
        /// </summary>
        public const string kFilePathStringType = "FilePathString";
        
        /// <summary>
        /// Full file path string (if available) where the preset comes from (be sure to use a bigger string when asking for it (with 1024 characters))
        /// </summary>
        public static ReadOnlySpan<byte> kFilePathStringType_u8 => "FilePathString\0"u8;
    }
    
    public static partial class PresetAttributes
    {
        /// <summary>
        /// name of the preset
        /// </summary>
        public const string kName = "Name";
        
        /// <summary>
        /// name of the preset
        /// </summary>
        public static ReadOnlySpan<byte> kName_u8 => "Name\0"u8;
    }
    
    public static partial class PresetAttributes
    {
        /// <summary>
        /// filename of the preset (including extension)
        /// </summary>
        public const string kFileName = "FileName";
        
        /// <summary>
        /// filename of the preset (including extension)
        /// </summary>
        public static ReadOnlySpan<byte> kFileName_u8 => "FileName\0"u8;
    }
    
    public static partial class StateType
    {
        /// <summary>
        /// the state is restored from a project loading or it is saved in a project
        /// </summary>
        public const string kProject = "Project";
        
        /// <summary>
        /// the state is restored from a project loading or it is saved in a project
        /// </summary>
        public static ReadOnlySpan<byte> kProject_u8 => "Project\0"u8;
    }
    
    public static partial class StateType
    {
        /// <summary>
        /// the state is restored from a preset (marked as default) or the host wants to store a default state of the plug-in
        /// </summary>
        public const string kDefault = "Default";
        
        /// <summary>
        /// the state is restored from a preset (marked as default) or the host wants to store a default state of the plug-in
        /// </summary>
        public static ReadOnlySpan<byte> kDefault_u8 => "Default\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        /// <summary>
        ///  musicalInstrument Predefined Musical Instrument
        /// </summary>
        /// <remarks>
        /// @
        /// {
        /// </remarks>
        public const string kAccordion = "Accordion";
        
        /// <summary>
        ///  musicalInstrument Predefined Musical Instrument
        /// </summary>
        /// <remarks>
        /// @
        /// {
        /// </remarks>
        public static ReadOnlySpan<byte> kAccordion_u8 => "Accordion\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kAccordionAccordion = "Accordion|Accordion";
        
        public static ReadOnlySpan<byte> kAccordionAccordion_u8 => "Accordion|Accordion\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kAccordionHarmonica = "Accordion|Harmonica";
        
        public static ReadOnlySpan<byte> kAccordionHarmonica_u8 => "Accordion|Harmonica\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kAccordionOther = "Accordion|Other";
        
        public static ReadOnlySpan<byte> kAccordionOther_u8 => "Accordion|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBass = "Bass";
        
        public static ReadOnlySpan<byte> kBass_u8 => "Bass\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBassABass = "Bass|A. Bass";
        
        public static ReadOnlySpan<byte> kBassABass_u8 => "Bass|A. Bass\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBassEBass = "Bass|E. Bass";
        
        public static ReadOnlySpan<byte> kBassEBass_u8 => "Bass|E. Bass\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBassSynthBass = "Bass|Synth Bass";
        
        public static ReadOnlySpan<byte> kBassSynthBass_u8 => "Bass|Synth Bass\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBassOther = "Bass|Other";
        
        public static ReadOnlySpan<byte> kBassOther_u8 => "Bass|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBrass = "Brass";
        
        public static ReadOnlySpan<byte> kBrass_u8 => "Brass\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBrassFrenchHorn = "Brass|French Horn";
        
        public static ReadOnlySpan<byte> kBrassFrenchHorn_u8 => "Brass|French Horn\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBrassTrumpet = "Brass|Trumpet";
        
        public static ReadOnlySpan<byte> kBrassTrumpet_u8 => "Brass|Trumpet\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBrassTrombone = "Brass|Trombone";
        
        public static ReadOnlySpan<byte> kBrassTrombone_u8 => "Brass|Trombone\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBrassTuba = "Brass|Tuba";
        
        public static ReadOnlySpan<byte> kBrassTuba_u8 => "Brass|Tuba\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBrassSection = "Brass|Section";
        
        public static ReadOnlySpan<byte> kBrassSection_u8 => "Brass|Section\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBrassSynth = "Brass|Synth";
        
        public static ReadOnlySpan<byte> kBrassSynth_u8 => "Brass|Synth\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kBrassOther = "Brass|Other";
        
        public static ReadOnlySpan<byte> kBrassOther_u8 => "Brass|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kChromaticPerc = "Chromatic Perc";
        
        public static ReadOnlySpan<byte> kChromaticPerc_u8 => "Chromatic Perc\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kChromaticPercBell = "Chromatic Perc|Bell";
        
        public static ReadOnlySpan<byte> kChromaticPercBell_u8 => "Chromatic Perc|Bell\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kChromaticPercMallett = "Chromatic Perc|Mallett";
        
        public static ReadOnlySpan<byte> kChromaticPercMallett_u8 => "Chromatic Perc|Mallett\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kChromaticPercWood = "Chromatic Perc|Wood";
        
        public static ReadOnlySpan<byte> kChromaticPercWood_u8 => "Chromatic Perc|Wood\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kChromaticPercPercussion = "Chromatic Perc|Percussion";
        
        public static ReadOnlySpan<byte> kChromaticPercPercussion_u8 => "Chromatic Perc|Percussion\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kChromaticPercTimpani = "Chromatic Perc|Timpani";
        
        public static ReadOnlySpan<byte> kChromaticPercTimpani_u8 => "Chromatic Perc|Timpani\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kChromaticPercOther = "Chromatic Perc|Other";
        
        public static ReadOnlySpan<byte> kChromaticPercOther_u8 => "Chromatic Perc|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPerc = "Drum&Perc";
        
        public static ReadOnlySpan<byte> kDrumPerc_u8 => "Drum&Perc\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercDrumsetGM = "Drum&Perc|Drumset GM";
        
        public static ReadOnlySpan<byte> kDrumPercDrumsetGM_u8 => "Drum&Perc|Drumset GM\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercDrumset = "Drum&Perc|Drumset";
        
        public static ReadOnlySpan<byte> kDrumPercDrumset_u8 => "Drum&Perc|Drumset\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercDrumMenues = "Drum&Perc|Drum Menues";
        
        public static ReadOnlySpan<byte> kDrumPercDrumMenues_u8 => "Drum&Perc|Drum Menues\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercBeats = "Drum&Perc|Beats";
        
        public static ReadOnlySpan<byte> kDrumPercBeats_u8 => "Drum&Perc|Beats\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercPercussion = "Drum&Perc|Percussion";
        
        public static ReadOnlySpan<byte> kDrumPercPercussion_u8 => "Drum&Perc|Percussion\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercKickDrum = "Drum&Perc|Kick Drum";
        
        public static ReadOnlySpan<byte> kDrumPercKickDrum_u8 => "Drum&Perc|Kick Drum\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercSnareDrum = "Drum&Perc|Snare Drum";
        
        public static ReadOnlySpan<byte> kDrumPercSnareDrum_u8 => "Drum&Perc|Snare Drum\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercToms = "Drum&Perc|Toms";
        
        public static ReadOnlySpan<byte> kDrumPercToms_u8 => "Drum&Perc|Toms\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercHiHats = "Drum&Perc|HiHats";
        
        public static ReadOnlySpan<byte> kDrumPercHiHats_u8 => "Drum&Perc|HiHats\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercCymbals = "Drum&Perc|Cymbals";
        
        public static ReadOnlySpan<byte> kDrumPercCymbals_u8 => "Drum&Perc|Cymbals\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kDrumPercOther = "Drum&Perc|Other";
        
        public static ReadOnlySpan<byte> kDrumPercOther_u8 => "Drum&Perc|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kEthnic = "Ethnic";
        
        public static ReadOnlySpan<byte> kEthnic_u8 => "Ethnic\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kEthnicAsian = "Ethnic|Asian";
        
        public static ReadOnlySpan<byte> kEthnicAsian_u8 => "Ethnic|Asian\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kEthnicAfrican = "Ethnic|African";
        
        public static ReadOnlySpan<byte> kEthnicAfrican_u8 => "Ethnic|African\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kEthnicEuropean = "Ethnic|European";
        
        public static ReadOnlySpan<byte> kEthnicEuropean_u8 => "Ethnic|European\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kEthnicLatin = "Ethnic|Latin";
        
        public static ReadOnlySpan<byte> kEthnicLatin_u8 => "Ethnic|Latin\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kEthnicAmerican = "Ethnic|American";
        
        public static ReadOnlySpan<byte> kEthnicAmerican_u8 => "Ethnic|American\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kEthnicAlien = "Ethnic|Alien";
        
        public static ReadOnlySpan<byte> kEthnicAlien_u8 => "Ethnic|Alien\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kEthnicOther = "Ethnic|Other";
        
        public static ReadOnlySpan<byte> kEthnicOther_u8 => "Ethnic|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kGuitar = "Guitar/Plucked";
        
        public static ReadOnlySpan<byte> kGuitar_u8 => "Guitar/Plucked\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kGuitarAGuitar = "Guitar/Plucked|A. Guitar";
        
        public static ReadOnlySpan<byte> kGuitarAGuitar_u8 => "Guitar/Plucked|A. Guitar\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kGuitarEGuitar = "Guitar/Plucked|E. Guitar";
        
        public static ReadOnlySpan<byte> kGuitarEGuitar_u8 => "Guitar/Plucked|E. Guitar\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kGuitarHarp = "Guitar/Plucked|Harp";
        
        public static ReadOnlySpan<byte> kGuitarHarp_u8 => "Guitar/Plucked|Harp\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kGuitarEthnic = "Guitar/Plucked|Ethnic";
        
        public static ReadOnlySpan<byte> kGuitarEthnic_u8 => "Guitar/Plucked|Ethnic\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kGuitarOther = "Guitar/Plucked|Other";
        
        public static ReadOnlySpan<byte> kGuitarOther_u8 => "Guitar/Plucked|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kKeyboard = "Keyboard";
        
        public static ReadOnlySpan<byte> kKeyboard_u8 => "Keyboard\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kKeyboardClavi = "Keyboard|Clavi";
        
        public static ReadOnlySpan<byte> kKeyboardClavi_u8 => "Keyboard|Clavi\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kKeyboardEPiano = "Keyboard|E. Piano";
        
        public static ReadOnlySpan<byte> kKeyboardEPiano_u8 => "Keyboard|E. Piano\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kKeyboardHarpsichord = "Keyboard|Harpsichord";
        
        public static ReadOnlySpan<byte> kKeyboardHarpsichord_u8 => "Keyboard|Harpsichord\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kKeyboardOther = "Keyboard|Other";
        
        public static ReadOnlySpan<byte> kKeyboardOther_u8 => "Keyboard|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kMusicalFX = "Musical FX";
        
        public static ReadOnlySpan<byte> kMusicalFX_u8 => "Musical FX\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kMusicalFXHitsStabs = "Musical FX|Hits&Stabs";
        
        public static ReadOnlySpan<byte> kMusicalFXHitsStabs_u8 => "Musical FX|Hits&Stabs\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kMusicalFXMotion = "Musical FX|Motion";
        
        public static ReadOnlySpan<byte> kMusicalFXMotion_u8 => "Musical FX|Motion\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kMusicalFXSweeps = "Musical FX|Sweeps";
        
        public static ReadOnlySpan<byte> kMusicalFXSweeps_u8 => "Musical FX|Sweeps\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kMusicalFXBeepsBlips = "Musical FX|Beeps&Blips";
        
        public static ReadOnlySpan<byte> kMusicalFXBeepsBlips_u8 => "Musical FX|Beeps&Blips\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kMusicalFXScratches = "Musical FX|Scratches";
        
        public static ReadOnlySpan<byte> kMusicalFXScratches_u8 => "Musical FX|Scratches\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kMusicalFXOther = "Musical FX|Other";
        
        public static ReadOnlySpan<byte> kMusicalFXOther_u8 => "Musical FX|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kOrgan = "Organ";
        
        public static ReadOnlySpan<byte> kOrgan_u8 => "Organ\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kOrganElectric = "Organ|Electric";
        
        public static ReadOnlySpan<byte> kOrganElectric_u8 => "Organ|Electric\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kOrganPipe = "Organ|Pipe";
        
        public static ReadOnlySpan<byte> kOrganPipe_u8 => "Organ|Pipe\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kOrganOther = "Organ|Other";
        
        public static ReadOnlySpan<byte> kOrganOther_u8 => "Organ|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kPiano = "Piano";
        
        public static ReadOnlySpan<byte> kPiano_u8 => "Piano\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kPianoAPiano = "Piano|A. Piano";
        
        public static ReadOnlySpan<byte> kPianoAPiano_u8 => "Piano|A. Piano\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kPianoEGrand = "Piano|E. Grand";
        
        public static ReadOnlySpan<byte> kPianoEGrand_u8 => "Piano|E. Grand\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kPianoOther = "Piano|Other";
        
        public static ReadOnlySpan<byte> kPianoOther_u8 => "Piano|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSoundFX = "Sound FX";
        
        public static ReadOnlySpan<byte> kSoundFX_u8 => "Sound FX\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSoundFXNature = "Sound FX|Nature";
        
        public static ReadOnlySpan<byte> kSoundFXNature_u8 => "Sound FX|Nature\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSoundFXMechanical = "Sound FX|Mechanical";
        
        public static ReadOnlySpan<byte> kSoundFXMechanical_u8 => "Sound FX|Mechanical\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSoundFXSynthetic = "Sound FX|Synthetic";
        
        public static ReadOnlySpan<byte> kSoundFXSynthetic_u8 => "Sound FX|Synthetic\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSoundFXOther = "Sound FX|Other";
        
        public static ReadOnlySpan<byte> kSoundFXOther_u8 => "Sound FX|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kStrings = "Strings";
        
        public static ReadOnlySpan<byte> kStrings_u8 => "Strings\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kStringsViolin = "Strings|Violin";
        
        public static ReadOnlySpan<byte> kStringsViolin_u8 => "Strings|Violin\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kStringsViola = "Strings|Viola";
        
        public static ReadOnlySpan<byte> kStringsViola_u8 => "Strings|Viola\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kStringsCello = "Strings|Cello";
        
        public static ReadOnlySpan<byte> kStringsCello_u8 => "Strings|Cello\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kStringsBass = "Strings|Bass";
        
        public static ReadOnlySpan<byte> kStringsBass_u8 => "Strings|Bass\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kStringsSection = "Strings|Section";
        
        public static ReadOnlySpan<byte> kStringsSection_u8 => "Strings|Section\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kStringsSynth = "Strings|Synth";
        
        public static ReadOnlySpan<byte> kStringsSynth_u8 => "Strings|Synth\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kStringsOther = "Strings|Other";
        
        public static ReadOnlySpan<byte> kStringsOther_u8 => "Strings|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthLead = "Synth Lead";
        
        public static ReadOnlySpan<byte> kSynthLead_u8 => "Synth Lead\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthLeadAnalog = "Synth Lead|Analog";
        
        public static ReadOnlySpan<byte> kSynthLeadAnalog_u8 => "Synth Lead|Analog\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthLeadDigital = "Synth Lead|Digital";
        
        public static ReadOnlySpan<byte> kSynthLeadDigital_u8 => "Synth Lead|Digital\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthLeadArpeggio = "Synth Lead|Arpeggio";
        
        public static ReadOnlySpan<byte> kSynthLeadArpeggio_u8 => "Synth Lead|Arpeggio\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthLeadOther = "Synth Lead|Other";
        
        public static ReadOnlySpan<byte> kSynthLeadOther_u8 => "Synth Lead|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthPad = "Synth Pad";
        
        public static ReadOnlySpan<byte> kSynthPad_u8 => "Synth Pad\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthPadSynthChoir = "Synth Pad|Synth Choir";
        
        public static ReadOnlySpan<byte> kSynthPadSynthChoir_u8 => "Synth Pad|Synth Choir\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthPadAnalog = "Synth Pad|Analog";
        
        public static ReadOnlySpan<byte> kSynthPadAnalog_u8 => "Synth Pad|Analog\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthPadDigital = "Synth Pad|Digital";
        
        public static ReadOnlySpan<byte> kSynthPadDigital_u8 => "Synth Pad|Digital\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthPadMotion = "Synth Pad|Motion";
        
        public static ReadOnlySpan<byte> kSynthPadMotion_u8 => "Synth Pad|Motion\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthPadOther = "Synth Pad|Other";
        
        public static ReadOnlySpan<byte> kSynthPadOther_u8 => "Synth Pad|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthComp = "Synth Comp";
        
        public static ReadOnlySpan<byte> kSynthComp_u8 => "Synth Comp\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthCompAnalog = "Synth Comp|Analog";
        
        public static ReadOnlySpan<byte> kSynthCompAnalog_u8 => "Synth Comp|Analog\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthCompDigital = "Synth Comp|Digital";
        
        public static ReadOnlySpan<byte> kSynthCompDigital_u8 => "Synth Comp|Digital\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kSynthCompOther = "Synth Comp|Other";
        
        public static ReadOnlySpan<byte> kSynthCompOther_u8 => "Synth Comp|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kVocal = "Vocal";
        
        public static ReadOnlySpan<byte> kVocal_u8 => "Vocal\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kVocalLeadVocal = "Vocal|Lead Vocal";
        
        public static ReadOnlySpan<byte> kVocalLeadVocal_u8 => "Vocal|Lead Vocal\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kVocalAdlibs = "Vocal|Adlibs";
        
        public static ReadOnlySpan<byte> kVocalAdlibs_u8 => "Vocal|Adlibs\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kVocalChoir = "Vocal|Choir";
        
        public static ReadOnlySpan<byte> kVocalChoir_u8 => "Vocal|Choir\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kVocalSolo = "Vocal|Solo";
        
        public static ReadOnlySpan<byte> kVocalSolo_u8 => "Vocal|Solo\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kVocalFX = "Vocal|FX";
        
        public static ReadOnlySpan<byte> kVocalFX_u8 => "Vocal|FX\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kVocalSpoken = "Vocal|Spoken";
        
        public static ReadOnlySpan<byte> kVocalSpoken_u8 => "Vocal|Spoken\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kVocalOther = "Vocal|Other";
        
        public static ReadOnlySpan<byte> kVocalOther_u8 => "Vocal|Other\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kWoodwinds = "Woodwinds";
        
        public static ReadOnlySpan<byte> kWoodwinds_u8 => "Woodwinds\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kWoodwindsEthnic = "Woodwinds|Ethnic";
        
        public static ReadOnlySpan<byte> kWoodwindsEthnic_u8 => "Woodwinds|Ethnic\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kWoodwindsFlute = "Woodwinds|Flute";
        
        public static ReadOnlySpan<byte> kWoodwindsFlute_u8 => "Woodwinds|Flute\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kWoodwindsOboe = "Woodwinds|Oboe";
        
        public static ReadOnlySpan<byte> kWoodwindsOboe_u8 => "Woodwinds|Oboe\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kWoodwindsEnglHorn = "Woodwinds|Engl. Horn";
        
        public static ReadOnlySpan<byte> kWoodwindsEnglHorn_u8 => "Woodwinds|Engl. Horn\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kWoodwindsClarinet = "Woodwinds|Clarinet";
        
        public static ReadOnlySpan<byte> kWoodwindsClarinet_u8 => "Woodwinds|Clarinet\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kWoodwindsSaxophone = "Woodwinds|Saxophone";
        
        public static ReadOnlySpan<byte> kWoodwindsSaxophone_u8 => "Woodwinds|Saxophone\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kWoodwindsBassoon = "Woodwinds|Bassoon";
        
        public static ReadOnlySpan<byte> kWoodwindsBassoon_u8 => "Woodwinds|Bassoon\0"u8;
    }
    
    public static partial class MusicalInstrument
    {
        public const string kWoodwindsOther = "Woodwinds|Other";
        
        public static ReadOnlySpan<byte> kWoodwindsOther_u8 => "Woodwinds|Other\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        /// <summary>
        ///  musicalStyle Predefined Musical Style
        /// </summary>
        /// <remarks>
        /// @
        /// {
        /// </remarks>
        public const string kAlternativeIndie = "Alternative/Indie";
        
        /// <summary>
        ///  musicalStyle Predefined Musical Style
        /// </summary>
        /// <remarks>
        /// @
        /// {
        /// </remarks>
        public static ReadOnlySpan<byte> kAlternativeIndie_u8 => "Alternative/Indie\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAlternativeIndieGothRock = "Alternative/Indie|Goth Rock";
        
        public static ReadOnlySpan<byte> kAlternativeIndieGothRock_u8 => "Alternative/Indie|Goth Rock\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAlternativeIndieGrunge = "Alternative/Indie|Grunge";
        
        public static ReadOnlySpan<byte> kAlternativeIndieGrunge_u8 => "Alternative/Indie|Grunge\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAlternativeIndieNewWave = "Alternative/Indie|New Wave";
        
        public static ReadOnlySpan<byte> kAlternativeIndieNewWave_u8 => "Alternative/Indie|New Wave\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAlternativeIndiePunk = "Alternative/Indie|Punk";
        
        public static ReadOnlySpan<byte> kAlternativeIndiePunk_u8 => "Alternative/Indie|Punk\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAlternativeIndieCollegeRock = "Alternative/Indie|College Rock";
        
        public static ReadOnlySpan<byte> kAlternativeIndieCollegeRock_u8 => "Alternative/Indie|College Rock\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAlternativeIndieDarkWave = "Alternative/Indie|Dark Wave";
        
        public static ReadOnlySpan<byte> kAlternativeIndieDarkWave_u8 => "Alternative/Indie|Dark Wave\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAlternativeIndieHardcore = "Alternative/Indie|Hardcore";
        
        public static ReadOnlySpan<byte> kAlternativeIndieHardcore_u8 => "Alternative/Indie|Hardcore\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAmbientChillOut = "Ambient/ChillOut";
        
        public static ReadOnlySpan<byte> kAmbientChillOut_u8 => "Ambient/ChillOut\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAmbientChillOutNewAgeMeditation = "Ambient/ChillOut|New Age/Meditation";
        
        public static ReadOnlySpan<byte> kAmbientChillOutNewAgeMeditation_u8 => "Ambient/ChillOut|New Age/Meditation\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAmbientChillOutDarkAmbient = "Ambient/ChillOut|Dark Ambient";
        
        public static ReadOnlySpan<byte> kAmbientChillOutDarkAmbient_u8 => "Ambient/ChillOut|Dark Ambient\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAmbientChillOutDowntempo = "Ambient/ChillOut|Downtempo";
        
        public static ReadOnlySpan<byte> kAmbientChillOutDowntempo_u8 => "Ambient/ChillOut|Downtempo\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kAmbientChillOutLounge = "Ambient/ChillOut|Lounge";
        
        public static ReadOnlySpan<byte> kAmbientChillOutLounge_u8 => "Ambient/ChillOut|Lounge\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kBlues = "Blues";
        
        public static ReadOnlySpan<byte> kBlues_u8 => "Blues\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kBluesAcousticBlues = "Blues|Acoustic Blues";
        
        public static ReadOnlySpan<byte> kBluesAcousticBlues_u8 => "Blues|Acoustic Blues\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kBluesCountryBlues = "Blues|Country Blues";
        
        public static ReadOnlySpan<byte> kBluesCountryBlues_u8 => "Blues|Country Blues\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kBluesElectricBlues = "Blues|Electric Blues";
        
        public static ReadOnlySpan<byte> kBluesElectricBlues_u8 => "Blues|Electric Blues\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kBluesChicagoBlues = "Blues|Chicago Blues";
        
        public static ReadOnlySpan<byte> kBluesChicagoBlues_u8 => "Blues|Chicago Blues\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassical = "Classical";
        
        public static ReadOnlySpan<byte> kClassical_u8 => "Classical\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalBaroque = "Classical|Baroque";
        
        public static ReadOnlySpan<byte> kClassicalBaroque_u8 => "Classical|Baroque\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalChamberMusic = "Classical|Chamber Music";
        
        public static ReadOnlySpan<byte> kClassicalChamberMusic_u8 => "Classical|Chamber Music\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalMedieval = "Classical|Medieval";
        
        public static ReadOnlySpan<byte> kClassicalMedieval_u8 => "Classical|Medieval\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalModernComposition = "Classical|Modern Composition";
        
        public static ReadOnlySpan<byte> kClassicalModernComposition_u8 => "Classical|Modern Composition\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalOpera = "Classical|Opera";
        
        public static ReadOnlySpan<byte> kClassicalOpera_u8 => "Classical|Opera\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalGregorian = "Classical|Gregorian";
        
        public static ReadOnlySpan<byte> kClassicalGregorian_u8 => "Classical|Gregorian\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalRenaissance = "Classical|Renaissance";
        
        public static ReadOnlySpan<byte> kClassicalRenaissance_u8 => "Classical|Renaissance\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalClassic = "Classical|Classic";
        
        public static ReadOnlySpan<byte> kClassicalClassic_u8 => "Classical|Classic\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalRomantic = "Classical|Romantic";
        
        public static ReadOnlySpan<byte> kClassicalRomantic_u8 => "Classical|Romantic\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kClassicalSoundtrack = "Classical|Soundtrack";
        
        public static ReadOnlySpan<byte> kClassicalSoundtrack_u8 => "Classical|Soundtrack\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kCountry = "Country";
        
        public static ReadOnlySpan<byte> kCountry_u8 => "Country\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kCountryCountryWestern = "Country|Country/Western";
        
        public static ReadOnlySpan<byte> kCountryCountryWestern_u8 => "Country|Country/Western\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kCountryHonkyTonk = "Country|Honky Tonk";
        
        public static ReadOnlySpan<byte> kCountryHonkyTonk_u8 => "Country|Honky Tonk\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kCountryUrbanCowboy = "Country|Urban Cowboy";
        
        public static ReadOnlySpan<byte> kCountryUrbanCowboy_u8 => "Country|Urban Cowboy\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kCountryBluegrass = "Country|Bluegrass";
        
        public static ReadOnlySpan<byte> kCountryBluegrass_u8 => "Country|Bluegrass\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kCountryAmericana = "Country|Americana";
        
        public static ReadOnlySpan<byte> kCountryAmericana_u8 => "Country|Americana\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kCountrySquaredance = "Country|Squaredance";
        
        public static ReadOnlySpan<byte> kCountrySquaredance_u8 => "Country|Squaredance\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kCountryNorthAmericanFolk = "Country|North American Folk";
        
        public static ReadOnlySpan<byte> kCountryNorthAmericanFolk_u8 => "Country|North American Folk\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDance = "Electronica/Dance";
        
        public static ReadOnlySpan<byte> kElectronicaDance_u8 => "Electronica/Dance\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceMinimal = "Electronica/Dance|Minimal";
        
        public static ReadOnlySpan<byte> kElectronicaDanceMinimal_u8 => "Electronica/Dance|Minimal\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceClassicHouse = "Electronica/Dance|Classic House";
        
        public static ReadOnlySpan<byte> kElectronicaDanceClassicHouse_u8 => "Electronica/Dance|Classic House\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceElektroHouse = "Electronica/Dance|Elektro House";
        
        public static ReadOnlySpan<byte> kElectronicaDanceElektroHouse_u8 => "Electronica/Dance|Elektro House\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceFunkyHouse = "Electronica/Dance|Funky House";
        
        public static ReadOnlySpan<byte> kElectronicaDanceFunkyHouse_u8 => "Electronica/Dance|Funky House\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceIndustrial = "Electronica/Dance|Industrial";
        
        public static ReadOnlySpan<byte> kElectronicaDanceIndustrial_u8 => "Electronica/Dance|Industrial\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceElectronicBodyMusic = "Electronica/Dance|Electronic Body Music";
        
        public static ReadOnlySpan<byte> kElectronicaDanceElectronicBodyMusic_u8 => "Electronica/Dance|Electronic Body Music\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceTripHop = "Electronica/Dance|Trip Hop";
        
        public static ReadOnlySpan<byte> kElectronicaDanceTripHop_u8 => "Electronica/Dance|Trip Hop\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceTechno = "Electronica/Dance|Techno";
        
        public static ReadOnlySpan<byte> kElectronicaDanceTechno_u8 => "Electronica/Dance|Techno\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceDrumNBassJungle = "Electronica/Dance|Drum'n'Bass/Jungle";
        
        public static ReadOnlySpan<byte> kElectronicaDanceDrumNBassJungle_u8 => "Electronica/Dance|Drum'n'Bass/Jungle\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceElektro = "Electronica/Dance|Elektro";
        
        public static ReadOnlySpan<byte> kElectronicaDanceElektro_u8 => "Electronica/Dance|Elektro\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceTrance = "Electronica/Dance|Trance";
        
        public static ReadOnlySpan<byte> kElectronicaDanceTrance_u8 => "Electronica/Dance|Trance\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceDub = "Electronica/Dance|Dub";
        
        public static ReadOnlySpan<byte> kElectronicaDanceDub_u8 => "Electronica/Dance|Dub\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kElectronicaDanceBigBeats = "Electronica/Dance|Big Beats";
        
        public static ReadOnlySpan<byte> kElectronicaDanceBigBeats_u8 => "Electronica/Dance|Big Beats\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kExperimental = "Experimental";
        
        public static ReadOnlySpan<byte> kExperimental_u8 => "Experimental\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kExperimentalNewMusic = "Experimental|New Music";
        
        public static ReadOnlySpan<byte> kExperimentalNewMusic_u8 => "Experimental|New Music\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kExperimentalFreeImprovisation = "Experimental|Free Improvisation";
        
        public static ReadOnlySpan<byte> kExperimentalFreeImprovisation_u8 => "Experimental|Free Improvisation\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kExperimentalElectronicArtMusic = "Experimental|Electronic Art Music";
        
        public static ReadOnlySpan<byte> kExperimentalElectronicArtMusic_u8 => "Experimental|Electronic Art Music\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kExperimentalNoise = "Experimental|Noise";
        
        public static ReadOnlySpan<byte> kExperimentalNoise_u8 => "Experimental|Noise\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kJazz = "Jazz";
        
        public static ReadOnlySpan<byte> kJazz_u8 => "Jazz\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kJazzNewOrleansJazz = "Jazz|New Orleans Jazz";
        
        public static ReadOnlySpan<byte> kJazzNewOrleansJazz_u8 => "Jazz|New Orleans Jazz\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kJazzTraditionalJazz = "Jazz|Traditional Jazz";
        
        public static ReadOnlySpan<byte> kJazzTraditionalJazz_u8 => "Jazz|Traditional Jazz\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kJazzOldtimeJazzDixiland = "Jazz|Oldtime Jazz/Dixiland";
        
        public static ReadOnlySpan<byte> kJazzOldtimeJazzDixiland_u8 => "Jazz|Oldtime Jazz/Dixiland\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kJazzFusion = "Jazz|Fusion";
        
        public static ReadOnlySpan<byte> kJazzFusion_u8 => "Jazz|Fusion\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kJazzAvantgarde = "Jazz|Avantgarde";
        
        public static ReadOnlySpan<byte> kJazzAvantgarde_u8 => "Jazz|Avantgarde\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kJazzLatinJazz = "Jazz|Latin Jazz";
        
        public static ReadOnlySpan<byte> kJazzLatinJazz_u8 => "Jazz|Latin Jazz\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kJazzFreeJazz = "Jazz|Free Jazz";
        
        public static ReadOnlySpan<byte> kJazzFreeJazz_u8 => "Jazz|Free Jazz\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kJazzRagtime = "Jazz|Ragtime";
        
        public static ReadOnlySpan<byte> kJazzRagtime_u8 => "Jazz|Ragtime\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kPop = "Pop";
        
        public static ReadOnlySpan<byte> kPop_u8 => "Pop\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kPopBritpop = "Pop|Britpop";
        
        public static ReadOnlySpan<byte> kPopBritpop_u8 => "Pop|Britpop\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kPopRock = "Pop|Pop/Rock";
        
        public static ReadOnlySpan<byte> kPopRock_u8 => "Pop|Pop/Rock\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kPopTeenPop = "Pop|Teen Pop";
        
        public static ReadOnlySpan<byte> kPopTeenPop_u8 => "Pop|Teen Pop\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kPopChartDance = "Pop|Chart Dance";
        
        public static ReadOnlySpan<byte> kPopChartDance_u8 => "Pop|Chart Dance\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kPop80sPop = "Pop|80's Pop";
        
        public static ReadOnlySpan<byte> kPop80sPop_u8 => "Pop|80's Pop\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kPopDancehall = "Pop|Dancehall";
        
        public static ReadOnlySpan<byte> kPopDancehall_u8 => "Pop|Dancehall\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kPopDisco = "Pop|Disco";
        
        public static ReadOnlySpan<byte> kPopDisco_u8 => "Pop|Disco\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetal = "Rock/Metal";
        
        public static ReadOnlySpan<byte> kRockMetal_u8 => "Rock/Metal\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalBluesRock = "Rock/Metal|Blues Rock";
        
        public static ReadOnlySpan<byte> kRockMetalBluesRock_u8 => "Rock/Metal|Blues Rock\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalClassicRock = "Rock/Metal|Classic Rock";
        
        public static ReadOnlySpan<byte> kRockMetalClassicRock_u8 => "Rock/Metal|Classic Rock\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalHardRock = "Rock/Metal|Hard Rock";
        
        public static ReadOnlySpan<byte> kRockMetalHardRock_u8 => "Rock/Metal|Hard Rock\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalRockRoll = "Rock/Metal|Rock &amp; Roll";
        
        public static ReadOnlySpan<byte> kRockMetalRockRoll_u8 => "Rock/Metal|Rock &amp; Roll\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalSingerSongwriter = "Rock/Metal|Singer/Songwriter";
        
        public static ReadOnlySpan<byte> kRockMetalSingerSongwriter_u8 => "Rock/Metal|Singer/Songwriter\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalHeavyMetal = "Rock/Metal|Heavy Metal";
        
        public static ReadOnlySpan<byte> kRockMetalHeavyMetal_u8 => "Rock/Metal|Heavy Metal\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalDeathBlackMetal = "Rock/Metal|Death/Black Metal";
        
        public static ReadOnlySpan<byte> kRockMetalDeathBlackMetal_u8 => "Rock/Metal|Death/Black Metal\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalNuMetal = "Rock/Metal|NuMetal";
        
        public static ReadOnlySpan<byte> kRockMetalNuMetal_u8 => "Rock/Metal|NuMetal\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalReggae = "Rock/Metal|Reggae";
        
        public static ReadOnlySpan<byte> kRockMetalReggae_u8 => "Rock/Metal|Reggae\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalBallad = "Rock/Metal|Ballad";
        
        public static ReadOnlySpan<byte> kRockMetalBallad_u8 => "Rock/Metal|Ballad\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalAlternativeRock = "Rock/Metal|Alternative Rock";
        
        public static ReadOnlySpan<byte> kRockMetalAlternativeRock_u8 => "Rock/Metal|Alternative Rock\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalRockabilly = "Rock/Metal|Rockabilly";
        
        public static ReadOnlySpan<byte> kRockMetalRockabilly_u8 => "Rock/Metal|Rockabilly\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalThrashMetal = "Rock/Metal|Thrash Metal";
        
        public static ReadOnlySpan<byte> kRockMetalThrashMetal_u8 => "Rock/Metal|Thrash Metal\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kRockMetalProgressiveRock = "Rock/Metal|Progressive Rock";
        
        public static ReadOnlySpan<byte> kRockMetalProgressiveRock_u8 => "Rock/Metal|Progressive Rock\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kUrbanHipHopRB = "Urban (Hip-Hop / R&B)";
        
        public static ReadOnlySpan<byte> kUrbanHipHopRB_u8 => "Urban (Hip-Hop / R&B)\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kUrbanHipHopRBClassic = "Urban (Hip-Hop / R&B)|Classic R&B";
        
        public static ReadOnlySpan<byte> kUrbanHipHopRBClassic_u8 => "Urban (Hip-Hop / R&B)|Classic R&B\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kUrbanHipHopRBModern = "Urban (Hip-Hop / R&B)|Modern R&B";
        
        public static ReadOnlySpan<byte> kUrbanHipHopRBModern_u8 => "Urban (Hip-Hop / R&B)|Modern R&B\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kUrbanHipHopRBPop = "Urban (Hip-Hop / R&B)|R&B Pop";
        
        public static ReadOnlySpan<byte> kUrbanHipHopRBPop_u8 => "Urban (Hip-Hop / R&B)|R&B Pop\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kUrbanHipHopRBWestCoastHipHop = "Urban (Hip-Hop / R&B)|WestCoast Hip-Hop";
        
        public static ReadOnlySpan<byte> kUrbanHipHopRBWestCoastHipHop_u8 => "Urban (Hip-Hop / R&B)|WestCoast Hip-Hop\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kUrbanHipHopRBEastCoastHipHop = "Urban (Hip-Hop / R&B)|EastCoast Hip-Hop";
        
        public static ReadOnlySpan<byte> kUrbanHipHopRBEastCoastHipHop_u8 => "Urban (Hip-Hop / R&B)|EastCoast Hip-Hop\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kUrbanHipHopRBRapHipHop = "Urban (Hip-Hop / R&B)|Rap/Hip Hop";
        
        public static ReadOnlySpan<byte> kUrbanHipHopRBRapHipHop_u8 => "Urban (Hip-Hop / R&B)|Rap/Hip Hop\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kUrbanHipHopRBSoul = "Urban (Hip-Hop / R&B)|Soul";
        
        public static ReadOnlySpan<byte> kUrbanHipHopRBSoul_u8 => "Urban (Hip-Hop / R&B)|Soul\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kUrbanHipHopRBFunk = "Urban (Hip-Hop / R&B)|Funk";
        
        public static ReadOnlySpan<byte> kUrbanHipHopRBFunk_u8 => "Urban (Hip-Hop / R&B)|Funk\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnic = "World/Ethnic";
        
        public static ReadOnlySpan<byte> kWorldEthnic_u8 => "World/Ethnic\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicAfrica = "World/Ethnic|Africa";
        
        public static ReadOnlySpan<byte> kWorldEthnicAfrica_u8 => "World/Ethnic|Africa\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicAsia = "World/Ethnic|Asia";
        
        public static ReadOnlySpan<byte> kWorldEthnicAsia_u8 => "World/Ethnic|Asia\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicCeltic = "World/Ethnic|Celtic";
        
        public static ReadOnlySpan<byte> kWorldEthnicCeltic_u8 => "World/Ethnic|Celtic\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicEurope = "World/Ethnic|Europe";
        
        public static ReadOnlySpan<byte> kWorldEthnicEurope_u8 => "World/Ethnic|Europe\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicKlezmer = "World/Ethnic|Klezmer";
        
        public static ReadOnlySpan<byte> kWorldEthnicKlezmer_u8 => "World/Ethnic|Klezmer\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicScandinavia = "World/Ethnic|Scandinavia";
        
        public static ReadOnlySpan<byte> kWorldEthnicScandinavia_u8 => "World/Ethnic|Scandinavia\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicEasternEurope = "World/Ethnic|Eastern Europe";
        
        public static ReadOnlySpan<byte> kWorldEthnicEasternEurope_u8 => "World/Ethnic|Eastern Europe\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicIndiaOriental = "World/Ethnic|India/Oriental";
        
        public static ReadOnlySpan<byte> kWorldEthnicIndiaOriental_u8 => "World/Ethnic|India/Oriental\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicNorthAmerica = "World/Ethnic|North America";
        
        public static ReadOnlySpan<byte> kWorldEthnicNorthAmerica_u8 => "World/Ethnic|North America\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicSouthAmerica = "World/Ethnic|South America";
        
        public static ReadOnlySpan<byte> kWorldEthnicSouthAmerica_u8 => "World/Ethnic|South America\0"u8;
    }
    
    public static partial class MusicalStyle
    {
        public const string kWorldEthnicAustralia = "World/Ethnic|Australia";
        
        public static ReadOnlySpan<byte> kWorldEthnicAustralia_u8 => "World/Ethnic|Australia\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        /// <summary>
        ///  musicalCharacter Predefined Musical Character
        /// </summary>
        /// <remarks>
        /// @
        /// {----TYPE------------------------------------
        /// </remarks>
        public const string kMono = "Mono";
        
        /// <summary>
        ///  musicalCharacter Predefined Musical Character
        /// </summary>
        /// <remarks>
        /// @
        /// {----TYPE------------------------------------
        /// </remarks>
        public static ReadOnlySpan<byte> kMono_u8 => "Mono\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kPoly = "Poly";
        
        public static ReadOnlySpan<byte> kPoly_u8 => "Poly\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kSplit = "Split";
        
        public static ReadOnlySpan<byte> kSplit_u8 => "Split\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kLayer = "Layer";
        
        public static ReadOnlySpan<byte> kLayer_u8 => "Layer\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kGlide = "Glide";
        
        public static ReadOnlySpan<byte> kGlide_u8 => "Glide\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kGlissando = "Glissando";
        
        public static ReadOnlySpan<byte> kGlissando_u8 => "Glissando\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kMajor = "Major";
        
        public static ReadOnlySpan<byte> kMajor_u8 => "Major\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kMinor = "Minor";
        
        public static ReadOnlySpan<byte> kMinor_u8 => "Minor\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kSingle = "Single";
        
        public static ReadOnlySpan<byte> kSingle_u8 => "Single\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kEnsemble = "Ensemble";
        
        public static ReadOnlySpan<byte> kEnsemble_u8 => "Ensemble\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kAcoustic = "Acoustic";
        
        public static ReadOnlySpan<byte> kAcoustic_u8 => "Acoustic\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kElectric = "Electric";
        
        public static ReadOnlySpan<byte> kElectric_u8 => "Electric\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kAnalog = "Analog";
        
        public static ReadOnlySpan<byte> kAnalog_u8 => "Analog\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kDigital = "Digital";
        
        public static ReadOnlySpan<byte> kDigital_u8 => "Digital\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kVintage = "Vintage";
        
        public static ReadOnlySpan<byte> kVintage_u8 => "Vintage\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kModern = "Modern";
        
        public static ReadOnlySpan<byte> kModern_u8 => "Modern\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kOld = "Old";
        
        public static ReadOnlySpan<byte> kOld_u8 => "Old\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kNew = "New";
        
        public static ReadOnlySpan<byte> kNew_u8 => "New\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        /// <summary>
        /// ----TONE------------------------------------
        /// </summary>
        public const string kClean = "Clean";
        
        /// <summary>
        /// ----TONE------------------------------------
        /// </summary>
        public static ReadOnlySpan<byte> kClean_u8 => "Clean\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kDistorted = "Distorted";
        
        public static ReadOnlySpan<byte> kDistorted_u8 => "Distorted\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kDry = "Dry";
        
        public static ReadOnlySpan<byte> kDry_u8 => "Dry\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kProcessed = "Processed";
        
        public static ReadOnlySpan<byte> kProcessed_u8 => "Processed\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kHarmonic = "Harmonic";
        
        public static ReadOnlySpan<byte> kHarmonic_u8 => "Harmonic\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kDissonant = "Dissonant";
        
        public static ReadOnlySpan<byte> kDissonant_u8 => "Dissonant\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kClear = "Clear";
        
        public static ReadOnlySpan<byte> kClear_u8 => "Clear\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kNoisy = "Noisy";
        
        public static ReadOnlySpan<byte> kNoisy_u8 => "Noisy\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kThin = "Thin";
        
        public static ReadOnlySpan<byte> kThin_u8 => "Thin\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kRich = "Rich";
        
        public static ReadOnlySpan<byte> kRich_u8 => "Rich\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kDark = "Dark";
        
        public static ReadOnlySpan<byte> kDark_u8 => "Dark\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kBright = "Bright";
        
        public static ReadOnlySpan<byte> kBright_u8 => "Bright\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kCold = "Cold";
        
        public static ReadOnlySpan<byte> kCold_u8 => "Cold\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kWarm = "Warm";
        
        public static ReadOnlySpan<byte> kWarm_u8 => "Warm\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kMetallic = "Metallic";
        
        public static ReadOnlySpan<byte> kMetallic_u8 => "Metallic\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kWooden = "Wooden";
        
        public static ReadOnlySpan<byte> kWooden_u8 => "Wooden\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kGlass = "Glass";
        
        public static ReadOnlySpan<byte> kGlass_u8 => "Glass\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kPlastic = "Plastic";
        
        public static ReadOnlySpan<byte> kPlastic_u8 => "Plastic\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        /// <summary>
        /// ----ENVELOPE------------------------------------
        /// </summary>
        public const string kPercussive = "Percussive";
        
        /// <summary>
        /// ----ENVELOPE------------------------------------
        /// </summary>
        public static ReadOnlySpan<byte> kPercussive_u8 => "Percussive\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kSoft = "Soft";
        
        public static ReadOnlySpan<byte> kSoft_u8 => "Soft\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kFast = "Fast";
        
        public static ReadOnlySpan<byte> kFast_u8 => "Fast\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kSlow = "Slow";
        
        public static ReadOnlySpan<byte> kSlow_u8 => "Slow\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kShort = "Short";
        
        public static ReadOnlySpan<byte> kShort_u8 => "Short\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kLong = "Long";
        
        public static ReadOnlySpan<byte> kLong_u8 => "Long\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kAttack = "Attack";
        
        public static ReadOnlySpan<byte> kAttack_u8 => "Attack\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kRelease = "Release";
        
        public static ReadOnlySpan<byte> kRelease_u8 => "Release\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kDecay = "Decay";
        
        public static ReadOnlySpan<byte> kDecay_u8 => "Decay\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kSustain = "Sustain";
        
        public static ReadOnlySpan<byte> kSustain_u8 => "Sustain\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kFastAttack = "Fast Attack";
        
        public static ReadOnlySpan<byte> kFastAttack_u8 => "Fast Attack\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kSlowAttack = "Slow Attack";
        
        public static ReadOnlySpan<byte> kSlowAttack_u8 => "Slow Attack\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kShortRelease = "Short Release";
        
        public static ReadOnlySpan<byte> kShortRelease_u8 => "Short Release\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kLongRelease = "Long Release";
        
        public static ReadOnlySpan<byte> kLongRelease_u8 => "Long Release\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kStatic = "Static";
        
        public static ReadOnlySpan<byte> kStatic_u8 => "Static\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kMoving = "Moving";
        
        public static ReadOnlySpan<byte> kMoving_u8 => "Moving\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kLoop = "Loop";
        
        public static ReadOnlySpan<byte> kLoop_u8 => "Loop\0"u8;
    }
    
    public static partial class MusicalCharacter
    {
        public const string kOneShot = "One Shot";
        
        public static ReadOnlySpan<byte> kOneShot_u8 => "One Shot\0"u8;
    }
    
    public partial class ComObjectManager
    {
        private static void RegisterAllInterfaces()
        {
            Register<FUnknown>();
            Register<IBStream>();
            Register<IAttributes>();
            Register<IAttributes2>();
            Register<IPluginBase>();
            Register<IPluginFactory>();
            Register<IPluginFactory2>();
            Register<IPluginFactory3>();
            Register<IStringResult>();
            Register<IPlugView>();
            Register<IPlugFrame>();
            Register<IPlugViewContentScaleSupport>();
            Register<IAttributeList>();
            Register<IStreamAttributes>();
            Register<IComponent>();
            Register<IEventList>();
            Register<IParameterChanges>();
            Register<IParamValueQueue>();
            Register<IAudioProcessor>();
            Register<IAudioPresentationLatency>();
            Register<IProcessContextRequirements>();
            Register<IAutomationState>();
            Register<IContextMenu>();
            Register<IContextMenuTarget>();
            Register<IComponentHandler3>();
            Register<IComponentHandler>();
            Register<IComponentHandler2>();
            Register<IComponentHandlerBusActivation>();
            Register<IProgress>();
            Register<IEditController>();
            Register<IEditController2>();
            Register<IMidiMapping>();
            Register<IEditControllerHostEditing>();
            Register<INoteExpressionController>();
            Register<IKeyswitchController>();
            Register<IMessage>();
            Register<IConnectionPoint>();
            Register<IHostApplication>();
            Register<IVst3WrapperMPESupport>();
            Register<IInterAppAudioPresetManager>();
            Register<IInterAppAudioHost>();
            Register<IMidiLearn>();
            Register<IParameterFunctionName>();
            Register<INoteExpressionPhysicalUIMapping>();
            Register<IPlugInterfaceSupport>();
            Register<IParameterFinder>();
            Register<IPrefetchableSupport>();
            Register<IXmlRepresentationController>();
            Register<ITestPlugProvider>();
            Register<ITestPlugProvider2>();
            Register<IUnitHandler>();
            Register<IUnitHandler2>();
            Register<IUnitInfo>();
            Register<IProgramListData>();
            Register<IUnitData>();
            Register<IInfoListener>();
        }
    }
    
    private static Dictionary<Guid, string> GetMapGuidToName()
    {
        return new Dictionary<Guid, string>()
        {
            { FUnknown.IId, nameof(FUnknown) },
            { IAttributeList.IId, nameof(IAttributeList) },
            { IAttributes.IId, nameof(IAttributes) },
            { IAttributes2.IId, nameof(IAttributes2) },
            { IAudioPresentationLatency.IId, nameof(IAudioPresentationLatency) },
            { IAudioProcessor.IId, nameof(IAudioProcessor) },
            { IAutomationState.IId, nameof(IAutomationState) },
            { IBStream.IId, nameof(IBStream) },
            { IComponent.IId, nameof(IComponent) },
            { IComponentHandler.IId, nameof(IComponentHandler) },
            { IComponentHandler2.IId, nameof(IComponentHandler2) },
            { IComponentHandler3.IId, nameof(IComponentHandler3) },
            { IComponentHandlerBusActivation.IId, nameof(IComponentHandlerBusActivation) },
            { IConnectionPoint.IId, nameof(IConnectionPoint) },
            { IContextMenu.IId, nameof(IContextMenu) },
            { IContextMenuTarget.IId, nameof(IContextMenuTarget) },
            { IEditController.IId, nameof(IEditController) },
            { IEditController2.IId, nameof(IEditController2) },
            { IEditControllerHostEditing.IId, nameof(IEditControllerHostEditing) },
            { IEventList.IId, nameof(IEventList) },
            { IHostApplication.IId, nameof(IHostApplication) },
            { IInfoListener.IId, nameof(IInfoListener) },
            { IInterAppAudioHost.IId, nameof(IInterAppAudioHost) },
            { IInterAppAudioPresetManager.IId, nameof(IInterAppAudioPresetManager) },
            { IKeyswitchController.IId, nameof(IKeyswitchController) },
            { IMessage.IId, nameof(IMessage) },
            { IMidiLearn.IId, nameof(IMidiLearn) },
            { IMidiMapping.IId, nameof(IMidiMapping) },
            { INoteExpressionController.IId, nameof(INoteExpressionController) },
            { INoteExpressionPhysicalUIMapping.IId, nameof(INoteExpressionPhysicalUIMapping) },
            { IParameterChanges.IId, nameof(IParameterChanges) },
            { IParameterFinder.IId, nameof(IParameterFinder) },
            { IParameterFunctionName.IId, nameof(IParameterFunctionName) },
            { IParamValueQueue.IId, nameof(IParamValueQueue) },
            { IPlugFrame.IId, nameof(IPlugFrame) },
            { IPluginBase.IId, nameof(IPluginBase) },
            { IPluginFactory.IId, nameof(IPluginFactory) },
            { IPluginFactory2.IId, nameof(IPluginFactory2) },
            { IPluginFactory3.IId, nameof(IPluginFactory3) },
            { IPlugInterfaceSupport.IId, nameof(IPlugInterfaceSupport) },
            { IPlugView.IId, nameof(IPlugView) },
            { IPlugViewContentScaleSupport.IId, nameof(IPlugViewContentScaleSupport) },
            { IPrefetchableSupport.IId, nameof(IPrefetchableSupport) },
            { IProcessContextRequirements.IId, nameof(IProcessContextRequirements) },
            { IProgramListData.IId, nameof(IProgramListData) },
            { IProgress.IId, nameof(IProgress) },
            { IStreamAttributes.IId, nameof(IStreamAttributes) },
            { IStringResult.IId, nameof(IStringResult) },
            { ITestPlugProvider.IId, nameof(ITestPlugProvider) },
            { ITestPlugProvider2.IId, nameof(ITestPlugProvider2) },
            { IUnitData.IId, nameof(IUnitData) },
            { IUnitHandler.IId, nameof(IUnitHandler) },
            { IUnitHandler2.IId, nameof(IUnitHandler2) },
            { IUnitInfo.IId, nameof(IUnitInfo) },
            { IVst3WrapperMPESupport.IId, nameof(IVst3WrapperMPESupport) },
            { IXmlRepresentationController.IId, nameof(IXmlRepresentationController) },
        };
    }
}
